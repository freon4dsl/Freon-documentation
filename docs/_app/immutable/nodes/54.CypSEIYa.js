import{s as ct,A as _t,a as k,e as y,f as S,b as $,m as R,i as w,B as vt,g as f,v as ht,x as et,w as bt,t as W,o as X,d as C,h as u,j as v,C as yt,D as ft,E,q as pt,p as ut}from"../chunks/scheduler.CIEH-92L.js";import{S as mt,i as gt,e as $t,c as D,a as P,m as M,t as B,b as H,d as N}from"../chunks/index.HLF2pGCU.js";import{e as z}from"../chunks/each.BLebZWAa.js";import{w as At}from"../chunks/index.bxqR-5-s.js";import{P as nt,S as Tt,c as wt,B as kt}from"../chunks/index.D1zh88jY.js";const G=At([]);function St(i){let t;return{c(){t=W("Freon Terminology")},l(e){t=X(e,"Freon Terminology")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Ct(i){let t,e,n,o,s,d,r=`<thead><tr><th>Phrase</th> <th>Description</th></tr></thead> <tbody><tr><td>abstract syntax tree</td> <td>An internal representation the model, a tree of nodes, each of which is an instance of a structural element of the language.</td></tr> <tr><td>action</td> <td>Certain behaviour of the editor, for instance, the reaction to a key stroke.</td></tr> <tr><td>AST</td> <td>Abstract Syntax Tree</td></tr> <tr><td>ast file</td> <td>File containing the definition of the metamodel of the language. The extension must be â€˜.astâ€™.</td></tr> <tr><td>box</td> <td>A TypeScript class that represents a rectangle on the editor screen.</td></tr> <tr><td>box tree / box model</td> <td>A tree of boxes that represent the appearance of a model in the editor</td></tr> <tr><td>concept</td> <td>A structural element in the language.</td></tr> <tr><td>concrete syntax tree</td> <td>A tree of elements that represent the appearance of a model. In Freon, it is equal to the box model.</td></tr> <tr><td>conformsto</td> <td>A predefined function in the typer, which defines that a certain type conforms to another type. The function can also be used in
				the validator.</td></tr> <tr><td>CST</td> <td>Concrete Syntax Tree</td></tr> <tr><td>custom scoper</td> <td>A scoper that is written in TypeScript and either augments or replaces the Freon scoper.</td></tr> <tr><td>custom typer</td> <td>A typer that is written in TypeScript and either augments or replaces the Freon typer.</td></tr> <tr><td>edit file</td> <td>File containing the definition of the editors, or projection sets of the language. The extension must be â€˜.editâ€™.</td></tr> <tr><td>editor</td> <td>A loosely used term to refer to the runtime tool in the browser, or to a certain projection set.</td></tr> <tr><td>enumeration</td> <td>See limited concept.</td></tr> <tr><td>equalsto</td> <td>A predefined function in the typer, which defines that a certain type is considered to be equal to another type. The function can
				also be used in the validator.</td></tr> <tr><td>expression concept</td> <td>A structural element in the language that can be used as an expression.</td></tr> <tr><td>external component</td> <td>A Svelte component that is added by the language engineer to the Freon projection(s).</td></tr> <tr><td>fragment</td> <td>A part of a projection definition.</td></tr> <tr><td>inference rule</td> <td>A built-in function in the typer definition that defines the type of a term.</td></tr> <tr><td>interpreter</td> <td>A tool that takes the AST (the represeantation of the model) and calculates a value to be associated with certain terms in the
				model.</td></tr> <tr><td>is-unique rule</td> <td>A built-in function in the validator definition that defines a check on whether all elements in a list are unique. (Making the list
				a strict set.)</td></tr> <tr><td>language engineer</td> <td>The person using Freon to create a DSL and the tools to use the DSL.</td></tr> <tr><td>limited concept</td> <td>A structural element in the language, that can only have a limited number of predefined instances. A more extensive version of an
				enumeration.</td></tr> <tr><td>metamodel</td> <td>The definition of the structure of the language, i.e. which kind of elements are part of the language and how they relate.</td></tr> <tr><td>model</td> <td>An instance of the language metamodel, like an object is an instance of a class. The model is what the user is interested in.</td></tr> <tr><td>model unit</td> <td>Part of a model that can be edited, or otherwise handled, separately from the rest of the model.</td></tr> <tr><td>named editor</td> <td>A projection set.</td></tr> <tr><td>named property projection</td> <td>A single projection in a (named) projection set.</td></tr> <tr><td>namespace</td> <td>A structural element that is the container for a set of names of parts of the model.</td></tr> <tr><td>namespace addition</td> <td>A built-in function in the scoper definition that adds the set of names from one namespace to another namespace.</td></tr> <tr><td>not-empty rule</td> <td>A built-in function in the validator definition that defines a check on whether a list is empty.</td></tr> <tr><td>precedence of projections</td> <td>In a set of projections for the same concept, the priority of one projection sover the other.</td></tr> <tr><td>projection</td> <td>A definition of how a single structural element in the language should appear on the screen or in text.</td></tr> <tr><td>projection set</td> <td>A named set of projection definitions, one per structural element in the language.</td></tr> <tr><td>scope provider</td> <td>A piece of code that is able to determine for each term in the model which names of other elements of the model are visible.</td></tr> <tr><td>scoper</td> <td>The Freon name for scope provider.</td></tr> <tr><td>scoper file</td> <td>File containing the definition of the scope provider for the language. The extension must be â€˜.scopeâ€™.</td></tr> <tr><td>symbol</td> <td>The concrete syntax to be used for the operator in a binary expression. For instance the â€™+â€™ in â€˜4+5â€™.</td></tr> <tr><td>term</td> <td>Part of a model that can be associated with a type (using a typer), or with a value (using an interpreter).</td></tr> <tr><td>trigger</td> <td>The key stroke, or series of key strokes, that the user must enter to let the editor perform a certain function.</td></tr> <tr><td>type checking rule</td> <td>A built-in function in the validator definition that defines a check on whether a term has a certain type.</td></tr> <tr><td>type concept</td> <td>A concept that is not part of the AST, but is needed to provide the type of a term.</td></tr> <tr><td>type provider</td> <td>A piece of code that is able to determine for each term in the model which type to associate with that term.</td></tr> <tr><td>typer</td> <td>The Freon name for type provider.</td></tr> <tr><td>typer file</td> <td>File containing the definition of the type provider for the language. The extension must be â€˜.typeâ€™.</td></tr> <tr><td>user</td> <td>The person using the tools, i.e. editor, scoper, etc, to create models in a certain DSL.</td></tr> <tr><td>valid file</td> <td>File containing the definition of the validator for the language. The extension must be â€˜.validâ€™.</td></tr> <tr><td>validator</td> <td>A piece of code that is able to determine for each term in the model whether the term is correct or erroneous.</td></tr> <tr><td>valid-identifier-rule</td> <td>A built-in function in the validator definition that defines a check on whether a string is a valid identifier.</td></tr> <tr><td>where-clause</td> <td>A part of a typer definition that defines conditions for all properties of a concept. It is used in â€˜equalstoâ€™ and â€˜conformstoâ€™
				definitions.</td></tr></tbody>`,a,h,T;t=new nt({props:{prevLink:rt,nextLink:ot}});function A(l){i[1](l)}let j={tag:"h1",id:"freon-terminology-1",$$slots:{default:[St]},$$scope:{ctx:i}};return i[0][0]!==void 0&&(j.intersecting=i[0][0]),n=new Tt({props:j}),_t.push(()=>$t(n,"intersecting",A)),h=new nt({props:{prevLink:rt,nextLink:ot}}),{c(){D(t.$$.fragment),e=k(),D(n.$$.fragment),s=k(),d=y("table"),d.innerHTML=r,a=k(),D(h.$$.fragment)},l(l){P(t.$$.fragment,l),e=S(l),P(n.$$.fragment,l),s=S(l),d=$(l,"TABLE",{"data-svelte-h":!0}),R(d)!=="svelte-1m6okrd"&&(d.innerHTML=r),a=S(l),P(h.$$.fragment,l)},m(l,m){M(t,l,m),w(l,e,m),M(n,l,m),w(l,s,m),w(l,d,m),w(l,a,m),M(h,l,m),T=!0},p(l,[m]){const q={};m&8&&(q.$$scope={dirty:m,ctx:l}),!o&&m&1&&(o=!0,q.intersecting=l[0][0],vt(()=>o=!1)),n.$set(q)},i(l){T||(B(t.$$.fragment,l),B(n.$$.fragment,l),B(h.$$.fragment,l),T=!0)},o(l){H(t.$$.fragment,l),H(n.$$.fragment,l),H(h.$$.fragment,l),T=!1},d(l){l&&(f(e),f(s),f(d),f(a)),N(t,l),N(n,l),N(h,l)}}}let rt="/Documentation/Under_the_Hood/FreTool_Interfaces",ot="/Tutorial";function Ft(i,t,e){let n;ht(i,G,d=>e(2,n=d)),et(G,n=[{title:"Freon Terminology",visible:!1,ref:"#freon-terminology-1"}],n);let o=[];bt(()=>{document.querySelectorAll("pre").forEach(r=>{const a=document.createElement("div");a.className="copy-prompt";const h=document.createElement("p");h.innerHTML="ðŸ‘† Click to copy",h.className="copy-prompt-p";const T=document.createElement("img");T.src="/icons/copy-icon.svg",T.className="copy-prompt-img",a.appendChild(T),a.appendChild(h),r.appendChild(a),r.querySelector(".copy-prompt > p").addEventListener("click",A=>{wt(r.querySelector("code").textContent),r.querySelector(".copy-prompt > p").innerHTML="Copied!",setTimeout(()=>{r.querySelector(".copy-prompt > p").innerHTML="ðŸ‘† Click to copy"},1e3)})})});function s(d){i.$$.not_equal(o[0],d)&&(o[0]=d,e(0,o))}return i.$$.update=()=>{i.$$.dirty&1&&et(G,n[0].visible=o[0],n)},[o,s]}class Et extends mt{constructor(t){super(),gt(this,t,Ft,Ct,ct,{})}}function it(i,t,e){const n=i.slice();return n[6]=t[e],n[8]=e,n}function at(i,t,e){const n=i.slice();return n[6]=t[e],n[8]=e,n}function jt(i){let t,e;return{c(){t=y("img"),this.h()},l(n){t=$(n,"IMG",{class:!0,src:!0,alt:!0}),this.h()},h(){u(t,"class","page-toc-small-img"),ut(t.src,e="/icons/down-arrow.png")||u(t,"src",e),u(t,"alt","arrow down")},m(n,o){w(n,t,o)},d(n){n&&f(t)}}}function Lt(i){let t,e;return{c(){t=y("img"),this.h()},l(n){t=$(n,"IMG",{class:!0,src:!0,alt:!0}),this.h()},h(){u(t,"class","page-toc-small-img"),ut(t.src,e="/icons/upload.png")||u(t,"src",e),u(t,"alt","arrow up")},m(n,o){w(n,t,o)},d(n){n&&f(t)}}}function st(i){let t,e,n=z(i[0]),o=[];for(let s=0;s<n.length;s+=1)o[s]=lt(at(i,n,s));return{c(){t=y("div"),e=y("ul");for(let s=0;s<o.length;s+=1)o[s].c();this.h()},l(s){t=$(s,"DIV",{class:!0});var d=C(t);e=$(d,"UL",{class:!0});var r=C(e);for(let a=0;a<o.length;a+=1)o[a].l(r);r.forEach(f),d.forEach(f),this.h()},h(){u(e,"class","page-ul"),u(t,"class","toc-details")},m(s,d){w(s,t,d),v(t,e);for(let r=0;r<o.length;r+=1)o[r]&&o[r].m(e,null)},p(s,d){if(d&5){n=z(s[0]);let r;for(r=0;r<n.length;r+=1){const a=at(s,n,r);o[r]?o[r].p(a,d):(o[r]=lt(a),o[r].c(),o[r].m(e,null))}for(;r<o.length;r+=1)o[r].d(1);o.length=n.length}},d(s){s&&f(t),ft(o,s)}}}function lt(i){let t,e,n=i[6].title+"",o,s,d;return{c(){t=y("li"),e=y("a"),o=W(n),d=k(),this.h()},l(r){t=$(r,"LI",{class:!0});var a=C(t);e=$(a,"A",{href:!0});var h=C(e);o=X(h,n),h.forEach(f),d=S(a),a.forEach(f),this.h()},h(){u(e,"href",s=i[6].ref),E(e,"page-visible",i[8]===i[2]),E(e,"page-nonvisible",i[8]!==i[2]),u(t,"class","page-toc-text")},m(r,a){w(r,t,a),v(t,e),v(e,o),v(t,d)},p(r,a){a&1&&n!==(n=r[6].title+"")&&pt(o,n),a&1&&s!==(s=r[6].ref)&&u(e,"href",s),a&4&&E(e,"page-visible",r[8]===r[2]),a&4&&E(e,"page-nonvisible",r[8]!==r[2])},d(r){r&&f(t)}}}function dt(i){let t,e,n=i[6].title+"",o,s,d;return{c(){t=y("li"),e=y("a"),o=W(n),d=k(),this.h()},l(r){t=$(r,"LI",{class:!0});var a=C(t);e=$(a,"A",{href:!0});var h=C(e);o=X(h,n),h.forEach(f),d=S(a),a.forEach(f),this.h()},h(){u(e,"href",s=i[6].ref),E(e,"page-visible",i[8]===i[2]),E(e,"page-nonvisible",i[8]!==i[2]),u(t,"class","page-toc-text")},m(r,a){w(r,t,a),v(t,e),v(e,o),v(t,d)},p(r,a){a&1&&n!==(n=r[6].title+"")&&pt(o,n),a&1&&s!==(s=r[6].ref)&&u(e,"href",s),a&4&&E(e,"page-visible",r[8]===r[2]),a&4&&E(e,"page-nonvisible",r[8]!==r[2])},d(r){r&&f(t)}}}function qt(i){let t,e,n,o="On this page ...",s,d,r,a,h,T,A,j,l,m,q="On this page",J,L,U,K,Y;function Z(c,_){return c[1]?Lt:jt}let V=Z(i),F=V(i),b=i[1]&&st(i);h=new kt({}),A=new Et({});let x=z(i[0]),g=[];for(let c=0;c<x.length;c+=1)g[c]=dt(it(i,x,c));return{c(){t=y("div"),e=y("div"),n=y("p"),n.textContent=o,s=k(),d=y("button"),F.c(),r=k(),b&&b.c(),a=k(),D(h.$$.fragment),T=k(),D(A.$$.fragment),j=k(),l=y("nav"),m=y("h3"),m.textContent=q,J=k(),L=y("ul");for(let c=0;c<g.length;c+=1)g[c].c();this.h()},l(c){t=$(c,"DIV",{class:!0});var _=C(t);e=$(_,"DIV",{class:!0});var p=C(e);n=$(p,"P",{class:!0,"data-svelte-h":!0}),R(n)!=="svelte-1929lhs"&&(n.textContent=o),s=S(p),d=$(p,"BUTTON",{class:!0});var I=C(d);F.l(I),I.forEach(f),p.forEach(f),r=S(_),b&&b.l(_),a=S(_),P(h.$$.fragment,_),T=S(_),P(A.$$.fragment,_),_.forEach(f),j=S(c),l=$(c,"NAV",{class:!0});var O=C(l);m=$(O,"H3",{class:!0,"data-svelte-h":!0}),R(m)!=="svelte-1hgt7fi"&&(m.textContent=q),J=S(O),L=$(O,"UL",{class:!0});var tt=C(L);for(let Q=0;Q<g.length;Q+=1)g[Q].l(tt);tt.forEach(f),O.forEach(f),this.h()},h(){u(n,"class","page-toc-small-title"),u(d,"class","page-toc-small-expand-button"),u(e,"class","page-toc-small"),u(t,"class","page-main"),u(m,"class","page-toc-title"),u(L,"class","page-ul"),u(l,"class","page-toc")},m(c,_){w(c,t,_),v(t,e),v(e,n),v(e,s),v(e,d),F.m(d,null),v(t,r),b&&b.m(t,null),v(t,a),M(h,t,null),v(t,T),M(A,t,null),w(c,j,_),w(c,l,_),v(l,m),v(l,J),v(l,L);for(let p=0;p<g.length;p+=1)g[p]&&g[p].m(L,null);U=!0,K||(Y=yt(d,"click",i[4]),K=!0)},p(c,[_]){if(V!==(V=Z(c))&&(F.d(1),F=V(c),F&&(F.c(),F.m(d,null))),c[1]?b?b.p(c,_):(b=st(c),b.c(),b.m(t,a)):b&&(b.d(1),b=null),_&5){x=z(c[0]);let p;for(p=0;p<x.length;p+=1){const I=it(c,x,p);g[p]?g[p].p(I,_):(g[p]=dt(I),g[p].c(),g[p].m(L,null))}for(;p<g.length;p+=1)g[p].d(1);g.length=x.length}},i(c){U||(B(h.$$.fragment,c),B(A.$$.fragment,c),U=!0)},o(c){H(h.$$.fragment,c),H(A.$$.fragment,c),U=!1},d(c){c&&(f(t),f(j),f(l)),F.d(),b&&b.d(),N(h),N(A),ft(g,c),K=!1,Y()}}}function xt(i,t,e){let n,o;ht(i,G,h=>e(0,o=h));let s=!1;function d(h){let T=n;for(let A=0;A<h.length;A++)if(h[A].visible)return A;return T}function r(){e(1,s=!s)}const a=()=>{r()};return i.$$.update=()=>{i.$$.dirty&1&&e(2,n=d(o))},[o,s,n,r,a]}class Ht extends mt{constructor(t){super(),gt(this,t,xt,qt,ct,{})}}export{Ht as component};
//# sourceMappingURL=54.CypSEIYa.js.map
