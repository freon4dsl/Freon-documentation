import{S as Z,i as ee,s as te,e as $,t as r,k,w as W,c as y,a as g,h as i,d as a,m as x,x as X,b as oe,g as m,H as s,y as B,q as z,o as J,B as K}from"../../chunks/vendor-0dc77bd0.js";import{N as Y}from"../../chunks/Note-b0db7989.js";import{F as ne}from"../../chunks/Figure-4dd15a94.js";/* empty css                                                      *//* empty css                                                        */function ae(p){let t;return{c(){t=r("Incomplete code")},l(o){t=i(o,"Incomplete code")},m(o,c){m(o,t,c)},d(o){o&&a(t)}}}function se(p){let t;return{c(){t=r(`Note that every command except *all*, used individually (i.e. without the other commands), generates code that
does not compile correctly.
For instance, both the scoper and validator might need to use the typer, therefore the
code seeks to include the typer class, which might not be generated yet. Likewise, the editor seeks to include
the scoper.
The best way to go about is to first use the *all* command. Next, when you focus on one of the aspects of your
language, you can use the specific command for that aspect. Thus, you can keep regeneration-time as short as possible.`)},l(o){t=i(o,`Note that every command except *all*, used individually (i.e. without the other commands), generates code that
does not compile correctly.
For instance, both the scoper and validator might need to use the typer, therefore the
code seeks to include the typer class, which might not be generated yet. Likewise, the editor seeks to include
the scoper.
The best way to go about is to first use the *all* command. Next, when you focus on one of the aspects of your
language, you can use the specific command for that aspect. Thus, you can keep regeneration-time as short as possible.`)},m(o,c){m(o,t,c)},d(o){o&&a(t)}}}function re(p){let t;return{c(){t=r("Watch Option")},l(o){t=i(o,"Watch Option")},m(o,c){m(o,t,c)},d(o){o&&a(t)}}}function ie(p){let t;return{c(){t=r("There also is a `-watch` option to automatically run the *all* command when a definition file changes.")},l(o){t=i(o,"There also is a `-watch` option to automatically run the *all* command when a definition file changes.")},m(o,c){m(o,t,c)},d(o){o&&a(t)}}}function ce(p){let t,o,c,l,M,w,P,S,v,A,C,b,D,G,T,_,N,f,q,F,H,U,O,u,I,d,j;return _=new ne({props:{imageName:"projectit-command-line-options.png",caption:"Screenshot of commandline options",figureNumber:1}}),u=new Y({props:{$$slots:{content:[se],header:[ae]},$$scope:{ctx:p}}}),d=new Y({props:{$$slots:{content:[ie],header:[re]},$$scope:{ctx:p}}}),{c(){t=$("h1"),o=r("Use of the Freon Generator"),c=k(),l=$("p"),M=r(`The Freon commandline tool generates code from the various definition files as described in
`),w=$("a"),P=r("A Language in Five Parts"),S=r(`.
If you type \u2018`),v=$("code"),A=r("projectit"),C=r(`\u2019 in a (bash) terminal you will see
an overview of the different
arguments that can be used. For detailed help about a specific command, type: \u2018`),b=$("code"),D=r("projectit <command> -h"),G=r("\u2019."),T=k(),W(_.$$.fragment),N=k(),f=$("p"),q=r(`// TODO  update screenshot to current
// FIXME  `),F=$("em"),H=r("all"),U=r(" within a Svelte fragment doesn\u2019t render as Markdown"),O=k(),W(u.$$.fragment),I=k(),W(d.$$.fragment),this.h()},l(e){t=y(e,"H1",{});var n=g(t);o=i(n,"Use of the Freon Generator"),n.forEach(a),c=x(e),l=y(e,"P",{});var h=g(l);M=i(h,`The Freon commandline tool generates code from the various definition files as described in
`),w=y(h,"A",{href:!0});var E=g(w);P=i(E,"A Language in Five Parts"),E.forEach(a),S=i(h,`.
If you type \u2018`),v=y(h,"CODE",{});var Q=g(v);A=i(Q,"projectit"),Q.forEach(a),C=i(h,`\u2019 in a (bash) terminal you will see
an overview of the different
arguments that can be used. For detailed help about a specific command, type: \u2018`),b=y(h,"CODE",{});var R=g(b);D=i(R,"projectit <command> -h"),R.forEach(a),G=i(h,"\u2019."),h.forEach(a),T=x(e),X(_.$$.fragment,e),N=x(e),f=y(e,"P",{});var L=g(f);q=i(L,`// TODO  update screenshot to current
// FIXME  `),F=y(L,"EM",{});var V=g(F);H=i(V,"all"),V.forEach(a),U=i(L," within a Svelte fragment doesn\u2019t render as Markdown"),L.forEach(a),O=x(e),X(u.$$.fragment,e),I=x(e),X(d.$$.fragment,e),this.h()},h(){oe(w,"href","/010_Intro/040_A_Language_in_Five_Parts")},m(e,n){m(e,t,n),s(t,o),m(e,c,n),m(e,l,n),s(l,M),s(l,w),s(w,P),s(l,S),s(l,v),s(v,A),s(l,C),s(l,b),s(b,D),s(l,G),m(e,T,n),B(_,e,n),m(e,N,n),m(e,f,n),s(f,q),s(f,F),s(F,H),s(f,U),m(e,O,n),B(u,e,n),m(e,I,n),B(d,e,n),j=!0},p(e,[n]){const h={};n&1&&(h.$$scope={dirty:n,ctx:e}),u.$set(h);const E={};n&1&&(E.$$scope={dirty:n,ctx:e}),d.$set(E)},i(e){j||(z(_.$$.fragment,e),z(u.$$.fragment,e),z(d.$$.fragment,e),j=!0)},o(e){J(_.$$.fragment,e),J(u.$$.fragment,e),J(d.$$.fragment,e),j=!1},d(e){e&&a(t),e&&a(c),e&&a(l),e&&a(T),K(_,e),e&&a(N),e&&a(f),e&&a(O),K(u,e),e&&a(I),K(d,e)}}}class de extends Z{constructor(t){super();ee(this,t,null,ce,te,{})}}export{de as default};
