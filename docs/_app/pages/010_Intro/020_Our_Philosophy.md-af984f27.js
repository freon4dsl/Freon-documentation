import{S as rr,i as nr,s as ir,e as i,t as r,k as h,c as l,a as s,g as n,d as o,n as p,b as d,a1 as lr,f,F as t,H as Eo}from"../../chunks/vendor-0216fdcb.js";function sr(or){let _,Je,we,N,Xe,_e,L,P,Z,Ye,Ze,S,$e,et,Pe,D,tt,ke,k,ot,R,rt,nt,xe,x,it,$,lt,st,Ie,v,at,ee,ft,ht,te,pt,ct,Te,F,dt,Oe,c,mt,oe,ut,vt,re,bt,gt,I,wo,yt,ne,Et,wt,ie,_t,Pt,je,b,M,kt,le,xt,It,Tt,G,Ot,se,jt,At,St,q,Rt,ae,Mt,Gt,Ae,g,qt,fe,Nt,Lt,he,Dt,Ft,Se,y,Ht,pe,Kt,Ut,H,Ct,Wt,Re,K,Bt,Me,E,Qt,U,Vt,zt,ce,Jt,Xt,Ge,T,Yt,qe,Ne,Le,m,C,de,Zt,$t,eo,me,to,oo,ue,ro,no,io,De,O,lo,ve,so,ao,Fe,w,be,fo,ho,ge,po,co,ye,mo,He,W,uo,Ke,j,vo,B,bo,go;return{c(){_=i("h1"),Je=r("Our Philosophy"),we=h(),N=i("p"),Xe=r(`The design philosophy that we follow in ProjectIt can best be described by the following quote from
the well-known graphical user interface designer Alan Kay.`),_e=h(),L=i("blockquote"),P=i("p"),Z=i("em"),Ye=r("Simple things should be simple, complex things should be possible."),Ze=r(`
(`),S=i("a"),$e=r("Alan Kay, Turing Award Winner"),et=r(")"),Pe=h(),D=i("h2"),tt=r("The Pareto Principle"),ke=h(),k=i("p"),ot=r(`ProjectIt is a minimal viable product which supports the
language engineer in creating a work environment for a mini-language. A key principle
is the `),R=i("a"),rt=r("Pareto principle"),nt=r(`
(or 80%-20% rule),
which states that for many events, roughly 80% of the effects come from 20% of the causes.
For example, it is an axiom of business  management that \u201C80% of sales come from 20% of clients\u201D.`),xe=h(),x=i("p"),it=r("In software development the Pareto principle translates to \u201C"),$=i("em"),lt=r(`80% of the development
effort is spend on 20% of the application`),st=r(`\u201D, this 20% being the more complex parts.
Still, the other 80% of the application needs to be created as well.`),Ie=h(),v=i("p"),at=r(`ProjectIt aims to
make the latter `),ee=i("strong"),ft=r("as simple as possible"),ht=r(", while keeping the generated code "),te=i("strong"),pt=r("open"),ct=r(` for the
language engineer to code the more complex parts by hand. One of our use cases is the
creation of a prototype language in a day or in a couple of days at most.`),Te=h(),F=i("h2"),dt=r("Other Guidelines"),Oe=h(),c=i("p"),mt=r("Other guidelines have been "),oe=i("strong"),ut=r("ease of use"),vt=r(", and "),re=i("strong"),bt=r("flexibility"),gt=r(". ProjectIt may not (yet "),I=i("img"),yt=r(`) do
everything you need, but what it does, should be very easy to get into. Furthermore,
ProjectIt is designed to be `),ne=i("strong"),Et=r("extendable"),wt=r(", and "),ie=i("strong"),_t=r("easy to integrate with other tooling"),Pt=r(`.
In practise this means that:`),je=h(),b=i("ul"),M=i("li"),kt=r("Every part of the work environment that is generated, can be "),le=i("em"),xt=r("exchanged"),It=r(` for one
that suits the language engineer better, provided the right interface is implemented.`),Tt=h(),G=i("li"),Ot=r(`Every part of the work environment is made by its own generator, so you can adjust which
parts you want to generate and which parts you `),se=i("em"),jt=r("omit"),At=r("."),St=h(),q=i("li"),Rt=r(`The different parts of the work environment can be run on either the server or the client.
Thus creating `),ae=i("em"),Mt=r("multiple deployment options"),Gt=r("."),Ae=h(),g=i("p"),qt=r(`With these principles in mind, we have started of small and simple. Every definition language,
from the language structure to the validation rules, is kept `),fe=i("strong"),Nt=r("minimal"),Lt=r(". Over time, in an "),he=i("strong"),Dt=r("agile"),Ft=r(`
fashion, these will be extended whenever the need arises.`),Se=h(),y=i("p"),Ht=r("Furthermore, we intend to use "),pe=i("strong"),Kt=r("bootstrapping"),Ut=r(` in one of the next versions of ProjectIt
to create editors for every one of the definition languages. If you are interested, you can
check out our `),H=i("a"),Ct=r("wish list"),Wt=r(" of features to be developed in the future."),Re=h(),K=i("h2"),Bt=r("Name-Based References"),Me=h(),E=i("p"),Qt=r("In "),U=i("a"),Vt=r("Support for Expressions"),zt=r(` we explain
that editing expressions is a known challenge for projectional editors. A second challenge
is posed by `),ce=i("em"),Jt=r("references"),Xt=r(", which is stated in"),Ge=h(),T=i("a"),Yt=r("Efficiency of Projectional Editing: A Controlled Experiment"),qe=r(` as follows.
`),Ne=i("hr"),Le=h(),m=i("blockquote"),C=i("p"),de=i("strong"),Zt=r("References."),$t=r(`
References are based on pointers to the targetnode\u2019s ID. Despite some advantages (e.g., robust
refactorings) of this approach, we observe problems with the tradeoff that the reference target
has to exist at the time the reference is created.  A more robust and intuitive handling of
references is desirable.  While some problems can be solved by language developers (e.g.,
quick fixes to create reference targets), there should be a better way to support references
by the IDE itself.`),eo=h(),me=i("p"),to=r(`The approach to references in ProjectIt is to used only name-based references which are resolve
on a need-to basis.`),oo=h(),ue=i("p"),ro=r("[Markus Voelter a.o., Efficiency of Projectional Editing]"),no=h(),io=i("hr"),De=h(),O=i("p"),lo=r(`This is the reason that in ProjectIt we allow only name-based references. Every reference is
an instance of the class `),ve=i("code"),so=r("PiElementReference"),ao=r(", which holds:"),Fe=h(),w=i("ul"),be=i("li"),fo=r("the name or path (i.e. a list of names) of the referred element"),ho=h(),ge=i("li"),po=r("the meta-type of the referred element"),co=h(),ye=i("li"),mo=r("a cache of the element itself"),He=h(),W=i("p"),uo=r("This means that the AST is truly a tree, not a graph."),Ke=h(),j=i("p"),vo=r(`The advantage is that we are not obliged to have the complete model in memory. Our use of
multi-file models is explained in `),B=i("a"),bo=r("Models and Model Units"),go=r("."),this.h()},l(e){_=l(e,"H1",{});var a=s(_);Je=n(a,"Our Philosophy"),a.forEach(o),we=p(e),N=l(e,"P",{});var _o=s(N);Xe=n(_o,`The design philosophy that we follow in ProjectIt can best be described by the following quote from
the well-known graphical user interface designer Alan Kay.`),_o.forEach(o),_e=p(e),L=l(e,"BLOCKQUOTE",{});var Po=s(L);P=l(Po,"P",{});var Ee=s(P);Z=l(Ee,"EM",{});var ko=s(Z);Ye=n(ko,"Simple things should be simple, complex things should be possible."),ko.forEach(o),Ze=n(Ee,`
(`),S=l(Ee,"A",{href:!0,target:!0});var xo=s(S);$e=n(xo,"Alan Kay, Turing Award Winner"),xo.forEach(o),et=n(Ee,")"),Ee.forEach(o),Po.forEach(o),Pe=p(e),D=l(e,"H2",{});var Io=s(D);tt=n(Io,"The Pareto Principle"),Io.forEach(o),ke=p(e),k=l(e,"P",{});var Ue=s(k);ot=n(Ue,`ProjectIt is a minimal viable product which supports the
language engineer in creating a work environment for a mini-language. A key principle
is the `),R=l(Ue,"A",{href:!0,target:!0});var To=s(R);rt=n(To,"Pareto principle"),To.forEach(o),nt=n(Ue,`
(or 80%-20% rule),
which states that for many events, roughly 80% of the effects come from 20% of the causes.
For example, it is an axiom of business  management that \u201C80% of sales come from 20% of clients\u201D.`),Ue.forEach(o),xe=p(e),x=l(e,"P",{});var Ce=s(x);it=n(Ce,"In software development the Pareto principle translates to \u201C"),$=l(Ce,"EM",{});var Oo=s($);lt=n(Oo,`80% of the development
effort is spend on 20% of the application`),Oo.forEach(o),st=n(Ce,`\u201D, this 20% being the more complex parts.
Still, the other 80% of the application needs to be created as well.`),Ce.forEach(o),Ie=p(e),v=l(e,"P",{});var Q=s(v);at=n(Q,`ProjectIt aims to
make the latter `),ee=l(Q,"STRONG",{});var jo=s(ee);ft=n(jo,"as simple as possible"),jo.forEach(o),ht=n(Q,", while keeping the generated code "),te=l(Q,"STRONG",{});var Ao=s(te);pt=n(Ao,"open"),Ao.forEach(o),ct=n(Q,` for the
language engineer to code the more complex parts by hand. One of our use cases is the
creation of a prototype language in a day or in a couple of days at most.`),Q.forEach(o),Te=p(e),F=l(e,"H2",{});var So=s(F);dt=n(So,"Other Guidelines"),So.forEach(o),Oe=p(e),c=l(e,"P",{});var u=s(c);mt=n(u,"Other guidelines have been "),oe=l(u,"STRONG",{});var Ro=s(oe);ut=n(Ro,"ease of use"),Ro.forEach(o),vt=n(u,", and "),re=l(u,"STRONG",{});var Mo=s(re);bt=n(Mo,"flexibility"),Mo.forEach(o),gt=n(u,". ProjectIt may not (yet "),I=l(u,"IMG",{src:!0,alt:!0,width:!0,height:!0}),yt=n(u,`) do
everything you need, but what it does, should be very easy to get into. Furthermore,
ProjectIt is designed to be `),ne=l(u,"STRONG",{});var Go=s(ne);Et=n(Go,"extendable"),Go.forEach(o),wt=n(u,", and "),ie=l(u,"STRONG",{});var qo=s(ie);_t=n(qo,"easy to integrate with other tooling"),qo.forEach(o),Pt=n(u,`.
In practise this means that:`),u.forEach(o),je=p(e),b=l(e,"UL",{});var V=s(b);M=l(V,"LI",{});var We=s(M);kt=n(We,"Every part of the work environment that is generated, can be "),le=l(We,"EM",{});var No=s(le);xt=n(No,"exchanged"),No.forEach(o),It=n(We,` for one
that suits the language engineer better, provided the right interface is implemented.`),We.forEach(o),Tt=p(V),G=l(V,"LI",{});var Be=s(G);Ot=n(Be,`Every part of the work environment is made by its own generator, so you can adjust which
parts you want to generate and which parts you `),se=l(Be,"EM",{});var Lo=s(se);jt=n(Lo,"omit"),Lo.forEach(o),At=n(Be,"."),Be.forEach(o),St=p(V),q=l(V,"LI",{});var Qe=s(q);Rt=n(Qe,`The different parts of the work environment can be run on either the server or the client.
Thus creating `),ae=l(Qe,"EM",{});var Do=s(ae);Mt=n(Do,"multiple deployment options"),Do.forEach(o),Gt=n(Qe,"."),Qe.forEach(o),V.forEach(o),Ae=p(e),g=l(e,"P",{});var z=s(g);qt=n(z,`With these principles in mind, we have started of small and simple. Every definition language,
from the language structure to the validation rules, is kept `),fe=l(z,"STRONG",{});var Fo=s(fe);Nt=n(Fo,"minimal"),Fo.forEach(o),Lt=n(z,". Over time, in an "),he=l(z,"STRONG",{});var Ho=s(he);Dt=n(Ho,"agile"),Ho.forEach(o),Ft=n(z,`
fashion, these will be extended whenever the need arises.`),z.forEach(o),Se=p(e),y=l(e,"P",{});var J=s(y);Ht=n(J,"Furthermore, we intend to use "),pe=l(J,"STRONG",{});var Ko=s(pe);Kt=n(Ko,"bootstrapping"),Ko.forEach(o),Ut=n(J,` in one of the next versions of ProjectIt
to create editors for every one of the definition languages. If you are interested, you can
check out our `),H=l(J,"A",{href:!0});var Uo=s(H);Ct=n(Uo,"wish list"),Uo.forEach(o),Wt=n(J," of features to be developed in the future."),J.forEach(o),Re=p(e),K=l(e,"H2",{});var Co=s(K);Bt=n(Co,"Name-Based References"),Co.forEach(o),Me=p(e),E=l(e,"P",{});var X=s(E);Qt=n(X,"In "),U=l(X,"A",{href:!0});var Wo=s(U);Vt=n(Wo,"Support for Expressions"),Wo.forEach(o),zt=n(X,` we explain
that editing expressions is a known challenge for projectional editors. A second challenge
is posed by `),ce=l(X,"EM",{});var Bo=s(ce);Jt=n(Bo,"references"),Bo.forEach(o),Xt=n(X,", which is stated in"),X.forEach(o),Ge=p(e),T=l(e,"A",{href:!0,target:!0});var Qo=s(T);Yt=n(Qo,"Efficiency of Projectional Editing: A Controlled Experiment"),Qo.forEach(o),qe=n(e,` as follows.
`),Ne=l(e,"HR",{}),Le=p(e),m=l(e,"BLOCKQUOTE",{});var A=s(m);C=l(A,"P",{});var yo=s(C);de=l(yo,"STRONG",{});var Vo=s(de);Zt=n(Vo,"References."),Vo.forEach(o),$t=n(yo,`
References are based on pointers to the targetnode\u2019s ID. Despite some advantages (e.g., robust
refactorings) of this approach, we observe problems with the tradeoff that the reference target
has to exist at the time the reference is created.  A more robust and intuitive handling of
references is desirable.  While some problems can be solved by language developers (e.g.,
quick fixes to create reference targets), there should be a better way to support references
by the IDE itself.`),yo.forEach(o),eo=p(A),me=l(A,"P",{});var zo=s(me);to=n(zo,`The approach to references in ProjectIt is to used only name-based references which are resolve
on a need-to basis.`),zo.forEach(o),oo=p(A),ue=l(A,"P",{});var Jo=s(ue);ro=n(Jo,"[Markus Voelter a.o., Efficiency of Projectional Editing]"),Jo.forEach(o),no=p(A),io=l(A,"HR",{}),A.forEach(o),De=p(e),O=l(e,"P",{});var Ve=s(O);lo=n(Ve,`This is the reason that in ProjectIt we allow only name-based references. Every reference is
an instance of the class `),ve=l(Ve,"CODE",{});var Xo=s(ve);so=n(Xo,"PiElementReference"),Xo.forEach(o),ao=n(Ve,", which holds:"),Ve.forEach(o),Fe=p(e),w=l(e,"UL",{});var Y=s(w);be=l(Y,"LI",{});var Yo=s(be);fo=n(Yo,"the name or path (i.e. a list of names) of the referred element"),Yo.forEach(o),ho=p(Y),ge=l(Y,"LI",{});var Zo=s(ge);po=n(Zo,"the meta-type of the referred element"),Zo.forEach(o),co=p(Y),ye=l(Y,"LI",{});var $o=s(ye);mo=n($o,"a cache of the element itself"),$o.forEach(o),Y.forEach(o),He=p(e),W=l(e,"P",{});var er=s(W);uo=n(er,"This means that the AST is truly a tree, not a graph."),er.forEach(o),Ke=p(e),j=l(e,"P",{});var ze=s(j);vo=n(ze,`The advantage is that we are not obliged to have the complete model in memory. Our use of
multi-file models is explained in `),B=l(ze,"A",{href:!0});var tr=s(B);bo=n(tr,"Models and Model Units"),tr.forEach(o),go=n(ze,"."),ze.forEach(o),this.h()},h(){d(S,"href","https://en.wikipedia.org/wiki/Alan_Kay"),d(S,"target","_blank"),d(R,"href","https://en.wikipedia.org/wiki/Pareto*principle"),d(R,"target","_blank"),lr(I.src,wo="/images/smile.png")||d(I,"src",wo),d(I,"alt","OOPS"),d(I,"width","20"),d(I,"height","20"),d(H,"href","/010_Intro/090_Future_Developments"),d(U,"href","/010_Intro/010_Projectional_Editing#expressions"),d(T,"href","https://www.voelter.de/data/pub/fse2016-projEditing.pdf"),d(T,"target","_blank"),d(B,"href","/010_Intro/030_Models_and_Model_Units")},m(e,a){f(e,_,a),t(_,Je),f(e,we,a),f(e,N,a),t(N,Xe),f(e,_e,a),f(e,L,a),t(L,P),t(P,Z),t(Z,Ye),t(P,Ze),t(P,S),t(S,$e),t(P,et),f(e,Pe,a),f(e,D,a),t(D,tt),f(e,ke,a),f(e,k,a),t(k,ot),t(k,R),t(R,rt),t(k,nt),f(e,xe,a),f(e,x,a),t(x,it),t(x,$),t($,lt),t(x,st),f(e,Ie,a),f(e,v,a),t(v,at),t(v,ee),t(ee,ft),t(v,ht),t(v,te),t(te,pt),t(v,ct),f(e,Te,a),f(e,F,a),t(F,dt),f(e,Oe,a),f(e,c,a),t(c,mt),t(c,oe),t(oe,ut),t(c,vt),t(c,re),t(re,bt),t(c,gt),t(c,I),t(c,yt),t(c,ne),t(ne,Et),t(c,wt),t(c,ie),t(ie,_t),t(c,Pt),f(e,je,a),f(e,b,a),t(b,M),t(M,kt),t(M,le),t(le,xt),t(M,It),t(b,Tt),t(b,G),t(G,Ot),t(G,se),t(se,jt),t(G,At),t(b,St),t(b,q),t(q,Rt),t(q,ae),t(ae,Mt),t(q,Gt),f(e,Ae,a),f(e,g,a),t(g,qt),t(g,fe),t(fe,Nt),t(g,Lt),t(g,he),t(he,Dt),t(g,Ft),f(e,Se,a),f(e,y,a),t(y,Ht),t(y,pe),t(pe,Kt),t(y,Ut),t(y,H),t(H,Ct),t(y,Wt),f(e,Re,a),f(e,K,a),t(K,Bt),f(e,Me,a),f(e,E,a),t(E,Qt),t(E,U),t(U,Vt),t(E,zt),t(E,ce),t(ce,Jt),t(E,Xt),f(e,Ge,a),f(e,T,a),t(T,Yt),f(e,qe,a),f(e,Ne,a),f(e,Le,a),f(e,m,a),t(m,C),t(C,de),t(de,Zt),t(C,$t),t(m,eo),t(m,me),t(me,to),t(m,oo),t(m,ue),t(ue,ro),t(m,no),t(m,io),f(e,De,a),f(e,O,a),t(O,lo),t(O,ve),t(ve,so),t(O,ao),f(e,Fe,a),f(e,w,a),t(w,be),t(be,fo),t(w,ho),t(w,ge),t(ge,po),t(w,co),t(w,ye),t(ye,mo),f(e,He,a),f(e,W,a),t(W,uo),f(e,Ke,a),f(e,j,a),t(j,vo),t(j,B),t(B,bo),t(j,go)},p:Eo,i:Eo,o:Eo,d(e){e&&o(_),e&&o(we),e&&o(N),e&&o(_e),e&&o(L),e&&o(Pe),e&&o(D),e&&o(ke),e&&o(k),e&&o(xe),e&&o(x),e&&o(Ie),e&&o(v),e&&o(Te),e&&o(F),e&&o(Oe),e&&o(c),e&&o(je),e&&o(b),e&&o(Ae),e&&o(g),e&&o(Se),e&&o(y),e&&o(Re),e&&o(K),e&&o(Me),e&&o(E),e&&o(Ge),e&&o(T),e&&o(qe),e&&o(Ne),e&&o(Le),e&&o(m),e&&o(De),e&&o(O),e&&o(Fe),e&&o(w),e&&o(He),e&&o(W),e&&o(Ke),e&&o(j)}}}class fr extends rr{constructor(_){super();nr(this,_,null,sr,ir,{})}}export{fr as default};
