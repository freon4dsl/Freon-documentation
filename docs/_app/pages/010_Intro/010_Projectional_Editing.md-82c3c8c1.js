import{S as Ki,i as Qi,s as Xi,e as l,t as o,k as h,j as hi,c as s,a as n,g as r,d as i,n as f,m as fi,b as z,f as p,F as t,o as ci,H as Zi,x as di,u as ui,v as mi}from"../../chunks/vendor-0216fdcb.js";import{F as Ei}from"../../chunks/Figure-9d44dae8.js";/* empty css                                                        */function eo(Ji){let _,qe,be,F,ze,_e,w,Je,S,Ke,Qe,we,D,Xe,Te,O,Ze,xe,k,ye,c,J,et,tt,K,it,ot,Q,rt,lt,X,st,at,Z,nt,je,g,ee,pt,Ae,H,ht,Se,T,ft,P,ct,dt,ke,ge,Pe,W,ut,Ie,M,mt,$e,Le,Ce,N,Et,Fe,I,te,vt,De,$,Oe,d,bt,ie,_t,wt,oe,Tt,xt,re,yt,jt,He,u,B,At,le,U,se,St,kt,gt,ae,Pt,It,G,$t,L,R,Lt,ne,Ct,Ft,E,Dt,pe,Ot,Ht,he,Wt,Mt,fe,Nt,Bt,Ut,ce,Gt,We,V,Rt,Me,Y,Vt,Ne,m,Yt,de,qt,zt,ue,Jt,Kt,me,Qt,Xt,Be,v,Zt,Ee,ei,ti,ve,ii,oi,Ue,C,Ge;return k=new Ei({props:{imageName:"projection-overview.png",caption:"General flow of projectional editing",figureNumber:1}}),$=new Ei({props:{imageName:"expressions-problem.png",caption:"Editing expressions",figureNumber:2}}),C=new Ei({props:{imageName:"projection-overview.png",caption:"General flow of projectional editing",figureNumber:3}}),{c(){_=l("h1"),qe=o("What is Projectional Editing?"),be=h(),F=l("p"),ze=o(`The essential characteristic of projectional editing is that the user manipulates
the Abstract Syntax Tree (AST) directly. In contrast, the traditional manner of editing is that
a user manipulates a text-string, which is then (re)parsed into a (changed) AST.`),_e=h(),w=l("p"),Je=o(`For a generic view on projectional editing
see `),S=l("a"),Ke=o("this page"),Qe=o(" on Wikipedia."),we=h(),D=l("h2"),Xe=o("Projectional workflow"),Te=h(),O=l("p"),Ze=o("The overall flow in a projectional editor generated by ProjectIt is shown in this figure."),xe=h(),hi(k.$$.fragment),ye=h(),c=l("ol"),J=l("li"),et=o("The model/AST is mapped to a visual presentation (the projection)."),tt=h(),K=l("li"),it=o("The projection is shown to the user."),ot=h(),Q=l("li"),rt=o("The user performs an action on the projection."),lt=h(),X=l("li"),st=o("The action on the projection is mapped to an action on the model/AST."),at=h(),Z=l("li"),nt=o("(or 1 again) The changed model/AST is (re)mapped to a visual representation."),je=h(),g=l("h2"),ee=l("a"),pt=o(" Support For Expressions"),Ae=h(),H=l("p"),ht=o(`Editing expressions in a projectional editor is a well-known challenge. The representation of an expression
in the AST is highly structured. Yet, because its appearance to the user looks textual, users expect that
the editing behavior resembles classical text editing as much as possible.`),Se=h(),T=l("p"),ft=o("In "),P=l("a"),ct=o(`Efficiency
of Projectional Editing: A Controlled Experiment`),dt=o(" the authors express the problem as follows."),ke=h(),ge=l("hr"),Pe=h(),W=l("p"),ut=o(`Editing expressions with their fine-grained tree structure is one of the major challenges in a
projectional editor. The inability to insert and remove parentheses in arbitrary places (and
then refactor the treestructure according to the precedence expressed by the parentheses) is an
example.`),Ie=h(),M=l("p"),mt=o("[Markus Voelter a.o., Efficiency of Projectional Editing]"),$e=h(),Le=l("hr"),Ce=h(),N=l("p"),Et=o(`For this reason, ProjectIt has in-build support for expressions. There is extra functionality to
be able to add an expression before or after an existing expression. Secondly, the AST of any binary
expression is automatically balanced.`),Fe=h(),I=l("h2"),te=l("a"),vt=o("Adding to an Existing Expression"),De=h(),hi($.$$.fragment),Oe=h(),d=l("p"),bt=o("In the above figure, when the user types a "),ie=l("code"),_t=o("+"),wt=o(" symbol after the "),oe=l("code"),Tt=o("**"),xt=o(`, it is not enough
to simply add the `),re=l("code"),yt=o("+"),jt=o(" in the AST."),He=h(),u=l("ul"),B=l("li"),At=o(`First of all,  a placeholder should be added to make the xpression strcuturally correct,
so we should see something like`),le=l("ul"),U=l("li"),se=l("code"),St=o("a * ... + b"),kt=o("."),gt=h(),ae=l("li"),Pt=o("Doing so will lead to the second AST shown."),It=h(),G=l("li"),$t=o("But \u2026 this AST is not balanced right!"),L=l("ul"),R=l("li"),Lt=o("When adding parenthesis to show the AST, this will look like "),ne=l("code"),Ct=o("a * (... + b)"),Ft=h(),E=l("li"),Dt=o("But the user (using his knowledge of priorities of "),pe=l("code"),Ot=o("**"),Ht=o(" and "),he=l("code"),Wt=o("+"),Mt=o(" will read "),fe=l("code"),Nt=o("(a * ...) + b"),Bt=o("."),Ut=h(),ce=l("li"),Gt=o(`Therefore, the AST needs to be re-balanced to take the priorities of the multiplication and addition into account.
This re-balancing leads to the trhird AST show, where the structure of the AST
properly reflects what the user understands.`),We=h(),V=l("p"),Rt=o("ProjectIt understands this kind of tree balancing and will automatically apply them while editing expressions."),Me=h(),Y=l("h2"),Vt=o("Persistence"),Ne=h(),m=l("p"),Yt=o("Typical user actions are to "),de=l("em"),qt=o("create"),zt=o(" a new element in the AST, to "),ue=l("em"),Jt=o("change"),Kt=o(` the content of an element,
or to `),me=l("em"),Qt=o("delete"),Xt=o(" an element."),Be=h(),v=l("p"),Zt=o(`Certainly, these changes may need to be persisted. When the user triggers
the menu actions `),Ee=l("em"),ei=o("save unit"),ti=o(" or "),ve=l("em"),ii=o("open unit"),oi=o(" the AST is pushed to or retrieved from a server."),Ue=h(),hi(C.$$.fragment),this.h()},l(e){_=s(e,"H1",{});var a=n(_);qe=r(a,"What is Projectional Editing?"),a.forEach(i),be=f(e),F=s(e,"P",{});var vi=n(F);ze=r(vi,`The essential characteristic of projectional editing is that the user manipulates
the Abstract Syntax Tree (AST) directly. In contrast, the traditional manner of editing is that
a user manipulates a text-string, which is then (re)parsed into a (changed) AST.`),vi.forEach(i),_e=f(e),w=s(e,"P",{});var Re=n(w);Je=r(Re,`For a generic view on projectional editing
see `),S=s(Re,"A",{href:!0,target:!0});var bi=n(S);Ke=r(bi,"this page"),bi.forEach(i),Qe=r(Re," on Wikipedia."),Re.forEach(i),we=f(e),D=s(e,"H2",{});var _i=n(D);Xe=r(_i,"Projectional workflow"),_i.forEach(i),Te=f(e),O=s(e,"P",{});var wi=n(O);Ze=r(wi,"The overall flow in a projectional editor generated by ProjectIt is shown in this figure."),wi.forEach(i),xe=f(e),fi(k.$$.fragment,e),ye=f(e),c=s(e,"OL",{});var b=n(c);J=s(b,"LI",{});var Ti=n(J);et=r(Ti,"The model/AST is mapped to a visual presentation (the projection)."),Ti.forEach(i),tt=f(b),K=s(b,"LI",{});var xi=n(K);it=r(xi,"The projection is shown to the user."),xi.forEach(i),ot=f(b),Q=s(b,"LI",{});var yi=n(Q);rt=r(yi,"The user performs an action on the projection."),yi.forEach(i),lt=f(b),X=s(b,"LI",{});var ji=n(X);st=r(ji,"The action on the projection is mapped to an action on the model/AST."),ji.forEach(i),at=f(b),Z=s(b,"LI",{});var Ai=n(Z);nt=r(Ai,"(or 1 again) The changed model/AST is (re)mapped to a visual representation."),Ai.forEach(i),b.forEach(i),je=f(e),g=s(e,"H2",{});var ri=n(g);ee=s(ri,"A",{name:!0}),n(ee).forEach(i),pt=r(ri," Support For Expressions"),ri.forEach(i),Ae=f(e),H=s(e,"P",{});var Si=n(H);ht=r(Si,`Editing expressions in a projectional editor is a well-known challenge. The representation of an expression
in the AST is highly structured. Yet, because its appearance to the user looks textual, users expect that
the editing behavior resembles classical text editing as much as possible.`),Si.forEach(i),Se=f(e),T=s(e,"P",{});var Ve=n(T);ft=r(Ve,"In "),P=s(Ve,"A",{href:!0,target:!0});var ki=n(P);ct=r(ki,`Efficiency
of Projectional Editing: A Controlled Experiment`),ki.forEach(i),dt=r(Ve," the authors express the problem as follows."),Ve.forEach(i),ke=f(e),ge=s(e,"HR",{}),Pe=f(e),W=s(e,"P",{});var gi=n(W);ut=r(gi,`Editing expressions with their fine-grained tree structure is one of the major challenges in a
projectional editor. The inability to insert and remove parentheses in arbitrary places (and
then refactor the treestructure according to the precedence expressed by the parentheses) is an
example.`),gi.forEach(i),Ie=f(e),M=s(e,"P",{});var Pi=n(M);mt=r(Pi,"[Markus Voelter a.o., Efficiency of Projectional Editing]"),Pi.forEach(i),$e=f(e),Le=s(e,"HR",{}),Ce=f(e),N=s(e,"P",{});var Ii=n(N);Et=r(Ii,`For this reason, ProjectIt has in-build support for expressions. There is extra functionality to
be able to add an expression before or after an existing expression. Secondly, the AST of any binary
expression is automatically balanced.`),Ii.forEach(i),Fe=f(e),I=s(e,"H2",{});var li=n(I);te=s(li,"A",{name:!0}),n(te).forEach(i),vt=r(li,"Adding to an Existing Expression"),li.forEach(i),De=f(e),fi($.$$.fragment,e),Oe=f(e),d=s(e,"P",{});var x=n(d);bt=r(x,"In the above figure, when the user types a "),ie=s(x,"CODE",{});var $i=n(ie);_t=r($i,"+"),$i.forEach(i),wt=r(x," symbol after the "),oe=s(x,"CODE",{});var Li=n(oe);Tt=r(Li,"**"),Li.forEach(i),xt=r(x,`, it is not enough
to simply add the `),re=s(x,"CODE",{});var Ci=n(re);yt=r(Ci,"+"),Ci.forEach(i),jt=r(x," in the AST."),x.forEach(i),He=f(e),u=s(e,"UL",{});var y=n(u);B=s(y,"LI",{});var si=n(B);At=r(si,`First of all,  a placeholder should be added to make the xpression strcuturally correct,
so we should see something like`),le=s(si,"UL",{});var Fi=n(le);U=s(Fi,"LI",{});var ai=n(U);se=s(ai,"CODE",{});var Di=n(se);St=r(Di,"a * ... + b"),Di.forEach(i),kt=r(ai,"."),ai.forEach(i),Fi.forEach(i),si.forEach(i),gt=f(y),ae=s(y,"LI",{});var Oi=n(ae);Pt=r(Oi,"Doing so will lead to the second AST shown."),Oi.forEach(i),It=f(y),G=s(y,"LI",{});var ni=n(G);$t=r(ni,"But \u2026 this AST is not balanced right!"),L=s(ni,"UL",{});var Ye=n(L);R=s(Ye,"LI",{});var pi=n(R);Lt=r(pi,"When adding parenthesis to show the AST, this will look like "),ne=s(pi,"CODE",{});var Hi=n(ne);Ct=r(Hi,"a * (... + b)"),Hi.forEach(i),pi.forEach(i),Ft=f(Ye),E=s(Ye,"LI",{});var j=n(E);Dt=r(j,"But the user (using his knowledge of priorities of "),pe=s(j,"CODE",{});var Wi=n(pe);Ot=r(Wi,"**"),Wi.forEach(i),Ht=r(j," and "),he=s(j,"CODE",{});var Mi=n(he);Wt=r(Mi,"+"),Mi.forEach(i),Mt=r(j," will read "),fe=s(j,"CODE",{});var Ni=n(fe);Nt=r(Ni,"(a * ...) + b"),Ni.forEach(i),Bt=r(j,"."),j.forEach(i),Ye.forEach(i),ni.forEach(i),Ut=f(y),ce=s(y,"LI",{});var Bi=n(ce);Gt=r(Bi,`Therefore, the AST needs to be re-balanced to take the priorities of the multiplication and addition into account.
This re-balancing leads to the trhird AST show, where the structure of the AST
properly reflects what the user understands.`),Bi.forEach(i),y.forEach(i),We=f(e),V=s(e,"P",{});var Ui=n(V);Rt=r(Ui,"ProjectIt understands this kind of tree balancing and will automatically apply them while editing expressions."),Ui.forEach(i),Me=f(e),Y=s(e,"H2",{});var Gi=n(Y);Vt=r(Gi,"Persistence"),Gi.forEach(i),Ne=f(e),m=s(e,"P",{});var A=n(m);Yt=r(A,"Typical user actions are to "),de=s(A,"EM",{});var Ri=n(de);qt=r(Ri,"create"),Ri.forEach(i),zt=r(A," a new element in the AST, to "),ue=s(A,"EM",{});var Vi=n(ue);Jt=r(Vi,"change"),Vi.forEach(i),Kt=r(A,` the content of an element,
or to `),me=s(A,"EM",{});var Yi=n(me);Qt=r(Yi,"delete"),Yi.forEach(i),Xt=r(A," an element."),A.forEach(i),Be=f(e),v=s(e,"P",{});var q=n(v);Zt=r(q,`Certainly, these changes may need to be persisted. When the user triggers
the menu actions `),Ee=s(q,"EM",{});var qi=n(Ee);ei=r(qi,"save unit"),qi.forEach(i),ti=r(q," or "),ve=s(q,"EM",{});var zi=n(ve);ii=r(zi,"open unit"),zi.forEach(i),oi=r(q," the AST is pushed to or retrieved from a server."),q.forEach(i),Ue=f(e),fi(C.$$.fragment,e),this.h()},h(){z(S,"href","https://en.wikipedia.org/wiki/Structure*editor"),z(S,"target","_blank"),z(ee,"name","expressions"),z(P,"href","https://www.voelter.de/data/pub/fse2016-projEditing.pdf"),z(P,"target","_blank"),z(te,"name","tree-balancing")},m(e,a){p(e,_,a),t(_,qe),p(e,be,a),p(e,F,a),t(F,ze),p(e,_e,a),p(e,w,a),t(w,Je),t(w,S),t(S,Ke),t(w,Qe),p(e,we,a),p(e,D,a),t(D,Xe),p(e,Te,a),p(e,O,a),t(O,Ze),p(e,xe,a),ci(k,e,a),p(e,ye,a),p(e,c,a),t(c,J),t(J,et),t(c,tt),t(c,K),t(K,it),t(c,ot),t(c,Q),t(Q,rt),t(c,lt),t(c,X),t(X,st),t(c,at),t(c,Z),t(Z,nt),p(e,je,a),p(e,g,a),t(g,ee),t(g,pt),p(e,Ae,a),p(e,H,a),t(H,ht),p(e,Se,a),p(e,T,a),t(T,ft),t(T,P),t(P,ct),t(T,dt),p(e,ke,a),p(e,ge,a),p(e,Pe,a),p(e,W,a),t(W,ut),p(e,Ie,a),p(e,M,a),t(M,mt),p(e,$e,a),p(e,Le,a),p(e,Ce,a),p(e,N,a),t(N,Et),p(e,Fe,a),p(e,I,a),t(I,te),t(I,vt),p(e,De,a),ci($,e,a),p(e,Oe,a),p(e,d,a),t(d,bt),t(d,ie),t(ie,_t),t(d,wt),t(d,oe),t(oe,Tt),t(d,xt),t(d,re),t(re,yt),t(d,jt),p(e,He,a),p(e,u,a),t(u,B),t(B,At),t(B,le),t(le,U),t(U,se),t(se,St),t(U,kt),t(u,gt),t(u,ae),t(ae,Pt),t(u,It),t(u,G),t(G,$t),t(G,L),t(L,R),t(R,Lt),t(R,ne),t(ne,Ct),t(L,Ft),t(L,E),t(E,Dt),t(E,pe),t(pe,Ot),t(E,Ht),t(E,he),t(he,Wt),t(E,Mt),t(E,fe),t(fe,Nt),t(E,Bt),t(u,Ut),t(u,ce),t(ce,Gt),p(e,We,a),p(e,V,a),t(V,Rt),p(e,Me,a),p(e,Y,a),t(Y,Vt),p(e,Ne,a),p(e,m,a),t(m,Yt),t(m,de),t(de,qt),t(m,zt),t(m,ue),t(ue,Jt),t(m,Kt),t(m,me),t(me,Qt),t(m,Xt),p(e,Be,a),p(e,v,a),t(v,Zt),t(v,Ee),t(Ee,ei),t(v,ti),t(v,ve),t(ve,ii),t(v,oi),p(e,Ue,a),ci(C,e,a),Ge=!0},p:Zi,i(e){Ge||(di(k.$$.fragment,e),di($.$$.fragment,e),di(C.$$.fragment,e),Ge=!0)},o(e){ui(k.$$.fragment,e),ui($.$$.fragment,e),ui(C.$$.fragment,e),Ge=!1},d(e){e&&i(_),e&&i(be),e&&i(F),e&&i(_e),e&&i(w),e&&i(we),e&&i(D),e&&i(Te),e&&i(O),e&&i(xe),mi(k,e),e&&i(ye),e&&i(c),e&&i(je),e&&i(g),e&&i(Ae),e&&i(H),e&&i(Se),e&&i(T),e&&i(ke),e&&i(ge),e&&i(Pe),e&&i(W),e&&i(Ie),e&&i(M),e&&i($e),e&&i(Le),e&&i(Ce),e&&i(N),e&&i(Fe),e&&i(I),e&&i(De),mi($,e),e&&i(Oe),e&&i(d),e&&i(He),e&&i(u),e&&i(We),e&&i(V),e&&i(Me),e&&i(Y),e&&i(Ne),e&&i(m),e&&i(Be),e&&i(v),e&&i(Ue),mi(C,e)}}}class ro extends Ki{constructor(_){super();Qi(this,_,null,eo,Xi,{})}}export{ro as default};
