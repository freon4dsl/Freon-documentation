import{S as zn,i as Bn,s as Mn,e as l,t as a,k as f,c,a as i,h as e,d as s,m as d,b as mn,g as p,H as t,J as wn}from"../../../chunks/vendor-492729b6.js";function Sn(xn){let y,G,O,u,J,g,F,K,_,Q,W,N,h,X,L,Z,$,z,E,nn,B,r,sn,j,tn,an,A,en,on,x,pn,ln,M,P,cn,S,w,Dn=`<code class="language-ts">  <span class="token comment">// add your custom type-providers here</span>
  customTypers<span class="token operator">:</span> PiTyperPart<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">CustomEntityTyperPart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code>`,Y,T,rn,R,b,un,U,k,kn,D,fn,dn,H,yn,hn,V,v,Hn=`<code class="language-ts"><span class="token comment">// tutorial-language/typer/CustomEntityTyperPart.ts#L32-L48</span>

<span class="token keyword">public</span> <span class="token function">conformList</span><span class="token punctuation">(</span>typelist1<span class="token operator">:</span> EntityEveryConcept<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> typelist2<span class="token operator">:</span> EntityEveryConcept<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>typelist1<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>typelist1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Variable</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>typelist1<span class="token punctuation">.</span>length <span class="token operator">!==</span> typelist2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> result<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> max_length <span class="token operator">=</span> typelist1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> typelist1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            result <span class="token operator">=</span> EntityEnvironment<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>typer<span class="token punctuation">.</span><span class="token function">conformsTo</span><span class="token punctuation">(</span>typelist1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> typelist2<span class="token punctuation">[</span>max_length <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/**
 * See interface
 */</span></code>`;return{c(){y=l("h1"),G=a("Third Level Customization of the Typer"),O=f(),u=l("p"),J=a("The typer can as of now be customized "),g=l("strong"),F=a("per concept"),K=a(`. Your new typer needs
to implement the `),_=l("a"),Q=a("PiTyperPart interface"),W=a("."),N=f(),h=l("p"),X=a("As a convenience, ProjectIt generates a file "),L=l("code"),Z=a("~/picode/typer/Custom<yourLanguageName>TyperPart.ts"),$=a(`,
which will not be overwritten upon regeneration. It already contains a class that implements this interface.`),z=f(),E=l("h2"),nn=a("Adjusting the Configuration"),B=f(),r=l("p"),sn=a(`Next you need to tell ProjectIt to use this new typer by adding an
instance of your class to the `),j=l("code"),tn=a("customTypers"),an=a(` array in
the file `),A=l("code"),en=a("ProjectitConfiguration.ts"),on=a(". You will find this file in "),x=l("code"),pn=a("~/picode/projectit"),ln=a(`.
It is generated once, and wil not be overwritten on regeneration.`),M=f(),P=l("p"),cn=a("Using the above convenience class, the configuration should look like this:"),S=f(),w=l("pre"),Y=f(),T=l("h2"),rn=a("Adding Typing Methods"),R=f(),b=l("p"),un=a(`In the new typer class add the code you want to add in one or more of the methods. Let the method return \u2018null\u2019
to let ProjectIt know that the typer from the ProjectIt Definition Level should be used instead.`),U=f(),k=l("p"),kn=a("The following code changes the "),D=l("code"),fn=a("conformsList"),dn=a(" method for lists of "),H=l("code"),yn=a("Variables"),hn=a(`. It checks the lists in
reverse order: A-B-C conforms to C-B-A.`),V=f(),v=l("pre"),this.h()},l(n){y=c(n,"H1",{});var o=i(y);G=e(o,"Third Level Customization of the Typer"),o.forEach(s),O=d(n),u=c(n,"P",{});var C=i(u);J=e(C,"The typer can as of now be customized "),g=c(C,"STRONG",{});var vn=i(g);F=e(vn,"per concept"),vn.forEach(s),K=e(C,`. Your new typer needs
to implement the `),_=c(C,"A",{href:!0});var _n=i(_);Q=e(_n,"PiTyperPart interface"),_n.forEach(s),W=e(C,"."),C.forEach(s),N=d(n),h=c(n,"P",{});var q=i(h);X=e(q,"As a convenience, ProjectIt generates a file "),L=c(q,"CODE",{});var En=i(L);Z=e(En,"~/picode/typer/Custom<yourLanguageName>TyperPart.ts"),En.forEach(s),$=e(q,`,
which will not be overwritten upon regeneration. It already contains a class that implements this interface.`),q.forEach(s),z=d(n),E=c(n,"H2",{});var Pn=i(E);nn=e(Pn,"Adjusting the Configuration"),Pn.forEach(s),B=d(n),r=c(n,"P",{});var m=i(r);sn=e(m,`Next you need to tell ProjectIt to use this new typer by adding an
instance of your class to the `),j=c(m,"CODE",{});var Tn=i(j);tn=e(Tn,"customTypers"),Tn.forEach(s),an=e(m,` array in
the file `),A=c(m,"CODE",{});var bn=i(A);en=e(bn,"ProjectitConfiguration.ts"),bn.forEach(s),on=e(m,". You will find this file in "),x=c(m,"CODE",{});var Cn=i(x);pn=e(Cn,"~/picode/projectit"),Cn.forEach(s),ln=e(m,`.
It is generated once, and wil not be overwritten on regeneration.`),m.forEach(s),M=d(n),P=c(n,"P",{});var In=i(P);cn=e(In,"Using the above convenience class, the configuration should look like this:"),In.forEach(s),S=d(n),w=c(n,"PRE",{class:!0});var On=i(w);On.forEach(s),Y=d(n),T=c(n,"H2",{});var gn=i(T);rn=e(gn,"Adding Typing Methods"),gn.forEach(s),R=d(n),b=c(n,"P",{});var Ln=i(b);un=e(Ln,`In the new typer class add the code you want to add in one or more of the methods. Let the method return \u2018null\u2019
to let ProjectIt know that the typer from the ProjectIt Definition Level should be used instead.`),Ln.forEach(s),U=d(n),k=c(n,"P",{});var I=i(k);kn=e(I,"The following code changes the "),D=c(I,"CODE",{});var jn=i(D);fn=e(jn,"conformsList"),jn.forEach(s),dn=e(I," method for lists of "),H=c(I,"CODE",{});var An=i(H);yn=e(An,"Variables"),An.forEach(s),hn=e(I,`. It checks the lists in
reverse order: A-B-C conforms to C-B-A.`),I.forEach(s),V=d(n),v=c(n,"PRE",{class:!0});var Nn=i(v);Nn.forEach(s),this.h()},h(){mn(_,"href","/060_Under_the_Hood/020_The_PiTool_Interfaces/050_PiTyper_Interface"),mn(w,"class","language-ts"),mn(v,"class","language-ts")},m(n,o){p(n,y,o),t(y,G),p(n,O,o),p(n,u,o),t(u,J),t(u,g),t(g,F),t(u,K),t(u,_),t(_,Q),t(u,W),p(n,N,o),p(n,h,o),t(h,X),t(h,L),t(L,Z),t(h,$),p(n,z,o),p(n,E,o),t(E,nn),p(n,B,o),p(n,r,o),t(r,sn),t(r,j),t(j,tn),t(r,an),t(r,A),t(A,en),t(r,on),t(r,x),t(x,pn),t(r,ln),p(n,M,o),p(n,P,o),t(P,cn),p(n,S,o),p(n,w,o),w.innerHTML=Dn,p(n,Y,o),p(n,T,o),t(T,rn),p(n,R,o),p(n,b,o),t(b,un),p(n,U,o),p(n,k,o),t(k,kn),t(k,D),t(D,fn),t(k,dn),t(k,H),t(H,yn),t(k,hn),p(n,V,o),p(n,v,o),v.innerHTML=Hn},p:wn,i:wn,o:wn,d(n){n&&s(y),n&&s(O),n&&s(u),n&&s(N),n&&s(h),n&&s(z),n&&s(E),n&&s(B),n&&s(r),n&&s(M),n&&s(P),n&&s(S),n&&s(w),n&&s(Y),n&&s(T),n&&s(R),n&&s(b),n&&s(U),n&&s(k),n&&s(V),n&&s(v)}}}class Rn extends zn{constructor(y){super();Bn(this,y,null,Sn,Mn,{})}}export{Rn as default};
