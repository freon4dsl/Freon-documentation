import{S as Nn,i as zn,s as Bn,e as l,t as a,k as f,c,a as i,h as e,d as s,m as d,b as mn,g as p,H as t,J as wn}from"../../../chunks/vendor-0dc77bd0.js";function Mn(Dn){let y,q,O,u,G,L,J,K,_,Q,W,j,h,X,A,Z,$,N,E,nn,z,r,sn,I,tn,an,x,en,on,D,pn,ln,B,T,cn,M,w,Fn=`<code class="language-ts">  <span class="token comment">// add your custom type-providers here</span>
  customTypers<span class="token operator">:</span> PiTyperPart<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">CustomEntityTyperPart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code>`,S,b,rn,Y,C,un,R,k,kn,F,fn,dn,H,yn,hn,U,v,Hn=`<code class="language-ts"><span class="token comment">// tutorial-language/typer/CustomEntityTyperPart.ts#L32-L48</span>

<span class="token keyword">public</span> <span class="token function">conformList</span><span class="token punctuation">(</span>typelist1<span class="token operator">:</span> EntityEveryConcept<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> typelist2<span class="token operator">:</span> EntityEveryConcept<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>typelist1<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>typelist1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Variable</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>typelist1<span class="token punctuation">.</span>length <span class="token operator">!==</span> typelist2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> result<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> max_length <span class="token operator">=</span> typelist1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> typelist1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            result <span class="token operator">=</span> EntityEnvironment<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>typer<span class="token punctuation">.</span><span class="token function">conformsTo</span><span class="token punctuation">(</span>typelist1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> typelist2<span class="token punctuation">[</span>max_length <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/**
 * See interface
 */</span></code>`;return{c(){y=l("h1"),q=a("Third Level Customization of the Typer"),O=f(),u=l("p"),G=a("The typer can as of now be customized "),L=l("strong"),J=a("per concept"),K=a(`. Your new typer needs
to implement the `),_=l("a"),Q=a("PiTyperPart interface"),W=a("."),j=f(),h=l("p"),X=a("As a convenience, Freon generates a file "),A=l("code"),Z=a("~/picode/typer/Custom<yourLanguageName>TyperPart.ts"),$=a(`,
which will not be overwritten upon regeneration. It already contains a class that implements this interface.`),N=f(),E=l("h2"),nn=a("Adjusting the Configuration"),z=f(),r=l("p"),sn=a(`Next you need to tell Freon to use this new typer by adding an
instance of your class to the `),I=l("code"),tn=a("customTypers"),an=a(` array in
the file `),x=l("code"),en=a("ProjectitConfiguration.ts"),on=a(". You will find this file in "),D=l("code"),pn=a("~/picode/projectit"),ln=a(`.
It is generated once, and wil not be overwritten on regeneration.`),B=f(),T=l("p"),cn=a("Using the above convenience class, the configuration should look like this:"),M=f(),w=l("pre"),S=f(),b=l("h2"),rn=a("Adding Typing Methods"),Y=f(),C=l("p"),un=a(`In the new typer class add the code you want to add in one or more of the methods. Let the method return \u2018null\u2019
to let Freon know that the typer from the Freon Definition Level should be used instead.`),R=f(),k=l("p"),kn=a("The following code changes the "),F=l("code"),fn=a("conformsList"),dn=a(" method for lists of "),H=l("code"),yn=a("Variables"),hn=a(`. It checks the lists in
reverse order: A-B-C conforms to C-B-A.`),U=f(),v=l("pre"),this.h()},l(n){y=c(n,"H1",{});var o=i(y);q=e(o,"Third Level Customization of the Typer"),o.forEach(s),O=d(n),u=c(n,"P",{});var P=i(u);G=e(P,"The typer can as of now be customized "),L=c(P,"STRONG",{});var vn=i(L);J=e(vn,"per concept"),vn.forEach(s),K=e(P,`. Your new typer needs
to implement the `),_=c(P,"A",{href:!0});var _n=i(_);Q=e(_n,"PiTyperPart interface"),_n.forEach(s),W=e(P,"."),P.forEach(s),j=d(n),h=c(n,"P",{});var V=i(h);X=e(V,"As a convenience, Freon generates a file "),A=c(V,"CODE",{});var En=i(A);Z=e(En,"~/picode/typer/Custom<yourLanguageName>TyperPart.ts"),En.forEach(s),$=e(V,`,
which will not be overwritten upon regeneration. It already contains a class that implements this interface.`),V.forEach(s),N=d(n),E=c(n,"H2",{});var Tn=i(E);nn=e(Tn,"Adjusting the Configuration"),Tn.forEach(s),z=d(n),r=c(n,"P",{});var m=i(r);sn=e(m,`Next you need to tell Freon to use this new typer by adding an
instance of your class to the `),I=c(m,"CODE",{});var bn=i(I);tn=e(bn,"customTypers"),bn.forEach(s),an=e(m,` array in
the file `),x=c(m,"CODE",{});var Cn=i(x);en=e(Cn,"ProjectitConfiguration.ts"),Cn.forEach(s),on=e(m,". You will find this file in "),D=c(m,"CODE",{});var Pn=i(D);pn=e(Pn,"~/picode/projectit"),Pn.forEach(s),ln=e(m,`.
It is generated once, and wil not be overwritten on regeneration.`),m.forEach(s),B=d(n),T=c(n,"P",{});var gn=i(T);cn=e(gn,"Using the above convenience class, the configuration should look like this:"),gn.forEach(s),M=d(n),w=c(n,"PRE",{class:!0});var On=i(w);On.forEach(s),S=d(n),b=c(n,"H2",{});var Ln=i(b);rn=e(Ln,"Adding Typing Methods"),Ln.forEach(s),Y=d(n),C=c(n,"P",{});var An=i(C);un=e(An,`In the new typer class add the code you want to add in one or more of the methods. Let the method return \u2018null\u2019
to let Freon know that the typer from the Freon Definition Level should be used instead.`),An.forEach(s),R=d(n),k=c(n,"P",{});var g=i(k);kn=e(g,"The following code changes the "),F=c(g,"CODE",{});var In=i(F);fn=e(In,"conformsList"),In.forEach(s),dn=e(g," method for lists of "),H=c(g,"CODE",{});var xn=i(H);yn=e(xn,"Variables"),xn.forEach(s),hn=e(g,`. It checks the lists in
reverse order: A-B-C conforms to C-B-A.`),g.forEach(s),U=d(n),v=c(n,"PRE",{class:!0});var jn=i(v);jn.forEach(s),this.h()},h(){mn(_,"href","/060_Under_the_Hood/020_The_PiTool_Interfaces/050_PiTyper_Interface"),mn(w,"class","language-ts"),mn(v,"class","language-ts")},m(n,o){p(n,y,o),t(y,q),p(n,O,o),p(n,u,o),t(u,G),t(u,L),t(L,J),t(u,K),t(u,_),t(_,Q),t(u,W),p(n,j,o),p(n,h,o),t(h,X),t(h,A),t(A,Z),t(h,$),p(n,N,o),p(n,E,o),t(E,nn),p(n,z,o),p(n,r,o),t(r,sn),t(r,I),t(I,tn),t(r,an),t(r,x),t(x,en),t(r,on),t(r,D),t(D,pn),t(r,ln),p(n,B,o),p(n,T,o),t(T,cn),p(n,M,o),p(n,w,o),w.innerHTML=Fn,p(n,S,o),p(n,b,o),t(b,rn),p(n,Y,o),p(n,C,o),t(C,un),p(n,R,o),p(n,k,o),t(k,kn),t(k,F),t(F,fn),t(k,dn),t(k,H),t(H,yn),t(k,hn),p(n,U,o),p(n,v,o),v.innerHTML=Hn},p:wn,i:wn,o:wn,d(n){n&&s(y),n&&s(O),n&&s(u),n&&s(j),n&&s(h),n&&s(N),n&&s(E),n&&s(z),n&&s(r),n&&s(B),n&&s(T),n&&s(M),n&&s(w),n&&s(S),n&&s(b),n&&s(Y),n&&s(C),n&&s(R),n&&s(k),n&&s(U),n&&s(v)}}}class Yn extends Nn{constructor(y){super();zn(this,y,null,Mn,Bn,{})}}export{Yn as default};
