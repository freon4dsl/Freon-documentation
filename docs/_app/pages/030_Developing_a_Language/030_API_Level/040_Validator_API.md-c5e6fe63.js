import{S as $t,i as en,s as tn,e as s,t as a,k as c,c as l,a as i,g as o,d as n,n as u,b as we,f as p,F as t,H as wt}from"../../../chunks/vendor-0216fdcb.js";function nn(Wt){let w,_e,se,L,be,le,O,ge,ie,D,Ce,re,d,Pe,q,Te,Ie,M,Le,Oe,R,De,je,pe,j,xe,ce,P,Gt=`<code class="language-ts"><span class="token comment">// add your custom validations here</span>
customValidations<span class="token operator">:</span> EntityCheckerInterface<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">CustomEntityValidator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code>`,ue,x,Ve,de,_,Ae,U,Ne,He,he,k,B,v,Ye,W,Fe,Se,G,ze,qe,Me,y,f,Re,J,Ue,Be,K,We,Ge,Q,Je,Ke,Qe,T,Xe,X,Ze,$e,et,V,Jt=`<code class="language-ts">    <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">EntityCheckerInterface</span> <span class="token keyword">extends</span> <span class="token class-name">EntityDefaultWorker</span> <span class="token punctuation">&#123;</span>
        errorList<span class="token operator">:</span> PiError<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token template-punctuation string">&#96;</span></span>&#96;
</code>`,tt,Z,E,nt,$,at,ot,A,st,lt,fe,N,it,ke,I,Kt=`<code class="language-ts"><span class="token comment">// tutorial-language/validator/CustomEntityValidator.ts#L9-L42</span>

    <span class="token keyword">public</span> <span class="token function">execBeforeEntityFunction</span><span class="token punctuation">(</span>modelelement<span class="token operator">:</span> EntityFunction<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>modelelement<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"determine"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>errorList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>
                <span class="token keyword">new</span> <span class="token class-name">PiError</span><span class="token punctuation">(</span>
                    <span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token string">"determine" is a terrible name for a Function</span><span class="token template-punctuation string">&#96;</span></span><span class="token punctuation">,</span>
                    modelelement<span class="token punctuation">,</span>
                    modelelement<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
                    PiErrorSeverity<span class="token punctuation">.</span>Error
                <span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</code>`,me,h,rt,ee,pt,ct,te,ut,dt,ne,ht,ft,ve,m,kt,ae,mt,vt,oe,yt,Et;return{c(){w=s("h1"),_e=a("Third Level Customization of the Validator"),se=c(),L=s("p"),be=a(`The validator can be adjusted on the API level by adding a single Typescript class. This class should implement
the worker part of the visitor pattern, adding checks per node of the AST that is visited.`),le=c(),O=s("p"),ge=a(`You can add the Typescript class anywhere, providing you let ProjectIt know where the file can be found through
the ProjectIt configuration.`),ie=c(),D=s("h2"),Ce=a("Adjusting the Configuration"),re=c(),d=s("p"),Pe=a(`You should let ProjectIt know where it can find your customized validation class by adding an
instance of your class to the `),q=s("code"),Te=a("customValidations"),Ie=a(` array in
the file `),M=s("code"),Le=a("ProjectitConfiguration.ts"),Oe=a(". You will find this file in "),R=s("code"),De=a("~/picode/projectit"),je=a(`.
It is generated once, and wil not be overwritten on regeneration.`),pe=c(),j=s("p"),xe=a("Using the above example class, the configuration should look like this:"),ce=c(),P=s("pre"),ue=c(),x=s("h2"),Ve=a("You own Validation Class"),de=c(),_=s("p"),Ae=a("As a convenience, ProjectIt generates a file "),U=s("code"),Ne=a("~/picode/validator/Custom<yourLanguageName>Validator.ts"),He=a(`,
which will not be overwritten upon regeneration. If you want to use it you can skip steps 1 and 2 in the next
list.`),he=c(),k=s("ol"),B=s("li"),v=s("p"),Ye=a("Create a Typescript file somewhere, for instance in "),W=s("code"),Fe=a("~/picode/validator"),Se=a(`. Note, again,
to not add it to the `),G=s("code"),ze=a("~/picode/validator/gen"),qe=a(" folder, as this will be deleted upon regeneration."),Me=c(),y=s("li"),f=s("p"),Re=a("Create a class in this file and let this class implement the generated "),J=s("code"),Ue=a("<yourLanguageName>CheckerInterface"),Be=a(`,
which you can find in the `),K=s("code"),We=a("~/picode/validator/gen"),Ge=a(` folder.
Obviously, `),Q=s("code"),Je=a("<yourLanguageName>"),Ke=a(" needs to be replaced by the name of your language."),Qe=c(),T=s("p"),Xe=a("This is the interface to be implemented for the example language called "),X=s("code"),Ze=a("Entity"),$e=a("."),et=c(),V=s("pre"),tt=c(),Z=s("li"),E=s("p"),nt=a(`Now implement any of the methods of the default worker by putting in your validation in
the corresponding model element method. This method will override the (empty) default implementation.
The validation error should be pushed onto the `),$=s("code"),at=a("errorList"),ot=a(` attribute. Therefore, each error must implement the
`),A=s("a"),st=a("PiError"),lt=a(" (TODO link) interface."),fe=c(),N=s("p"),it=a("The result of the above should look something like this:"),ke=c(),I=s("pre"),me=c(),h=s("p"),rt=a("In this example only nodes of type "),ee=s("code"),pt=a("EntityFunction"),ct=a(" are checked. If the name of the node equals "),te=s("code"),ut=a("determine"),dt=a(` than an error is
pushed on the `),ne=s("code"),ht=a("errorList"),ft=a("."),ve=c(),m=s("p"),kt=a(`If you want the walker to stop when an erroneous node is found you
should return `),ae=s("code"),mt=a("true"),vt=a(", else return "),oe=s("code"),yt=a("false"),Et=a("."),this.h()},l(e){w=l(e,"H1",{});var r=i(w);_e=o(r,"Third Level Customization of the Validator"),r.forEach(n),se=u(e),L=l(e,"P",{});var _t=i(L);be=o(_t,`The validator can be adjusted on the API level by adding a single Typescript class. This class should implement
the worker part of the visitor pattern, adding checks per node of the AST that is visited.`),_t.forEach(n),le=u(e),O=l(e,"P",{});var bt=i(O);ge=o(bt,`You can add the Typescript class anywhere, providing you let ProjectIt know where the file can be found through
the ProjectIt configuration.`),bt.forEach(n),ie=u(e),D=l(e,"H2",{});var gt=i(D);Ce=o(gt,"Adjusting the Configuration"),gt.forEach(n),re=u(e),d=l(e,"P",{});var b=i(d);Pe=o(b,`You should let ProjectIt know where it can find your customized validation class by adding an
instance of your class to the `),q=l(b,"CODE",{});var Ct=i(q);Te=o(Ct,"customValidations"),Ct.forEach(n),Ie=o(b,` array in
the file `),M=l(b,"CODE",{});var Pt=i(M);Le=o(Pt,"ProjectitConfiguration.ts"),Pt.forEach(n),Oe=o(b,". You will find this file in "),R=l(b,"CODE",{});var Tt=i(R);De=o(Tt,"~/picode/projectit"),Tt.forEach(n),je=o(b,`.
It is generated once, and wil not be overwritten on regeneration.`),b.forEach(n),pe=u(e),j=l(e,"P",{});var It=i(j);xe=o(It,"Using the above example class, the configuration should look like this:"),It.forEach(n),ce=u(e),P=l(e,"PRE",{class:!0});var Qt=i(P);Qt.forEach(n),ue=u(e),x=l(e,"H2",{});var Lt=i(x);Ve=o(Lt,"You own Validation Class"),Lt.forEach(n),de=u(e),_=l(e,"P",{});var ye=i(_);Ae=o(ye,"As a convenience, ProjectIt generates a file "),U=l(ye,"CODE",{});var Ot=i(U);Ne=o(Ot,"~/picode/validator/Custom<yourLanguageName>Validator.ts"),Ot.forEach(n),He=o(ye,`,
which will not be overwritten upon regeneration. If you want to use it you can skip steps 1 and 2 in the next
list.`),ye.forEach(n),he=u(e),k=l(e,"OL",{});var H=i(k);B=l(H,"LI",{});var Dt=i(B);v=l(Dt,"P",{});var Y=i(v);Ye=o(Y,"Create a Typescript file somewhere, for instance in "),W=l(Y,"CODE",{});var jt=i(W);Fe=o(jt,"~/picode/validator"),jt.forEach(n),Se=o(Y,`. Note, again,
to not add it to the `),G=l(Y,"CODE",{});var xt=i(G);ze=o(xt,"~/picode/validator/gen"),xt.forEach(n),qe=o(Y," folder, as this will be deleted upon regeneration."),Y.forEach(n),Dt.forEach(n),Me=u(H),y=l(H,"LI",{});var F=i(y);f=l(F,"P",{});var g=i(f);Re=o(g,"Create a class in this file and let this class implement the generated "),J=l(g,"CODE",{});var Vt=i(J);Ue=o(Vt,"<yourLanguageName>CheckerInterface"),Vt.forEach(n),Be=o(g,`,
which you can find in the `),K=l(g,"CODE",{});var At=i(K);We=o(At,"~/picode/validator/gen"),At.forEach(n),Ge=o(g,` folder.
Obviously, `),Q=l(g,"CODE",{});var Nt=i(Q);Je=o(Nt,"<yourLanguageName>"),Nt.forEach(n),Ke=o(g," needs to be replaced by the name of your language."),g.forEach(n),Qe=u(F),T=l(F,"P",{});var Ee=i(T);Xe=o(Ee,"This is the interface to be implemented for the example language called "),X=l(Ee,"CODE",{});var Ht=i(X);Ze=o(Ht,"Entity"),Ht.forEach(n),$e=o(Ee,"."),Ee.forEach(n),et=u(F),V=l(F,"PRE",{class:!0});var Xt=i(V);Xt.forEach(n),F.forEach(n),tt=u(H),Z=l(H,"LI",{});var Yt=i(Z);E=l(Yt,"P",{});var S=i(E);nt=o(S,`Now implement any of the methods of the default worker by putting in your validation in
the corresponding model element method. This method will override the (empty) default implementation.
The validation error should be pushed onto the `),$=l(S,"CODE",{});var Ft=i($);at=o(Ft,"errorList"),Ft.forEach(n),ot=o(S,` attribute. Therefore, each error must implement the
`),A=l(S,"A",{href:!0});var St=i(A);st=o(St,"PiError"),St.forEach(n),lt=o(S," (TODO link) interface."),S.forEach(n),Yt.forEach(n),H.forEach(n),fe=u(e),N=l(e,"P",{});var zt=i(N);it=o(zt,"The result of the above should look something like this:"),zt.forEach(n),ke=u(e),I=l(e,"PRE",{class:!0});var Zt=i(I);Zt.forEach(n),me=u(e),h=l(e,"P",{});var C=i(h);rt=o(C,"In this example only nodes of type "),ee=l(C,"CODE",{});var qt=i(ee);pt=o(qt,"EntityFunction"),qt.forEach(n),ct=o(C," are checked. If the name of the node equals "),te=l(C,"CODE",{});var Mt=i(te);ut=o(Mt,"determine"),Mt.forEach(n),dt=o(C,` than an error is
pushed on the `),ne=l(C,"CODE",{});var Rt=i(ne);ht=o(Rt,"errorList"),Rt.forEach(n),ft=o(C,"."),C.forEach(n),ve=u(e),m=l(e,"P",{});var z=i(m);kt=o(z,`If you want the walker to stop when an erroneous node is found you
should return `),ae=l(z,"CODE",{});var Ut=i(ae);mt=o(Ut,"true"),Ut.forEach(n),vt=o(z,", else return "),oe=l(z,"CODE",{});var Bt=i(oe);yt=o(Bt,"false"),Bt.forEach(n),Et=o(z,"."),z.forEach(n),this.h()},h(){we(P,"class","language-ts"),we(V,"class","language-ts"),we(A,"href","/060_Under_the_Hood/020_The_PiTool_Interfaces/040_PiValidator_Interface#PiError"),we(I,"class","language-ts")},m(e,r){p(e,w,r),t(w,_e),p(e,se,r),p(e,L,r),t(L,be),p(e,le,r),p(e,O,r),t(O,ge),p(e,ie,r),p(e,D,r),t(D,Ce),p(e,re,r),p(e,d,r),t(d,Pe),t(d,q),t(q,Te),t(d,Ie),t(d,M),t(M,Le),t(d,Oe),t(d,R),t(R,De),t(d,je),p(e,pe,r),p(e,j,r),t(j,xe),p(e,ce,r),p(e,P,r),P.innerHTML=Gt,p(e,ue,r),p(e,x,r),t(x,Ve),p(e,de,r),p(e,_,r),t(_,Ae),t(_,U),t(U,Ne),t(_,He),p(e,he,r),p(e,k,r),t(k,B),t(B,v),t(v,Ye),t(v,W),t(W,Fe),t(v,Se),t(v,G),t(G,ze),t(v,qe),t(k,Me),t(k,y),t(y,f),t(f,Re),t(f,J),t(J,Ue),t(f,Be),t(f,K),t(K,We),t(f,Ge),t(f,Q),t(Q,Je),t(f,Ke),t(y,Qe),t(y,T),t(T,Xe),t(T,X),t(X,Ze),t(T,$e),t(y,et),t(y,V),V.innerHTML=Jt,t(k,tt),t(k,Z),t(Z,E),t(E,nt),t(E,$),t($,at),t(E,ot),t(E,A),t(A,st),t(E,lt),p(e,fe,r),p(e,N,r),t(N,it),p(e,ke,r),p(e,I,r),I.innerHTML=Kt,p(e,me,r),p(e,h,r),t(h,rt),t(h,ee),t(ee,pt),t(h,ct),t(h,te),t(te,ut),t(h,dt),t(h,ne),t(ne,ht),t(h,ft),p(e,ve,r),p(e,m,r),t(m,kt),t(m,ae),t(ae,mt),t(m,vt),t(m,oe),t(oe,yt),t(m,Et)},p:wt,i:wt,o:wt,d(e){e&&n(w),e&&n(se),e&&n(L),e&&n(le),e&&n(O),e&&n(ie),e&&n(D),e&&n(re),e&&n(d),e&&n(pe),e&&n(j),e&&n(ce),e&&n(P),e&&n(ue),e&&n(x),e&&n(de),e&&n(_),e&&n(he),e&&n(k),e&&n(fe),e&&n(N),e&&n(ke),e&&n(I),e&&n(me),e&&n(h),e&&n(ve),e&&n(m)}}}class on extends $t{constructor(w){super();en(this,w,null,nn,tn,{})}}export{on as default};
