import{S as Pn,i as In,s as Dn,e as i,t as o,k as c,j as pn,c as p,a as r,g as l,d as t,n as u,m as rn,b as C,f as a,F as n,o as cn,x as un,u as fn,v as yn}from"../../../chunks/vendor-0216fdcb.js";import{N as hn}from"../../../chunks/Note-1a08578a.js";/* empty css                                                         */function An(q){let f;return{c(){f=o("There must be a type hierarchy")},l(y){f=l(y,"There must be a type hierarchy")},m(y,d){a(y,f,d)},d(y){y&&t(f)}}}function Cn(q){let f;return{c(){f=o(`We assume that either
there is a concept which is the common super type of all types in your language, or all types in your
language implement the same interface. The **first** concept or interface in
the types list is considered to be this **root** of your type hierarchy.`)},l(y){f=l(y,`We assume that either
there is a concept which is the common super type of all types in your language, or all types in your
language implement the same interface. The **first** concept or interface in
the types list is considered to be this **root** of your type hierarchy.`)},m(y,d){a(y,f,d)},d(y){y&&t(f)}}}function On(q){let f,y,d,E,T,w,k;return{c(){f=o("In the AST "),y=i("code"),d=o("declaredType"),E=o(" has type "),T=i("code"),w=o("Type"),k=o(`, which 
has in the above example
been stated to be a type in your user's language.`)},l(h){f=l(h,"In the AST "),y=p(h,"CODE",{});var m=r(y);d=l(m,"declaredType"),m.forEach(t),E=l(h," has type "),T=p(h,"CODE",{});var v=r(T);w=l(v,"Type"),v.forEach(t),k=l(h,`, which 
has in the above example
been stated to be a type in your user's language.`)},m(h,m){a(h,f,m),a(h,y,m),n(y,d),a(h,E,m),a(h,T,m),n(T,w),a(h,k,m)},d(h){h&&t(f),h&&t(y),h&&t(E),h&&t(T),h&&t(k)}}}function Hn(q){let f,y,d,E,T,w,k,h,m,v,Ve,Y,Je,Ke,ee,Qe,Xe,me,L,O,Ze,te,et,tt,nt,H,st,ne,at,ot,ve,z,lt,de,U,it,_e,b,pt,se,rt,ct,ae,ut,ft,Ee,W,yt,ke,g,ht,oe,mt,vt,Te,M,mn=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.type#L3-L4</span>

<span class="token comment">// 'BaseType' is the root of the type hierarchy</span>
istype <span class="token punctuation">&#123;</span> BaseType<span class="token punctuation">,</span> Type<span class="token punctuation">,</span> Entity<span class="token punctuation">,</span> AttributeType <span class="token punctuation">&#125;</span></code>`,be,$,we,V,dt,Le,R,_t,le,Et,kt,ge,N,vn=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L63-L69</span>

concept EntityFunction <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    aliases<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    expression<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
    parameters<span class="token operator">:</span> Variable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    reference declaredType <span class="token operator">:</span> Type<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,$e,S,dn=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.type#L20-L22</span>

EntityFunction <span class="token punctuation">&#123;</span>
    infertype self<span class="token punctuation">.</span>declaredType<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Re,x,xe,P,Tt,ie,bt,wt,Pe,F,_n=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.type#L23-L25</span>

EntityExpression <span class="token punctuation">&#123;</span>
    <span class="token keyword">abstract</span> infertype <span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Ie,I,Lt,pe,gt,$t,De,G,En=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.type#L44-L46</span>

ComparisonExpression <span class="token punctuation">&#123;</span>
    infertype AttributeType<span class="token operator">:</span>Boolean<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Ae,J,Rt,Ce,_,xt,re,Pt,It,ce,Dt,At,ue,Ct,Ot,Oe,K,Ht,He,B,kn=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.type#L11-L13</span>

Entity <span class="token punctuation">&#123;</span>
    conformsto self<span class="token punctuation">.</span>baseEntity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Me,Q,Mt,Ne,D,Nt,fe,St,Ft,Se,j,Tn=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.type#L6-L9</span>

anytype <span class="token punctuation">&#123;</span>
    conformsto AttributeType<span class="token operator">:</span><span class="token constant">ANY</span><span class="token punctuation">;</span>
    equalsto AttributeType<span class="token operator">:</span><span class="token constant">ANY</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Fe;return $=new hn({props:{$$slots:{content:[Cn],header:[An]},$$scope:{ctx:q}}}),x=new hn({props:{$$slots:{content:[On]},$$scope:{ctx:q}}}),{c(){f=i("h1"),y=o("The Typer Definition"),d=c(),E=i("p"),T=o(`This tutorial describes the possibilities of defining a type provider (or typer, for short).
In the typer definition you provide
the information necessary to do type checking.`),w=c(),k=i("h3"),h=o("Three-level definition"),m=c(),v=i("p"),Ve=o("As explained in "),Y=i("a"),Je=o("Three Levels of Customization"),Ke=o(`
the generated typer can be defined in three levels.
For each `),ee=i("em"),Qe=o("concept"),Xe=o(" in the AST the typer will"),me=c(),L=i("ol"),O=i("li"),Ze=o("use the "),te=i("em"),et=o("hand-made typing rule(s)"),tt=o(", when present. Otherwise, the validator will"),nt=c(),H=i("li"),st=o("use to the "),ne=i("em"),at=o("typing rule(s) generated from the typer definition"),ot=o(", when this definition is present."),ve=c(),z=i("p"),lt=o("There are no default typing rules, so the typer does not have a fallback to a third level."),de=c(),U=i("h2"),it=o("The Typer Definition File"),_e=c(),b=i("p"),pt=o("In the typer definition file (with extension "),se=i("code"),rt=o(".type"),ct=o(`) you can indicate typing rules for every
`),ae=i("em"),ut=o("concept"),ft=o(" in your language."),Ee=c(),W=i("h3"),yt=o("Types"),ke=c(),g=i("p"),ht=o(`First, you have to indicate which concepts are considered to be types in your language.
You indicate this by the keyword `),oe=i("code"),mt=o("isType"),vt=o(` followed by all types in your language between curly
brackets.`),Te=c(),M=i("pre"),be=c(),pn($.$$.fragment),we=c(),V=i("h3"),dt=o("Inference Rules"),Le=c(),R=i("p"),_t=o("Using "),le=i("strong"),Et=o("inference rules"),kt=o(`, you can indicate how to determine the type of certain concepts. Every concept
for which an inference rule is defined has a type. That type is determined according to the given
rule. In the following example the type of entity function is the value of its attribute
\u2018declaredType\u2019.`),ge=c(),N=i("pre"),$e=c(),S=i("pre"),Re=c(),pn(x.$$.fragment),xe=c(),P=i("p"),Tt=o("By stating that an inference rule is "),ie=i("strong"),bt=o("abstract"),wt=o(`, you define that the concept does have a type, but the
way its type is determined, is given by the inference rules of its subconcepts.`),Pe=c(),F=i("pre"),Ie=c(),I=i("p"),Lt=o("It is possible to use the predefined instances of a "),pe=i("strong"),gt=o("limited concept"),$t=o("."),De=c(),G=i("pre"),Ae=c(),J=i("h3"),Rt=o("Type Conformance Rules"),Ce=c(),_=i("p"),xt=o("Finally, you have to state your "),re=i("strong"),Pt=o("type conformance rules"),It=o(`. There are two flavours of conformance rules:
the `),ce=i("strong"),Dt=o("conformsto"),At=o(" and the "),ue=i("strong"),Ct=o("equalsto"),Ot=o(" rules. To a language engineer the differences between these will be clear."),Oe=c(),K=i("p"),Ht=o(`In conformance rules
it is also possible to use the predefined instances of a limited concept.`),He=c(),B=i("pre"),Me=c(),Q=i("h2"),Mt=o("Rules that Apply to any Concept"),Ne=c(),D=i("p"),Nt=o("Conformance and other rules can also be defined to apply to *"),fe=i("em"),St=o("any"),Ft=o(` concept. Obviously, this means that
any instance of any concept conforms to the given value.`),Se=c(),j=i("pre"),this.h()},l(e){f=p(e,"H1",{});var s=r(f);y=l(s,"The Typer Definition"),s.forEach(t),d=u(e),E=p(e,"P",{});var ye=r(E);T=l(ye,`This tutorial describes the possibilities of defining a type provider (or typer, for short).
In the typer definition you provide
the information necessary to do type checking.`),ye.forEach(t),w=u(e),k=p(e,"H3",{});var he=r(k);h=l(he,"Three-level definition"),he.forEach(t),m=u(e),v=p(e,"P",{});var X=r(v);Ve=l(X,"As explained in "),Y=p(X,"A",{href:!0});var Gt=r(Y);Je=l(Gt,"Three Levels of Customization"),Gt.forEach(t),Ke=l(X,`
the generated typer can be defined in three levels.
For each `),ee=p(X,"EM",{});var Bt=r(ee);Qe=l(Bt,"concept"),Bt.forEach(t),Xe=l(X," in the AST the typer will"),X.forEach(t),me=u(e),L=p(e,"OL",{});var Ge=r(L);O=p(Ge,"LI",{});var Be=r(O);Ze=l(Be,"use the "),te=p(Be,"EM",{});var jt=r(te);et=l(jt,"hand-made typing rule(s)"),jt.forEach(t),tt=l(Be,", when present. Otherwise, the validator will"),Be.forEach(t),nt=u(Ge),H=p(Ge,"LI",{});var je=r(H);st=l(je,"use to the "),ne=p(je,"EM",{});var qt=r(ne);at=l(qt,"typing rule(s) generated from the typer definition"),qt.forEach(t),ot=l(je,", when this definition is present."),je.forEach(t),Ge.forEach(t),ve=u(e),z=p(e,"P",{});var Yt=r(z);lt=l(Yt,"There are no default typing rules, so the typer does not have a fallback to a third level."),Yt.forEach(t),de=u(e),U=p(e,"H2",{});var zt=r(U);it=l(zt,"The Typer Definition File"),zt.forEach(t),_e=u(e),b=p(e,"P",{});var Z=r(b);pt=l(Z,"In the typer definition file (with extension "),se=p(Z,"CODE",{});var Ut=r(se);rt=l(Ut,".type"),Ut.forEach(t),ct=l(Z,`) you can indicate typing rules for every
`),ae=p(Z,"EM",{});var Wt=r(ae);ut=l(Wt,"concept"),Wt.forEach(t),ft=l(Z," in your language."),Z.forEach(t),Ee=u(e),W=p(e,"H3",{});var Vt=r(W);yt=l(Vt,"Types"),Vt.forEach(t),ke=u(e),g=p(e,"P",{});var qe=r(g);ht=l(qe,`First, you have to indicate which concepts are considered to be types in your language.
You indicate this by the keyword `),oe=p(qe,"CODE",{});var Jt=r(oe);mt=l(Jt,"isType"),Jt.forEach(t),vt=l(qe,` followed by all types in your language between curly
brackets.`),qe.forEach(t),Te=u(e),M=p(e,"PRE",{class:!0});var bn=r(M);bn.forEach(t),be=u(e),rn($.$$.fragment,e),we=u(e),V=p(e,"H3",{});var Kt=r(V);dt=l(Kt,"Inference Rules"),Kt.forEach(t),Le=u(e),R=p(e,"P",{});var Ye=r(R);_t=l(Ye,"Using "),le=p(Ye,"STRONG",{});var Qt=r(le);Et=l(Qt,"inference rules"),Qt.forEach(t),kt=l(Ye,`, you can indicate how to determine the type of certain concepts. Every concept
for which an inference rule is defined has a type. That type is determined according to the given
rule. In the following example the type of entity function is the value of its attribute
\u2018declaredType\u2019.`),Ye.forEach(t),ge=u(e),N=p(e,"PRE",{class:!0});var wn=r(N);wn.forEach(t),$e=u(e),S=p(e,"PRE",{class:!0});var Ln=r(S);Ln.forEach(t),Re=u(e),rn(x.$$.fragment,e),xe=u(e),P=p(e,"P",{});var ze=r(P);Tt=l(ze,"By stating that an inference rule is "),ie=p(ze,"STRONG",{});var Xt=r(ie);bt=l(Xt,"abstract"),Xt.forEach(t),wt=l(ze,`, you define that the concept does have a type, but the
way its type is determined, is given by the inference rules of its subconcepts.`),ze.forEach(t),Pe=u(e),F=p(e,"PRE",{class:!0});var gn=r(F);gn.forEach(t),Ie=u(e),I=p(e,"P",{});var Ue=r(I);Lt=l(Ue,"It is possible to use the predefined instances of a "),pe=p(Ue,"STRONG",{});var Zt=r(pe);gt=l(Zt,"limited concept"),Zt.forEach(t),$t=l(Ue,"."),Ue.forEach(t),De=u(e),G=p(e,"PRE",{class:!0});var $n=r(G);$n.forEach(t),Ae=u(e),J=p(e,"H3",{});var en=r(J);Rt=l(en,"Type Conformance Rules"),en.forEach(t),Ce=u(e),_=p(e,"P",{});var A=r(_);xt=l(A,"Finally, you have to state your "),re=p(A,"STRONG",{});var tn=r(re);Pt=l(tn,"type conformance rules"),tn.forEach(t),It=l(A,`. There are two flavours of conformance rules:
the `),ce=p(A,"STRONG",{});var nn=r(ce);Dt=l(nn,"conformsto"),nn.forEach(t),At=l(A," and the "),ue=p(A,"STRONG",{});var sn=r(ue);Ct=l(sn,"equalsto"),sn.forEach(t),Ot=l(A," rules. To a language engineer the differences between these will be clear."),A.forEach(t),Oe=u(e),K=p(e,"P",{});var an=r(K);Ht=l(an,`In conformance rules
it is also possible to use the predefined instances of a limited concept.`),an.forEach(t),He=u(e),B=p(e,"PRE",{class:!0});var Rn=r(B);Rn.forEach(t),Me=u(e),Q=p(e,"H2",{});var on=r(Q);Mt=l(on,"Rules that Apply to any Concept"),on.forEach(t),Ne=u(e),D=p(e,"P",{});var We=r(D);Nt=l(We,"Conformance and other rules can also be defined to apply to *"),fe=p(We,"EM",{});var ln=r(fe);St=l(ln,"any"),ln.forEach(t),Ft=l(We,` concept. Obviously, this means that
any instance of any concept conforms to the given value.`),We.forEach(t),Se=u(e),j=p(e,"PRE",{class:!0});var xn=r(j);xn.forEach(t),this.h()},h(){C(Y,"href","/010_Intro/050_Three_Levels_of_Customization#levels"),C(M,"class","language-ts"),C(N,"class","language-ts"),C(S,"class","language-ts"),C(F,"class","language-ts"),C(G,"class","language-ts"),C(B,"class","language-ts"),C(j,"class","language-ts")},m(e,s){a(e,f,s),n(f,y),a(e,d,s),a(e,E,s),n(E,T),a(e,w,s),a(e,k,s),n(k,h),a(e,m,s),a(e,v,s),n(v,Ve),n(v,Y),n(Y,Je),n(v,Ke),n(v,ee),n(ee,Qe),n(v,Xe),a(e,me,s),a(e,L,s),n(L,O),n(O,Ze),n(O,te),n(te,et),n(O,tt),n(L,nt),n(L,H),n(H,st),n(H,ne),n(ne,at),n(H,ot),a(e,ve,s),a(e,z,s),n(z,lt),a(e,de,s),a(e,U,s),n(U,it),a(e,_e,s),a(e,b,s),n(b,pt),n(b,se),n(se,rt),n(b,ct),n(b,ae),n(ae,ut),n(b,ft),a(e,Ee,s),a(e,W,s),n(W,yt),a(e,ke,s),a(e,g,s),n(g,ht),n(g,oe),n(oe,mt),n(g,vt),a(e,Te,s),a(e,M,s),M.innerHTML=mn,a(e,be,s),cn($,e,s),a(e,we,s),a(e,V,s),n(V,dt),a(e,Le,s),a(e,R,s),n(R,_t),n(R,le),n(le,Et),n(R,kt),a(e,ge,s),a(e,N,s),N.innerHTML=vn,a(e,$e,s),a(e,S,s),S.innerHTML=dn,a(e,Re,s),cn(x,e,s),a(e,xe,s),a(e,P,s),n(P,Tt),n(P,ie),n(ie,bt),n(P,wt),a(e,Pe,s),a(e,F,s),F.innerHTML=_n,a(e,Ie,s),a(e,I,s),n(I,Lt),n(I,pe),n(pe,gt),n(I,$t),a(e,De,s),a(e,G,s),G.innerHTML=En,a(e,Ae,s),a(e,J,s),n(J,Rt),a(e,Ce,s),a(e,_,s),n(_,xt),n(_,re),n(re,Pt),n(_,It),n(_,ce),n(ce,Dt),n(_,At),n(_,ue),n(ue,Ct),n(_,Ot),a(e,Oe,s),a(e,K,s),n(K,Ht),a(e,He,s),a(e,B,s),B.innerHTML=kn,a(e,Me,s),a(e,Q,s),n(Q,Mt),a(e,Ne,s),a(e,D,s),n(D,Nt),n(D,fe),n(fe,St),n(D,Ft),a(e,Se,s),a(e,j,s),j.innerHTML=Tn,Fe=!0},p(e,[s]){const ye={};s&1&&(ye.$$scope={dirty:s,ctx:e}),$.$set(ye);const he={};s&1&&(he.$$scope={dirty:s,ctx:e}),x.$set(he)},i(e){Fe||(un($.$$.fragment,e),un(x.$$.fragment,e),Fe=!0)},o(e){fn($.$$.fragment,e),fn(x.$$.fragment,e),Fe=!1},d(e){e&&t(f),e&&t(d),e&&t(E),e&&t(w),e&&t(k),e&&t(m),e&&t(v),e&&t(me),e&&t(L),e&&t(ve),e&&t(z),e&&t(de),e&&t(U),e&&t(_e),e&&t(b),e&&t(Ee),e&&t(W),e&&t(ke),e&&t(g),e&&t(Te),e&&t(M),e&&t(be),yn($,e),e&&t(we),e&&t(V),e&&t(Le),e&&t(R),e&&t(ge),e&&t(N),e&&t($e),e&&t(S),e&&t(Re),yn(x,e),e&&t(xe),e&&t(P),e&&t(Pe),e&&t(F),e&&t(Ie),e&&t(I),e&&t(De),e&&t(G),e&&t(Ae),e&&t(J),e&&t(Ce),e&&t(_),e&&t(Oe),e&&t(K),e&&t(He),e&&t(B),e&&t(Me),e&&t(Q),e&&t(Ne),e&&t(D),e&&t(Se),e&&t(j)}}}class Fn extends Pn{constructor(f){super();In(this,f,null,Hn,Dn,{})}}export{Fn as default};
