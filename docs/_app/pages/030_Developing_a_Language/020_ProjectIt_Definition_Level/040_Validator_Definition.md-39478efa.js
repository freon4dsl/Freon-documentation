import{S as Ms,i as Ss,s as Ns,e as o,t as l,k as u,c as p,a as r,g as n,d as t,n as f,b as C,f as a,F as s,H as Yt}from"../../../chunks/vendor-0216fdcb.js";/* empty css                                                         */function Fs(Is){let k,ze,ce,O,Ue,de,A,Be,he,h,Je,V,Ke,Qe,X,Xe,Ye,ve,v,b,Ze,Y,$e,ge,et,L,tt,Z,st,lt,nt,D,it,q,$,at,ot,me,E,pt,g,rt,ut,ye,G,ft,_e,H,ct,ke,M,dt,Ee,m,ht,ee,vt,mt,te,yt,_t,Te,c,kt,se,Et,Tt,le,wt,bt,ne,Lt,Dt,ie,Pt,Rt,we,P,xs=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.valid#L21-L26</span>

AttributeWithLimitedType <span class="token punctuation">&#123;</span>
    validIdentifier self<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
Variable <span class="token punctuation">&#123;</span>
    validIdentifier<span class="token punctuation">;</span> <span class="token comment">// default is 'name'</span>
<span class="token punctuation">&#125;</span></code>`,be,S,It,Le,N,xt,De,R,Cs=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.valid#L3-L6</span>

AttributeType  <span class="token punctuation">&#123;</span>
	self<span class="token punctuation">.</span>extra <span class="token operator">>=</span> <span class="token number">12</span><span class="token punctuation">;</span>
	self<span class="token punctuation">.</span>extra <span class="token operator">&lt;=</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Pe,F,Ct,Re,T,Ot,ae,At,Vt,Ie,w,qt,oe,Gt,Ht,xe,I,Os=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.valid#L7-L9</span>

EntityModelUnit <span class="token punctuation">&#123;</span>
    notEmpty self<span class="token punctuation">.</span>entities<span class="token punctuation">;</span>
    isunique name <span class="token keyword">in</span> self<span class="token punctuation">.</span>entities<span class="token punctuation">;</span></code>`,Ce,j,Mt,Oe,d,St,pe,Nt,Ft,re,jt,Wt,ue,zt,Ut,fe,Bt,Jt,Ae,W,Kt,Ve,x,As=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.valid#L35-L39</span>

MultiplyExpression <span class="token punctuation">&#123;</span>
    typecheck <span class="token function">equalsType</span><span class="token punctuation">(</span> self<span class="token punctuation">.</span>left<span class="token punctuation">,</span> AttributeType<span class="token operator">:</span>Integer <span class="token punctuation">)</span><span class="token punctuation">;</span>
    typecheck <span class="token function">equalsType</span><span class="token punctuation">(</span> self<span class="token punctuation">.</span>right<span class="token punctuation">,</span> AttributeType<span class="token operator">:</span>Integer <span class="token punctuation">)</span><span class="token punctuation">;</span>
    typecheck <span class="token function">conformsTo</span><span class="token punctuation">(</span> self<span class="token punctuation">.</span>left<span class="token punctuation">,</span> self<span class="token punctuation">.</span>right <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,qe,z,Ge,U,Qt,He,B,Xt;return{c(){k=o("h1"),ze=l("The Validator Definition"),ce=u(),O=o("p"),Ue=l(`The validator definition is the definition of the rules that hold in your language. These rules are not the rules
of the concrete syntax, but instead they provide an extra check of the models.`),de=u(),A=o("h3"),Be=l("Three-level definition"),he=u(),h=o("p"),Je=l("As explained in "),V=o("a"),Ke=l("Three Levels of Customization"),Qe=l(`
the generated validator can be defined in three levels.
For each *`),X=o("em"),Xe=l("concept"),Ye=l(" in the AST the validator will"),ve=u(),v=o("ol"),b=o("li"),Ze=l("use the "),Y=o("em"),$e=l("hand-made validation rule(s)"),ge=l(", when present. Otherwise, the validator will"),et=u(),L=o("li"),tt=l("use to the "),Z=o("em"),st=l("validation rule(s) generated from the validator definition"),lt=l(`, when this definition is present.
Finally, the validator will`),nt=u(),D=o("li"),it=l(`use the
`),q=o("a"),$=o("em"),at=l("default validation rule(s)"),ot=l("."),me=u(),E=o("p"),pt=l("The rest of this tutorial explains the second level: how to write a validator definition ("),g=o("code"),rt=l(".valid"),ut=l(" file)."),ye=u(),G=o("h2"),ft=l("The Validator Definition File"),_e=u(),H=o("p"),ct=l(`The validator definition defines the constraints or rules that should be true in the models build by your users.
Currently, there are four types of rules.`),ke=u(),M=o("h3"),dt=l("Valid Identifier Rules"),Ee=u(),m=o("p"),ht=l("Given a simple property of type "),ee=o("em"),vt=l("identifier"),mt=l(", a "),te=o("strong"),yt=l("valid-identifier-rule"),_t=l(` can be given. The property complies with the
rule if it is a valid identifier according to the TypeScript definition.`),Te=u(),c=o("p"),kt=l("For a "),se=o("em"),Et=l("valid-identifier-rule"),Tt=l(" the "),le=o("code"),wt=l("validIdentifier"),bt=l(` keyword is used followed by an optional simple property. When the
property is present, this property is checked. When the property is not present, ProjectIt assumes that the
concept has a simple property named \u2018`),ne=o("code"),Lt=l("name"),Dt=l("\u2019 of type \u2018"),ie=o("code"),Pt=l("identifier"),Rt=l("\u2019, and it will check this property."),we=u(),P=o("pre"),be=u(),S=o("h3"),It=l("Simple Value Rules"),Le=u(),N=o("p"),xt=l("Given a simple property, its value can be limited to certain values."),De=u(),R=o("pre"),Pe=u(),F=o("h3"),Ct=l("List Rules"),Re=u(),T=o("p"),Ot=l("Given a list property, a "),ae=o("strong"),At=l("not-empty rule"),Vt=l(" can be stated. The list complies with the rule if it is not empty."),Ie=u(),w=o("p"),qt=l("An "),oe=o("strong"),Gt=l("is-unique rule"),Ht=l(` is another rule that can be stated for a list property. The list
complies when the value of the property is unique within the list.`),xe=u(),I=o("pre"),Ce=u(),j=o("h3"),Mt=l("Type Check Rules"),Oe=u(),d=o("p"),St=l(`Given the rules in the typer definition, rules can be stated to ensure type compliance.
To indicate a `),pe=o("strong"),Nt=l("type checking rule"),Ft=l(" the keyword "),re=o("code"),jt=l("typecheck"),Wt=l(" is used, followed by either "),ue=o("code"),zt=l("equalsType"),Ut=l(" or "),fe=o("code"),Bt=l("conformsTo"),Jt=l(`.
The first demands that the types of the two properties given are equal. The second demands that the type of the first
conforms to the type of the second.`),Ae=u(),W=o("p"),Kt=l("In type checking rules it is possible to use predefined instances of a limited concept."),Ve=u(),x=o("pre"),qe=u(),z=o("a"),Ge=l(`
## The Default Validation Rules
`),U=o("p"),Qt=l("There are just a few default validation rules:"),He=u(),B=o("p"),Xt=l(`. Non optional properties must be set.
. Non optional lists must include one element.
. Names of model units should be valid identifiers.`),this.h()},l(e){k=p(e,"H1",{});var i=r(k);ze=n(i,"The Validator Definition"),i.forEach(t),ce=f(e),O=p(e,"P",{});var Zt=r(O);Ue=n(Zt,`The validator definition is the definition of the rules that hold in your language. These rules are not the rules
of the concrete syntax, but instead they provide an extra check of the models.`),Zt.forEach(t),de=f(e),A=p(e,"H3",{});var $t=r(A);Be=n($t,"Three-level definition"),$t.forEach(t),he=f(e),h=p(e,"P",{});var J=r(h);Je=n(J,"As explained in "),V=p(J,"A",{href:!0});var gt=r(V);Ke=n(gt,"Three Levels of Customization"),gt.forEach(t),Qe=n(J,`
the generated validator can be defined in three levels.
For each *`),X=p(J,"EM",{});var es=r(X);Xe=n(es,"concept"),es.forEach(t),Ye=n(J," in the AST the validator will"),J.forEach(t),ve=f(e),v=p(e,"OL",{});var K=r(v);b=p(K,"LI",{});var Me=r(b);Ze=n(Me,"use the "),Y=p(Me,"EM",{});var ts=r(Y);$e=n(ts,"hand-made validation rule(s)"),ts.forEach(t),ge=n(Me,", when present. Otherwise, the validator will"),Me.forEach(t),et=f(K),L=p(K,"LI",{});var Se=r(L);tt=n(Se,"use to the "),Z=p(Se,"EM",{});var ss=r(Z);st=n(ss,"validation rule(s) generated from the validator definition"),ss.forEach(t),lt=n(Se,`, when this definition is present.
Finally, the validator will`),Se.forEach(t),nt=f(K),D=p(K,"LI",{});var Ne=r(D);it=n(Ne,`use the
`),q=p(Ne,"A",{href:!0});var ls=r(q);$=p(ls,"EM",{});var ns=r($);at=n(ns,"default validation rule(s)"),ns.forEach(t),ls.forEach(t),ot=n(Ne,"."),Ne.forEach(t),K.forEach(t),me=f(e),E=p(e,"P",{});var Fe=r(E);pt=n(Fe,"The rest of this tutorial explains the second level: how to write a validator definition ("),g=p(Fe,"CODE",{});var is=r(g);rt=n(is,".valid"),is.forEach(t),ut=n(Fe," file)."),Fe.forEach(t),ye=f(e),G=p(e,"H2",{});var as=r(G);ft=n(as,"The Validator Definition File"),as.forEach(t),_e=f(e),H=p(e,"P",{});var os=r(H);ct=n(os,`The validator definition defines the constraints or rules that should be true in the models build by your users.
Currently, there are four types of rules.`),os.forEach(t),ke=f(e),M=p(e,"H3",{});var ps=r(M);dt=n(ps,"Valid Identifier Rules"),ps.forEach(t),Ee=f(e),m=p(e,"P",{});var Q=r(m);ht=n(Q,"Given a simple property of type "),ee=p(Q,"EM",{});var rs=r(ee);vt=n(rs,"identifier"),rs.forEach(t),mt=n(Q,", a "),te=p(Q,"STRONG",{});var us=r(te);yt=n(us,"valid-identifier-rule"),us.forEach(t),_t=n(Q,` can be given. The property complies with the
rule if it is a valid identifier according to the TypeScript definition.`),Q.forEach(t),Te=f(e),c=p(e,"P",{});var y=r(c);kt=n(y,"For a "),se=p(y,"EM",{});var fs=r(se);Et=n(fs,"valid-identifier-rule"),fs.forEach(t),Tt=n(y," the "),le=p(y,"CODE",{});var cs=r(le);wt=n(cs,"validIdentifier"),cs.forEach(t),bt=n(y,` keyword is used followed by an optional simple property. When the
property is present, this property is checked. When the property is not present, ProjectIt assumes that the
concept has a simple property named \u2018`),ne=p(y,"CODE",{});var ds=r(ne);Lt=n(ds,"name"),ds.forEach(t),Dt=n(y,"\u2019 of type \u2018"),ie=p(y,"CODE",{});var hs=r(ie);Pt=n(hs,"identifier"),hs.forEach(t),Rt=n(y,"\u2019, and it will check this property."),y.forEach(t),we=f(e),P=p(e,"PRE",{class:!0});var Vs=r(P);Vs.forEach(t),be=f(e),S=p(e,"H3",{});var vs=r(S);It=n(vs,"Simple Value Rules"),vs.forEach(t),Le=f(e),N=p(e,"P",{});var ms=r(N);xt=n(ms,"Given a simple property, its value can be limited to certain values."),ms.forEach(t),De=f(e),R=p(e,"PRE",{class:!0});var qs=r(R);qs.forEach(t),Pe=f(e),F=p(e,"H3",{});var ys=r(F);Ct=n(ys,"List Rules"),ys.forEach(t),Re=f(e),T=p(e,"P",{});var je=r(T);Ot=n(je,"Given a list property, a "),ae=p(je,"STRONG",{});var _s=r(ae);At=n(_s,"not-empty rule"),_s.forEach(t),Vt=n(je," can be stated. The list complies with the rule if it is not empty."),je.forEach(t),Ie=f(e),w=p(e,"P",{});var We=r(w);qt=n(We,"An "),oe=p(We,"STRONG",{});var ks=r(oe);Gt=n(ks,"is-unique rule"),ks.forEach(t),Ht=n(We,` is another rule that can be stated for a list property. The list
complies when the value of the property is unique within the list.`),We.forEach(t),xe=f(e),I=p(e,"PRE",{class:!0});var Gs=r(I);Gs.forEach(t),Ce=f(e),j=p(e,"H3",{});var Es=r(j);Mt=n(Es,"Type Check Rules"),Es.forEach(t),Oe=f(e),d=p(e,"P",{});var _=r(d);St=n(_,`Given the rules in the typer definition, rules can be stated to ensure type compliance.
To indicate a `),pe=p(_,"STRONG",{});var Ts=r(pe);Nt=n(Ts,"type checking rule"),Ts.forEach(t),Ft=n(_," the keyword "),re=p(_,"CODE",{});var ws=r(re);jt=n(ws,"typecheck"),ws.forEach(t),Wt=n(_," is used, followed by either "),ue=p(_,"CODE",{});var bs=r(ue);zt=n(bs,"equalsType"),bs.forEach(t),Ut=n(_," or "),fe=p(_,"CODE",{});var Ls=r(fe);Bt=n(Ls,"conformsTo"),Ls.forEach(t),Jt=n(_,`.
The first demands that the types of the two properties given are equal. The second demands that the type of the first
conforms to the type of the second.`),_.forEach(t),Ae=f(e),W=p(e,"P",{});var Ds=r(W);Kt=n(Ds,"In type checking rules it is possible to use predefined instances of a limited concept."),Ds.forEach(t),Ve=f(e),x=p(e,"PRE",{class:!0});var Hs=r(x);Hs.forEach(t),qe=f(e),z=p(e,"A",{name:!0}),r(z).forEach(t),Ge=n(e,`
## The Default Validation Rules
`),U=p(e,"P",{});var Ps=r(U);Qt=n(Ps,"There are just a few default validation rules:"),Ps.forEach(t),He=f(e),B=p(e,"P",{});var Rs=r(B);Xt=n(Rs,`. Non optional properties must be set.
. Non optional lists must include one element.
. Names of model units should be valid identifiers.`),Rs.forEach(t),this.h()},h(){C(V,"href","/010_Intro/050_Three_Levels_of_Customization#levels"),C(q,"href","/030_Developing_a_Language/020_ProjectIt_Definition_Level/040_Validator_Definition#default-validation-rules"),C(P,"class","language-ts"),C(R,"class","language-ts"),C(I,"class","language-ts"),C(x,"class","language-ts"),C(z,"name","default-validation-rules")},m(e,i){a(e,k,i),s(k,ze),a(e,ce,i),a(e,O,i),s(O,Ue),a(e,de,i),a(e,A,i),s(A,Be),a(e,he,i),a(e,h,i),s(h,Je),s(h,V),s(V,Ke),s(h,Qe),s(h,X),s(X,Xe),s(h,Ye),a(e,ve,i),a(e,v,i),s(v,b),s(b,Ze),s(b,Y),s(Y,$e),s(b,ge),s(v,et),s(v,L),s(L,tt),s(L,Z),s(Z,st),s(L,lt),s(v,nt),s(v,D),s(D,it),s(D,q),s(q,$),s($,at),s(D,ot),a(e,me,i),a(e,E,i),s(E,pt),s(E,g),s(g,rt),s(E,ut),a(e,ye,i),a(e,G,i),s(G,ft),a(e,_e,i),a(e,H,i),s(H,ct),a(e,ke,i),a(e,M,i),s(M,dt),a(e,Ee,i),a(e,m,i),s(m,ht),s(m,ee),s(ee,vt),s(m,mt),s(m,te),s(te,yt),s(m,_t),a(e,Te,i),a(e,c,i),s(c,kt),s(c,se),s(se,Et),s(c,Tt),s(c,le),s(le,wt),s(c,bt),s(c,ne),s(ne,Lt),s(c,Dt),s(c,ie),s(ie,Pt),s(c,Rt),a(e,we,i),a(e,P,i),P.innerHTML=xs,a(e,be,i),a(e,S,i),s(S,It),a(e,Le,i),a(e,N,i),s(N,xt),a(e,De,i),a(e,R,i),R.innerHTML=Cs,a(e,Pe,i),a(e,F,i),s(F,Ct),a(e,Re,i),a(e,T,i),s(T,Ot),s(T,ae),s(ae,At),s(T,Vt),a(e,Ie,i),a(e,w,i),s(w,qt),s(w,oe),s(oe,Gt),s(w,Ht),a(e,xe,i),a(e,I,i),I.innerHTML=Os,a(e,Ce,i),a(e,j,i),s(j,Mt),a(e,Oe,i),a(e,d,i),s(d,St),s(d,pe),s(pe,Nt),s(d,Ft),s(d,re),s(re,jt),s(d,Wt),s(d,ue),s(ue,zt),s(d,Ut),s(d,fe),s(fe,Bt),s(d,Jt),a(e,Ae,i),a(e,W,i),s(W,Kt),a(e,Ve,i),a(e,x,i),x.innerHTML=As,a(e,qe,i),a(e,z,i),a(e,Ge,i),a(e,U,i),s(U,Qt),a(e,He,i),a(e,B,i),s(B,Xt)},p:Yt,i:Yt,o:Yt,d(e){e&&t(k),e&&t(ce),e&&t(O),e&&t(de),e&&t(A),e&&t(he),e&&t(h),e&&t(ve),e&&t(v),e&&t(me),e&&t(E),e&&t(ye),e&&t(G),e&&t(_e),e&&t(H),e&&t(ke),e&&t(M),e&&t(Ee),e&&t(m),e&&t(Te),e&&t(c),e&&t(we),e&&t(P),e&&t(be),e&&t(S),e&&t(Le),e&&t(N),e&&t(De),e&&t(R),e&&t(Pe),e&&t(F),e&&t(Re),e&&t(T),e&&t(Ie),e&&t(w),e&&t(xe),e&&t(I),e&&t(Ce),e&&t(j),e&&t(Oe),e&&t(d),e&&t(Ae),e&&t(W),e&&t(Ve),e&&t(x),e&&t(qe),e&&t(z),e&&t(Ge),e&&t(U),e&&t(He),e&&t(B)}}}class zs extends Ms{constructor(k){super();Ss(this,k,null,Fs,Ns,{})}}export{zs as default};
