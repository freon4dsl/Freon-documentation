import{S as Ze,i as et,s as tt,e as l,t as a,k as m,w as nt,c as p,a as c,h as o,d as t,m as d,x as st,b as ae,g as i,H as n,y as at,q as ot,o as it,B as lt}from"../../../chunks/vendor-492729b6.js";import{N as pt}from"../../../chunks/Note-1bdf01a3.js";/* empty css                                                         */function ct(B){let r;return{c(){r=a("Each model unit is a namespace.")},l(f){r=o(f,"Each model unit is a namespace.")},m(f,v){i(f,r,v)},d(f){f&&t(r)}}}function rt(B){let r;return{c(){r=a("On all Levels of Customizations model units are always considered to be namespaces.")},l(f){r=o(f,"On all Levels of Customizations model units are always considered to be namespaces.")},m(f,v){i(f,r,v)},d(f){f&&t(r)}}}function ft(B){let r,f,v,_,oe,L,ie,le,q,b,pe,O,ce,re,G,$,fe,U,I,ue,g,h,me,H,de,he,N,ye,ve,j,k,Je=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.scope#L3-L3</span>

isnamespace <span class="token punctuation">&#123;</span> EntityModelUnit<span class="token punctuation">,</span> Entity<span class="token punctuation">,</span> EntityFunction <span class="token punctuation">&#125;</span></code>`,J,D,_e,K,E,Q,C,be,V,u,Ee,F,we,ke,M,Te,Ae,R,xe,Le,Y,$e,Ie,W,T,Ke=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.scope#L5-L7</span>

Entity <span class="token punctuation">&#123;</span>
    namespace_addition <span class="token operator">=</span> self<span class="token punctuation">.</span>baseEntity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,X,P,De,Z,w,Ce,z,Pe,Se,ee,A,Qe=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.scope#L15-L17</span>

AppliedFeature <span class="token punctuation">&#123;</span>
	scope <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span> container <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,te;return E=new pt({props:{$$slots:{content:[rt],header:[ct]},$$scope:{ctx:B}}}),{c(){r=l("h1"),f=a("The Scoper Definition"),v=m(),_=l("p"),oe=a("For now, the scoper definition does not support our "),L=l("a"),ie=a("three-level approach"),le=a(`.
You can manually code your own scoper on the 3rd level, but it is not possible to combine this with the
scopers on the 1st and 2nd levels.`),q=m(),b=l("p"),pe=a(`This tutorial
describes the possibilities of defining a scoper in the scoper definition file (with extension `),O=l("code"),ce=a(".scope"),re=a(")."),G=m(),$=l("p"),fe=a(`In the scoper definition you provide the information necessary to determine which names are visible from a certain
element of your user\u2019s model.`),U=m(),I=l("h2"),ue=a("Namespaces"),g=m(),h=l("p"),me=a("In the scoper definition you can mark a list of concepts to be "),H=l("strong"),de=a("namespaces"),he=a(". Any "),N=l("em"),ye=a("namespace"),ve=a(` has its own
set of visible names. Any namespace shadows the visible names from its surrounding namespace (using lexical scope).
The default scoper simply regards the model of your user as the only namespace.`),j=m(),k=l("pre"),J=m(),D=l("p"),_e=a(`Interfaces can be namespaces as well.
Any instance of a concept that implements the namespace interface is a
namespace, but only the properties of the interface will be visible.`),K=m(),nt(E.$$.fragment),Q=m(),C=l("h2"),be=a("Namespace Additions"),V=m(),u=l("p"),Ee=a(`The standard namespaces can be added to. In that case, the visible elements from the addition are included.
By indicating an addition to a namespace you can, for instance, support inheritance. In the following example,
`),F=l("code"),we=a("baseEntity"),ke=a(" is in the language structure definition ("),M=l("code"),Te=a(".ast"),Ae=a(` file) defined to be the
super type of the `),R=l("code"),xe=a("Entity"),Le=a(" concept. The names visible in the "),Y=l("code"),$e=a("baseEntity"),Ie=a(`
are included in the namespace by defining the namespace-addition.`),W=m(),T=l("pre"),X=m(),P=l("h2"),De=a("Alternative Scopes"),Z=m(),w=l("p"),Ce=a(`You can also indicate that a different namespace altogether should be used. In the following example,
the elements visible in
an `),z=l("code"),Pe=a("AppliedFeature"),Se=a(" are determined based on the type of its container, i.e. the type of its parent in the AST."),ee=m(),A=l("pre"),this.h()},l(e){r=p(e,"H1",{});var s=c(r);f=o(s,"The Scoper Definition"),s.forEach(t),v=d(e),_=p(e,"P",{});var x=c(_);oe=o(x,"For now, the scoper definition does not support our "),L=p(x,"A",{href:!0});var Oe=c(L);ie=o(Oe,"three-level approach"),Oe.forEach(t),le=o(x,`.
You can manually code your own scoper on the 3rd level, but it is not possible to combine this with the
scopers on the 1st and 2nd levels.`),x.forEach(t),q=d(e),b=p(e,"P",{});var ne=c(b);pe=o(ne,`This tutorial
describes the possibilities of defining a scoper in the scoper definition file (with extension `),O=p(ne,"CODE",{});var He=c(O);ce=o(He,".scope"),He.forEach(t),re=o(ne,")."),ne.forEach(t),G=d(e),$=p(e,"P",{});var Ne=c($);fe=o(Ne,`In the scoper definition you provide the information necessary to determine which names are visible from a certain
element of your user\u2019s model.`),Ne.forEach(t),U=d(e),I=p(e,"H2",{});var Fe=c(I);ue=o(Fe,"Namespaces"),Fe.forEach(t),g=d(e),h=p(e,"P",{});var S=c(h);me=o(S,"In the scoper definition you can mark a list of concepts to be "),H=p(S,"STRONG",{});var Me=c(H);de=o(Me,"namespaces"),Me.forEach(t),he=o(S,". Any "),N=p(S,"EM",{});var Re=c(N);ye=o(Re,"namespace"),Re.forEach(t),ve=o(S,` has its own
set of visible names. Any namespace shadows the visible names from its surrounding namespace (using lexical scope).
The default scoper simply regards the model of your user as the only namespace.`),S.forEach(t),j=d(e),k=p(e,"PRE",{class:!0});var Ve=c(k);Ve.forEach(t),J=d(e),D=p(e,"P",{});var Ye=c(D);_e=o(Ye,`Interfaces can be namespaces as well.
Any instance of a concept that implements the namespace interface is a
namespace, but only the properties of the interface will be visible.`),Ye.forEach(t),K=d(e),st(E.$$.fragment,e),Q=d(e),C=p(e,"H2",{});var ze=c(C);be=o(ze,"Namespace Additions"),ze.forEach(t),V=d(e),u=p(e,"P",{});var y=c(u);Ee=o(y,`The standard namespaces can be added to. In that case, the visible elements from the addition are included.
By indicating an addition to a namespace you can, for instance, support inheritance. In the following example,
`),F=p(y,"CODE",{});var Be=c(F);we=o(Be,"baseEntity"),Be.forEach(t),ke=o(y," is in the language structure definition ("),M=p(y,"CODE",{});var qe=c(M);Te=o(qe,".ast"),qe.forEach(t),Ae=o(y,` file) defined to be the
super type of the `),R=p(y,"CODE",{});var Ge=c(R);xe=o(Ge,"Entity"),Ge.forEach(t),Le=o(y," concept. The names visible in the "),Y=p(y,"CODE",{});var Ue=c(Y);$e=o(Ue,"baseEntity"),Ue.forEach(t),Ie=o(y,`
are included in the namespace by defining the namespace-addition.`),y.forEach(t),W=d(e),T=p(e,"PRE",{class:!0});var We=c(T);We.forEach(t),X=d(e),P=p(e,"H2",{});var ge=c(P);De=o(ge,"Alternative Scopes"),ge.forEach(t),Z=d(e),w=p(e,"P",{});var se=c(w);Ce=o(se,`You can also indicate that a different namespace altogether should be used. In the following example,
the elements visible in
an `),z=p(se,"CODE",{});var je=c(z);Pe=o(je,"AppliedFeature"),je.forEach(t),Se=o(se," are determined based on the type of its container, i.e. the type of its parent in the AST."),se.forEach(t),ee=d(e),A=p(e,"PRE",{class:!0});var Xe=c(A);Xe.forEach(t),this.h()},h(){ae(L,"href","/010_Intro/050_Three_Levels_of_Customization"),ae(k,"class","language-ts"),ae(T,"class","language-ts"),ae(A,"class","language-ts")},m(e,s){i(e,r,s),n(r,f),i(e,v,s),i(e,_,s),n(_,oe),n(_,L),n(L,ie),n(_,le),i(e,q,s),i(e,b,s),n(b,pe),n(b,O),n(O,ce),n(b,re),i(e,G,s),i(e,$,s),n($,fe),i(e,U,s),i(e,I,s),n(I,ue),i(e,g,s),i(e,h,s),n(h,me),n(h,H),n(H,de),n(h,he),n(h,N),n(N,ye),n(h,ve),i(e,j,s),i(e,k,s),k.innerHTML=Je,i(e,J,s),i(e,D,s),n(D,_e),i(e,K,s),at(E,e,s),i(e,Q,s),i(e,C,s),n(C,be),i(e,V,s),i(e,u,s),n(u,Ee),n(u,F),n(F,we),n(u,ke),n(u,M),n(M,Te),n(u,Ae),n(u,R),n(R,xe),n(u,Le),n(u,Y),n(Y,$e),n(u,Ie),i(e,W,s),i(e,T,s),T.innerHTML=Ke,i(e,X,s),i(e,P,s),n(P,De),i(e,Z,s),i(e,w,s),n(w,Ce),n(w,z),n(z,Pe),n(w,Se),i(e,ee,s),i(e,A,s),A.innerHTML=Qe,te=!0},p(e,[s]){const x={};s&1&&(x.$$scope={dirty:s,ctx:e}),E.$set(x)},i(e){te||(ot(E.$$.fragment,e),te=!0)},o(e){it(E.$$.fragment,e),te=!1},d(e){e&&t(r),e&&t(v),e&&t(_),e&&t(q),e&&t(b),e&&t(G),e&&t($),e&&t(U),e&&t(I),e&&t(g),e&&t(h),e&&t(j),e&&t(k),e&&t(J),e&&t(D),e&&t(K),lt(E,e),e&&t(Q),e&&t(C),e&&t(V),e&&t(u),e&&t(W),e&&t(T),e&&t(X),e&&t(P),e&&t(Z),e&&t(w),e&&t(ee),e&&t(A)}}}class ht extends Ze{constructor(r){super();et(this,r,null,ft,tt,{})}}export{ht as default};
