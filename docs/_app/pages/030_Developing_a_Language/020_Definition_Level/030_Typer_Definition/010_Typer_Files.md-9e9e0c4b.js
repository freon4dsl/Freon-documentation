import{S as qo,i as Ho,s as Mo,e as l,t as s,k as i,w as qt,c as r,a as c,h as o,d as n,m as f,x as Ht,b as R,g as p,H as t,y as Mt,q as Gt,o as jt,B as Ft}from"../../../../chunks/vendor-492729b6.js";import{N as Wt}from"../../../../chunks/Note-1bdf01a3.js";/* empty css                                                            */function Go(S){let d;return{c(){d=s(`This is a valid inference rule, only if 'declaredType' is an instance 
of a concept that is marked 'isType'.`)},l(u){d=o(u,`This is a valid inference rule, only if 'declaredType' is an instance 
of a concept that is marked 'isType'.`)},m(u,v){p(u,d,v)},d(u){u&&n(d)}}}function jo(S){let d,u,v,y;return{c(){d=s("Be careful with the use of "),u=l("b"),v=s("conformsto"),y=s(` within where-clauses because this can lead to an 
explosion of newly created type concept instances.`)},l(h){d=o(h,"Be careful with the use of "),u=r(h,"B",{});var m=c(u);v=o(m,"conformsto"),m.forEach(n),y=o(h,` within where-clauses because this can lead to an 
explosion of newly created type concept instances.`)},m(h,m){p(h,d,m),p(h,u,m),t(u,v),p(h,y,m)},d(h){h&&n(d),h&&n(u),h&&n(y)}}}function Fo(S){let d,u,v,y;return{c(){d=s(`Type concept instances can not be compared based on their identity, 
instead you will need to use an `),u=l("i"),v=s("equalsto"),y=s(" entry.")},l(h){d=o(h,`Type concept instances can not be compared based on their identity, 
instead you will need to use an `),u=r(h,"I",{});var m=c(u);v=o(m,"equalsto"),m.forEach(n),y=o(h," entry.")},m(h,m){p(h,d,m),p(h,u,m),t(u,v),p(h,y,m)},d(h){h&&n(d),h&&n(u),h&&n(y)}}}function Wo(S){let d;return{c(){d=s("Anytype rules must be included after the 'hasType' rules and before the inference rules.")},l(u){d=o(u,"Anytype rules must be included after the 'hasType' rules and before the inference rules.")},m(u,v){p(u,d,v)},d(u){u&&n(d)}}}function Bo(S){let d,u,v,y,h,m,Bt,Yt,ye,Kt,Ut,me,gt,zt,Ze,E,A,Jt,ve,Qt,Vt,_e,Xt,Zt,en,D,tn,Te,nn,sn,Ee,on,an,ln,N,rn,we,cn,pn,ke,fn,un,dn,be,hn,et,x,yn,$e,mn,vn,tt,ee,_n,nt,_,Tn,Pe,En,wn,Ce,kn,bn,Le,$n,Pn,Ie,Cn,Ln,st,q,In,Oe,On,Sn,ot,g,ko=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L4-L4</span>

istype <span class="token punctuation">&#123;</span> NamedType <span class="token punctuation">&#125;</span></code>`,at,T,An,Se,Dn,Nn,Ae,Rn,xn,De,qn,Hn,Ne,Mn,Gn,lt,z,bo=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L6-L9</span>

<span class="token keyword">type</span> <span class="token class-name">GenericType</span> <span class="token punctuation">&#123;</span>
    base<span class="token operator">:</span> PiType<span class="token punctuation">;</span>
    kind<span class="token operator">:</span> GenericKind<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,rt,te,jn,ct,ne,Fn,pt,$,Wn,Re,Bn,Yn,se,xe,Kn,Un,it,H,gn,qe,zn,Jn,ft,J,$o=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L12-L12</span>

hastype <span class="token punctuation">&#123;</span> DocuExpression<span class="token punctuation">,</span> DocuType<span class="token punctuation">,</span> CalcFunction<span class="token punctuation">,</span> Parameter <span class="token punctuation">&#125;</span></code>`,ut,oe,Qn,dt,w,Vn,He,Xn,Zn,Me,es,ts,Ge,ns,ss,ht,Q,Po=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L18-L20</span>

CalcFunction <span class="token punctuation">&#123;</span>
    infertype self<span class="token punctuation">.</span>declaredType<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,yt,M,mt,P,os,je,as,ls,Fe,rs,cs,vt,G,ps,We,is,fs,_t,V,Co=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L27-L29</span>

RiskAdjustmentRef <span class="token punctuation">&#123;</span>
    infertype PercentageType<span class="token operator">:</span>Percentage<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Tt,ae,us,Et,C,ds,Be,hs,ys,Ye,ms,vs,wt,X,Lo=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L79-L86</span>

NamedType <span class="token punctuation">&#123;</span>
    equalsto aa<span class="token operator">:</span>NamedType where <span class="token punctuation">&#123;</span>
            aa<span class="token punctuation">.</span>name equalsto self<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    conformsto other<span class="token operator">:</span>NamedType where <span class="token punctuation">&#123;</span>
            other<span class="token punctuation">.</span>name equalsto self<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,kt,L,_s,Ke,Ts,Es,Ue,ws,ks,bt,k,bs,ge,$s,Ps,ze,Cs,Ls,le,Is,Os,$t,j,Pt,F,Ct,re,Ss,Lt,W,As,Je,Ds,Ns,It,Z,Io=`<code class="language-ts"><span class="token comment">// typer-example/defs/projectY.type#L21-L28</span>

    conformsto PredefinedType<span class="token operator">:</span><span class="token constant">ANY</span><span class="token punctuation">;</span> <span class="token comment">// PredefinedType:ANY is the least specific type</span>
<span class="token punctuation">&#125;</span>

PredefinedType <span class="token punctuation">&#123;</span>
    PredefinedType<span class="token operator">:</span><span class="token constant">NULL</span> conformsto anytype<span class="token punctuation">;</span> <span class="token comment">// PredefinedType:NULL is the most specific type</span>
    <span class="token class-name"><span class="token constant">NUMBER</span></span> conformsto <span class="token constant">STRING</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code>`,Ot,B,St;return M=new Wt({props:{$$slots:{content:[Go]},$$scope:{ctx:S}}}),j=new Wt({props:{$$slots:{content:[jo]},$$scope:{ctx:S}}}),F=new Wt({props:{$$slots:{content:[Fo]},$$scope:{ctx:S}}}),B=new Wt({props:{$$slots:{content:[Wo]},$$scope:{ctx:S}}}),{c(){d=l("h1"),u=s("The Typer Definition File"),v=i(),y=l("p"),h=s("In the typer definition file (with extension "),m=l("code"),Bt=s(".type"),Yt=s(`) you can indicate typing rules for every
`),ye=l("em"),Kt=s("concept"),Ut=s(" or "),me=l("em"),gt=s("interface"),zt=s(` in your language. The typing rules come in four categories. Each category
is there to answer one of the following questions.`),Ze=i(),E=l("ol"),A=l("li"),Jt=s("Which "),ve=l("em"),Qt=s("concepts"),Vt=s(" or "),_e=l("em"),Xt=s("interfaces"),Zt=s(" are considered to be types?"),en=i(),D=l("li"),tn=s("Which "),Te=l("em"),nn=s("concepts"),sn=s(" or "),Ee=l("em"),on=s("interfaces"),an=s(" are considered to have a type?"),ln=i(),N=l("li"),rn=s("How to determine the type of a "),we=l("em"),cn=s("concept"),pn=s(" or "),ke=l("em"),fn=s("interface"),un=s("?"),dn=i(),be=l("li"),hn=s("Which types are considered to be equal or conforming?"),et=i(),x=l("p"),yn=s("Note that (for now) these sections need to be in the "),$e=l("code"),mn=s(".type"),vn=s(" file in this order."),tt=i(),ee=l("h2"),_n=s("Types or Type Concepts"),nt=i(),_=l("p"),Tn=s("In ProjectIt all types are completely separate from the elements of your AST. These are called "),Pe=l("strong"),En=s("Type Concepts"),wn=s(`,
which all implements the interface `),Ce=l("strong"),kn=s("PiType"),bn=s(`. Type Concepts can be defined in two ways. Either they are defined
in the `),Le=l("code"),$n=s(".type"),Pn=s(" file, or some AST nodes are declared to be types. In the latter case, ProjectIt generates a "),Ie=l("code"),Cn=s("Type Concept"),Ln=s(`
which holds a reference to the AST node.`),st=i(),q=l("p"),In=s(`To indicate which AST concepts are considered to be types in your language,
the keyword `),Oe=l("code"),On=s("isType"),Sn=s(" is used, followed by all types in your language between curly brackets."),ot=i(),g=l("pre"),at=i(),T=l("p"),An=s(`To define new type concepts you can use a simplified version of the concept definition in the .ast files.
The properties may only be instances of other type concepts, or references to limited concepts. The property
`),Se=l("code"),Dn=s("base"),Nn=s(" in the next example is an instance of the interface "),Ae=l("code"),Rn=s("PiType"),xn=s(", whereas the property "),De=l("code"),qn=s("kind"),Hn=s(` refers to
the limited concept `),Ne=l("code"),Mn=s("GenericKind"),Gn=s("."),lt=i(),z=l("pre"),rt=i(),te=l("p"),jn=s(`Note that is it often good practise to have a common superclass or interface for all your types,
but this is not necessary.`),ct=i(),ne=l("h2"),Fn=s("Terms That Have a Type"),pt=i(),$=l("p"),Wn=s(`Not all AST nodes need to have a type associated to it. Only those nodes for which you
need a validation rule, or have another reason to require a type, need to be marked as
having a type. We refer to those AST nodes as `),Re=l("strong"),Bn=s("terms"),Yn=s(`, so as not to confuse these with
`),se=l("a"),xe=l("code"),Kn=s("expression concepts"),Un=s(`,
which have a different meaning.`),it=i(),H=l("p"),gn=s("You can indicate which AST nodes are terms by the keyword "),qe=l("code"),zn=s("hasType"),Jn=s(` followed by all terms in
your language between curly brackets.`),ft=i(),J=l("pre"),ut=i(),oe=l("h2"),Qn=s("Inference Rules"),dt=i(),w=l("p"),Vn=s("In order to determine the type of a term, there need to be a rule, called  an "),He=l("strong"),Xn=s("inference rule"),Zn=s(`,
for each concept or interface that is marked `),Me=l("code"),es=s("hasType"),ts=s(`. Each of these rules should result in a type concept.
The following example gives an inference rule that states that the type of calculation function is the
value of its attribute `),Ge=l("code"),ns=s("declaredType"),ss=s("."),ht=i(),Q=l("pre"),yt=i(),qt(M.$$.fragment),mt=i(),P=l("p"),os=s("Concepts that are types (as indicated by "),je=l("code"),as=s("isType"),ls=s(`) can also be terms. If an inference rule
is present, this rule will determine the type of such a term. If no rule is
present, the type of the AST node is the `),Fe=l("code"),rs=s("type concept"),cs=s(" generated for this AST node."),vt=i(),G=l("p"),ps=s(`In an inference rule, as in other definition files, it is possible to use
the predefined instances of a `),We=l("strong"),is=s("limited concept"),fs=s("."),_t=i(),V=l("pre"),Tt=i(),ae=l("h2"),us=s("Type Equals and Type Conformance Rules"),Et=i(),C=l("p"),ds=s(`The last section in the type definition is where rules are given that state which types
are considered equal or conforming. Each rule can have two entries: the `),Be=l("strong"),hs=s("conformsto"),ys=s(` and
the `),Ye=l("strong"),ms=s("equalsto"),vs=s(` entries. In these it is also possible to use the predefined
instances of a limited concept.`),wt=i(),X=l("pre"),kt=i(),L=l("p"),_s=s("The "),Ke=l("strong"),Ts=s("where-clause"),Es=s(` in the above example can be used when a type has some structure. For every property
in the type concept a condition is given. If all conditions evaluate to true then the `),Ue=l("code"),ws=s("where-clause"),ks=s(" results in true."),bt=i(),k=l("p"),bs=s("In a condition of a "),ge=l("code"),$s=s("where-clause"),Ps=s(" you may use "),ze=l("code"),Cs=s("conformsto"),Ls=s(`. In that case, invocation of the rule will produce the cartesian product of
all super concepts of the properties in the conditions. For an
example, see `),le=l("a"),Is=s("Typer Example"),Os=s("."),$t=i(),qt(j.$$.fragment),Pt=i(),qt(F.$$.fragment),Ct=i(),re=l("h2"),Ss=s("Rules That Apply to Any Concept"),Lt=i(),W=l("p"),As=s("Conformance and other rules can also be defined to apply to "),Je=l("strong"),Ds=s("any"),Ns=s(` concept. Obviously, this means that
any instance of any concept conforms to the given value.`),It=i(),Z=l("pre"),Ot=i(),qt(B.$$.fragment),this.h()},l(e){d=r(e,"H1",{});var a=c(d);u=o(a,"The Typer Definition File"),a.forEach(n),v=f(e),y=r(e,"P",{});var b=c(y);h=o(b,"In the typer definition file (with extension "),m=r(b,"CODE",{});var Qe=c(m);Bt=o(Qe,".type"),Qe.forEach(n),Yt=o(b,`) you can indicate typing rules for every
`),ye=r(b,"EM",{});var Ve=c(ye);Kt=o(Ve,"concept"),Ve.forEach(n),Ut=o(b," or "),me=r(b,"EM",{});var Xe=c(me);gt=o(Xe,"interface"),Xe.forEach(n),zt=o(b,` in your language. The typing rules come in four categories. Each category
is there to answer one of the following questions.`),b.forEach(n),Ze=f(e),E=r(e,"OL",{});var Y=c(E);A=r(Y,"LI",{});var ce=c(A);Jt=o(ce,"Which "),ve=r(ce,"EM",{});var Rs=c(ve);Qt=o(Rs,"concepts"),Rs.forEach(n),Vt=o(ce," or "),_e=r(ce,"EM",{});var xs=c(_e);Xt=o(xs,"interfaces"),xs.forEach(n),Zt=o(ce," are considered to be types?"),ce.forEach(n),en=f(Y),D=r(Y,"LI",{});var pe=c(D);tn=o(pe,"Which "),Te=r(pe,"EM",{});var qs=c(Te);nn=o(qs,"concepts"),qs.forEach(n),sn=o(pe," or "),Ee=r(pe,"EM",{});var Hs=c(Ee);on=o(Hs,"interfaces"),Hs.forEach(n),an=o(pe," are considered to have a type?"),pe.forEach(n),ln=f(Y),N=r(Y,"LI",{});var ie=c(N);rn=o(ie,"How to determine the type of a "),we=r(ie,"EM",{});var Ms=c(we);cn=o(Ms,"concept"),Ms.forEach(n),pn=o(ie," or "),ke=r(ie,"EM",{});var Gs=c(ke);fn=o(Gs,"interface"),Gs.forEach(n),un=o(ie,"?"),ie.forEach(n),dn=f(Y),be=r(Y,"LI",{});var js=c(be);hn=o(js,"Which types are considered to be equal or conforming?"),js.forEach(n),Y.forEach(n),et=f(e),x=r(e,"P",{});var At=c(x);yn=o(At,"Note that (for now) these sections need to be in the "),$e=r(At,"CODE",{});var Fs=c($e);mn=o(Fs,".type"),Fs.forEach(n),vn=o(At," file in this order."),At.forEach(n),tt=f(e),ee=r(e,"H2",{});var Ws=c(ee);_n=o(Ws,"Types or Type Concepts"),Ws.forEach(n),nt=f(e),_=r(e,"P",{});var I=c(_);Tn=o(I,"In ProjectIt all types are completely separate from the elements of your AST. These are called "),Pe=r(I,"STRONG",{});var Bs=c(Pe);En=o(Bs,"Type Concepts"),Bs.forEach(n),wn=o(I,`,
which all implements the interface `),Ce=r(I,"STRONG",{});var Ys=c(Ce);kn=o(Ys,"PiType"),Ys.forEach(n),bn=o(I,`. Type Concepts can be defined in two ways. Either they are defined
in the `),Le=r(I,"CODE",{});var Ks=c(Le);$n=o(Ks,".type"),Ks.forEach(n),Pn=o(I," file, or some AST nodes are declared to be types. In the latter case, ProjectIt generates a "),Ie=r(I,"CODE",{});var Us=c(Ie);Cn=o(Us,"Type Concept"),Us.forEach(n),Ln=o(I,`
which holds a reference to the AST node.`),I.forEach(n),st=f(e),q=r(e,"P",{});var Dt=c(q);In=o(Dt,`To indicate which AST concepts are considered to be types in your language,
the keyword `),Oe=r(Dt,"CODE",{});var gs=c(Oe);On=o(gs,"isType"),gs.forEach(n),Sn=o(Dt," is used, followed by all types in your language between curly brackets."),Dt.forEach(n),ot=f(e),g=r(e,"PRE",{class:!0});var Oo=c(g);Oo.forEach(n),at=f(e),T=r(e,"P",{});var O=c(T);An=o(O,`To define new type concepts you can use a simplified version of the concept definition in the .ast files.
The properties may only be instances of other type concepts, or references to limited concepts. The property
`),Se=r(O,"CODE",{});var zs=c(Se);Dn=o(zs,"base"),zs.forEach(n),Nn=o(O," in the next example is an instance of the interface "),Ae=r(O,"CODE",{});var Js=c(Ae);Rn=o(Js,"PiType"),Js.forEach(n),xn=o(O,", whereas the property "),De=r(O,"CODE",{});var Qs=c(De);qn=o(Qs,"kind"),Qs.forEach(n),Hn=o(O,` refers to
the limited concept `),Ne=r(O,"CODE",{});var Vs=c(Ne);Mn=o(Vs,"GenericKind"),Vs.forEach(n),Gn=o(O,"."),O.forEach(n),lt=f(e),z=r(e,"PRE",{class:!0});var So=c(z);So.forEach(n),rt=f(e),te=r(e,"P",{});var Xs=c(te);jn=o(Xs,`Note that is it often good practise to have a common superclass or interface for all your types,
but this is not necessary.`),Xs.forEach(n),ct=f(e),ne=r(e,"H2",{});var Zs=c(ne);Fn=o(Zs,"Terms That Have a Type"),Zs.forEach(n),pt=f(e),$=r(e,"P",{});var fe=c($);Wn=o(fe,`Not all AST nodes need to have a type associated to it. Only those nodes for which you
need a validation rule, or have another reason to require a type, need to be marked as
having a type. We refer to those AST nodes as `),Re=r(fe,"STRONG",{});var eo=c(Re);Bn=o(eo,"terms"),eo.forEach(n),Yn=o(fe,`, so as not to confuse these with
`),se=r(fe,"A",{href:!0});var to=c(se);xe=r(to,"CODE",{});var no=c(xe);Kn=o(no,"expression concepts"),no.forEach(n),to.forEach(n),Un=o(fe,`,
which have a different meaning.`),fe.forEach(n),it=f(e),H=r(e,"P",{});var Nt=c(H);gn=o(Nt,"You can indicate which AST nodes are terms by the keyword "),qe=r(Nt,"CODE",{});var so=c(qe);zn=o(so,"hasType"),so.forEach(n),Jn=o(Nt,` followed by all terms in
your language between curly brackets.`),Nt.forEach(n),ft=f(e),J=r(e,"PRE",{class:!0});var Ao=c(J);Ao.forEach(n),ut=f(e),oe=r(e,"H2",{});var oo=c(oe);Qn=o(oo,"Inference Rules"),oo.forEach(n),dt=f(e),w=r(e,"P",{});var K=c(w);Vn=o(K,"In order to determine the type of a term, there need to be a rule, called  an "),He=r(K,"STRONG",{});var ao=c(He);Xn=o(ao,"inference rule"),ao.forEach(n),Zn=o(K,`,
for each concept or interface that is marked `),Me=r(K,"CODE",{});var lo=c(Me);es=o(lo,"hasType"),lo.forEach(n),ts=o(K,`. Each of these rules should result in a type concept.
The following example gives an inference rule that states that the type of calculation function is the
value of its attribute `),Ge=r(K,"CODE",{});var ro=c(Ge);ns=o(ro,"declaredType"),ro.forEach(n),ss=o(K,"."),K.forEach(n),ht=f(e),Q=r(e,"PRE",{class:!0});var Do=c(Q);Do.forEach(n),yt=f(e),Ht(M.$$.fragment,e),mt=f(e),P=r(e,"P",{});var ue=c(P);os=o(ue,"Concepts that are types (as indicated by "),je=r(ue,"CODE",{});var co=c(je);as=o(co,"isType"),co.forEach(n),ls=o(ue,`) can also be terms. If an inference rule
is present, this rule will determine the type of such a term. If no rule is
present, the type of the AST node is the `),Fe=r(ue,"CODE",{});var po=c(Fe);rs=o(po,"type concept"),po.forEach(n),cs=o(ue," generated for this AST node."),ue.forEach(n),vt=f(e),G=r(e,"P",{});var Rt=c(G);ps=o(Rt,`In an inference rule, as in other definition files, it is possible to use
the predefined instances of a `),We=r(Rt,"STRONG",{});var io=c(We);is=o(io,"limited concept"),io.forEach(n),fs=o(Rt,"."),Rt.forEach(n),_t=f(e),V=r(e,"PRE",{class:!0});var No=c(V);No.forEach(n),Tt=f(e),ae=r(e,"H2",{});var fo=c(ae);us=o(fo,"Type Equals and Type Conformance Rules"),fo.forEach(n),Et=f(e),C=r(e,"P",{});var de=c(C);ds=o(de,`The last section in the type definition is where rules are given that state which types
are considered equal or conforming. Each rule can have two entries: the `),Be=r(de,"STRONG",{});var uo=c(Be);hs=o(uo,"conformsto"),uo.forEach(n),ys=o(de,` and
the `),Ye=r(de,"STRONG",{});var ho=c(Ye);ms=o(ho,"equalsto"),ho.forEach(n),vs=o(de,` entries. In these it is also possible to use the predefined
instances of a limited concept.`),de.forEach(n),wt=f(e),X=r(e,"PRE",{class:!0});var Ro=c(X);Ro.forEach(n),kt=f(e),L=r(e,"P",{});var he=c(L);_s=o(he,"The "),Ke=r(he,"STRONG",{});var yo=c(Ke);Ts=o(yo,"where-clause"),yo.forEach(n),Es=o(he,` in the above example can be used when a type has some structure. For every property
in the type concept a condition is given. If all conditions evaluate to true then the `),Ue=r(he,"CODE",{});var mo=c(Ue);ws=o(mo,"where-clause"),mo.forEach(n),ks=o(he," results in true."),he.forEach(n),bt=f(e),k=r(e,"P",{});var U=c(k);bs=o(U,"In a condition of a "),ge=r(U,"CODE",{});var vo=c(ge);$s=o(vo,"where-clause"),vo.forEach(n),Ps=o(U," you may use "),ze=r(U,"CODE",{});var _o=c(ze);Cs=o(_o,"conformsto"),_o.forEach(n),Ls=o(U,`. In that case, invocation of the rule will produce the cartesian product of
all super concepts of the properties in the conditions. For an
example, see `),le=r(U,"A",{href:!0});var To=c(le);Is=o(To,"Typer Example"),To.forEach(n),Os=o(U,"."),U.forEach(n),$t=f(e),Ht(j.$$.fragment,e),Pt=f(e),Ht(F.$$.fragment,e),Ct=f(e),re=r(e,"H2",{});var Eo=c(re);Ss=o(Eo,"Rules That Apply to Any Concept"),Eo.forEach(n),Lt=f(e),W=r(e,"P",{});var xt=c(W);As=o(xt,"Conformance and other rules can also be defined to apply to "),Je=r(xt,"STRONG",{});var wo=c(Je);Ds=o(wo,"any"),wo.forEach(n),Ns=o(xt,` concept. Obviously, this means that
any instance of any concept conforms to the given value.`),xt.forEach(n),It=f(e),Z=r(e,"PRE",{class:!0});var xo=c(Z);xo.forEach(n),Ot=f(e),Ht(B.$$.fragment,e),this.h()},h(){R(g,"class","language-ts"),R(z,"class","language-ts"),R(se,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure"),R(J,"class","language-ts"),R(Q,"class","language-ts"),R(V,"class","language-ts"),R(X,"class","language-ts"),R(le,"href","/030_Developing_a_Language/020_Definition_Level/030_Typer_Definition/030_Example_Typer_Definition"),R(Z,"class","language-ts")},m(e,a){p(e,d,a),t(d,u),p(e,v,a),p(e,y,a),t(y,h),t(y,m),t(m,Bt),t(y,Yt),t(y,ye),t(ye,Kt),t(y,Ut),t(y,me),t(me,gt),t(y,zt),p(e,Ze,a),p(e,E,a),t(E,A),t(A,Jt),t(A,ve),t(ve,Qt),t(A,Vt),t(A,_e),t(_e,Xt),t(A,Zt),t(E,en),t(E,D),t(D,tn),t(D,Te),t(Te,nn),t(D,sn),t(D,Ee),t(Ee,on),t(D,an),t(E,ln),t(E,N),t(N,rn),t(N,we),t(we,cn),t(N,pn),t(N,ke),t(ke,fn),t(N,un),t(E,dn),t(E,be),t(be,hn),p(e,et,a),p(e,x,a),t(x,yn),t(x,$e),t($e,mn),t(x,vn),p(e,tt,a),p(e,ee,a),t(ee,_n),p(e,nt,a),p(e,_,a),t(_,Tn),t(_,Pe),t(Pe,En),t(_,wn),t(_,Ce),t(Ce,kn),t(_,bn),t(_,Le),t(Le,$n),t(_,Pn),t(_,Ie),t(Ie,Cn),t(_,Ln),p(e,st,a),p(e,q,a),t(q,In),t(q,Oe),t(Oe,On),t(q,Sn),p(e,ot,a),p(e,g,a),g.innerHTML=ko,p(e,at,a),p(e,T,a),t(T,An),t(T,Se),t(Se,Dn),t(T,Nn),t(T,Ae),t(Ae,Rn),t(T,xn),t(T,De),t(De,qn),t(T,Hn),t(T,Ne),t(Ne,Mn),t(T,Gn),p(e,lt,a),p(e,z,a),z.innerHTML=bo,p(e,rt,a),p(e,te,a),t(te,jn),p(e,ct,a),p(e,ne,a),t(ne,Fn),p(e,pt,a),p(e,$,a),t($,Wn),t($,Re),t(Re,Bn),t($,Yn),t($,se),t(se,xe),t(xe,Kn),t($,Un),p(e,it,a),p(e,H,a),t(H,gn),t(H,qe),t(qe,zn),t(H,Jn),p(e,ft,a),p(e,J,a),J.innerHTML=$o,p(e,ut,a),p(e,oe,a),t(oe,Qn),p(e,dt,a),p(e,w,a),t(w,Vn),t(w,He),t(He,Xn),t(w,Zn),t(w,Me),t(Me,es),t(w,ts),t(w,Ge),t(Ge,ns),t(w,ss),p(e,ht,a),p(e,Q,a),Q.innerHTML=Po,p(e,yt,a),Mt(M,e,a),p(e,mt,a),p(e,P,a),t(P,os),t(P,je),t(je,as),t(P,ls),t(P,Fe),t(Fe,rs),t(P,cs),p(e,vt,a),p(e,G,a),t(G,ps),t(G,We),t(We,is),t(G,fs),p(e,_t,a),p(e,V,a),V.innerHTML=Co,p(e,Tt,a),p(e,ae,a),t(ae,us),p(e,Et,a),p(e,C,a),t(C,ds),t(C,Be),t(Be,hs),t(C,ys),t(C,Ye),t(Ye,ms),t(C,vs),p(e,wt,a),p(e,X,a),X.innerHTML=Lo,p(e,kt,a),p(e,L,a),t(L,_s),t(L,Ke),t(Ke,Ts),t(L,Es),t(L,Ue),t(Ue,ws),t(L,ks),p(e,bt,a),p(e,k,a),t(k,bs),t(k,ge),t(ge,$s),t(k,Ps),t(k,ze),t(ze,Cs),t(k,Ls),t(k,le),t(le,Is),t(k,Os),p(e,$t,a),Mt(j,e,a),p(e,Pt,a),Mt(F,e,a),p(e,Ct,a),p(e,re,a),t(re,Ss),p(e,Lt,a),p(e,W,a),t(W,As),t(W,Je),t(Je,Ds),t(W,Ns),p(e,It,a),p(e,Z,a),Z.innerHTML=Io,p(e,Ot,a),Mt(B,e,a),St=!0},p(e,[a]){const b={};a&1&&(b.$$scope={dirty:a,ctx:e}),M.$set(b);const Qe={};a&1&&(Qe.$$scope={dirty:a,ctx:e}),j.$set(Qe);const Ve={};a&1&&(Ve.$$scope={dirty:a,ctx:e}),F.$set(Ve);const Xe={};a&1&&(Xe.$$scope={dirty:a,ctx:e}),B.$set(Xe)},i(e){St||(Gt(M.$$.fragment,e),Gt(j.$$.fragment,e),Gt(F.$$.fragment,e),Gt(B.$$.fragment,e),St=!0)},o(e){jt(M.$$.fragment,e),jt(j.$$.fragment,e),jt(F.$$.fragment,e),jt(B.$$.fragment,e),St=!1},d(e){e&&n(d),e&&n(v),e&&n(y),e&&n(Ze),e&&n(E),e&&n(et),e&&n(x),e&&n(tt),e&&n(ee),e&&n(nt),e&&n(_),e&&n(st),e&&n(q),e&&n(ot),e&&n(g),e&&n(at),e&&n(T),e&&n(lt),e&&n(z),e&&n(rt),e&&n(te),e&&n(ct),e&&n(ne),e&&n(pt),e&&n($),e&&n(it),e&&n(H),e&&n(ft),e&&n(J),e&&n(ut),e&&n(oe),e&&n(dt),e&&n(w),e&&n(ht),e&&n(Q),e&&n(yt),Ft(M,e),e&&n(mt),e&&n(P),e&&n(vt),e&&n(G),e&&n(_t),e&&n(V),e&&n(Tt),e&&n(ae),e&&n(Et),e&&n(C),e&&n(wt),e&&n(X),e&&n(kt),e&&n(L),e&&n(bt),e&&n(k),e&&n($t),Ft(j,e),e&&n(Pt),Ft(F,e),e&&n(Ct),e&&n(re),e&&n(Lt),e&&n(W),e&&n(It),e&&n(Z),e&&n(Ot),Ft(B,e)}}}class go extends qo{constructor(d){super();Ho(this,d,null,Bo,Mo,{})}}export{go as default};
