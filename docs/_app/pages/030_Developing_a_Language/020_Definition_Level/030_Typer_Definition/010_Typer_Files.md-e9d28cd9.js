import{S as qo,i as Ho,s as Mo,e as l,t as s,k as i,w as qt,c as r,a as p,h as o,d as n,m as f,x as Ht,b as R,g as c,H as t,y as Mt,q as Gt,o as Ft,B as jt}from"../../../../chunks/vendor-0dc77bd0.js";import{N as Wt}from"../../../../chunks/Note-b0db7989.js";/* empty css                                                            */function Go(I){let d;return{c(){d=s(`This is a valid inference rule, only if 'declaredType' is an instance 
of a concept that is marked 'isType'.`)},l(u){d=o(u,`This is a valid inference rule, only if 'declaredType' is an instance 
of a concept that is marked 'isType'.`)},m(u,v){c(u,d,v)},d(u){u&&n(d)}}}function Fo(I){let d,u,v,y;return{c(){d=s("Be careful with the use of "),u=l("b"),v=s("conformsto"),y=s(` within where-clauses because this can lead to an 
explosion of newly created type concept instances.`)},l(h){d=o(h,"Be careful with the use of "),u=r(h,"B",{});var m=p(u);v=o(m,"conformsto"),m.forEach(n),y=o(h,` within where-clauses because this can lead to an 
explosion of newly created type concept instances.`)},m(h,m){c(h,d,m),c(h,u,m),t(u,v),c(h,y,m)},d(h){h&&n(d),h&&n(u),h&&n(y)}}}function jo(I){let d,u,v,y;return{c(){d=s(`Type concept instances can not be compared based on their identity, 
instead you will need to use an `),u=l("i"),v=s("equalsto"),y=s(" entry.")},l(h){d=o(h,`Type concept instances can not be compared based on their identity, 
instead you will need to use an `),u=r(h,"I",{});var m=p(u);v=o(m,"equalsto"),m.forEach(n),y=o(h," entry.")},m(h,m){c(h,d,m),c(h,u,m),t(u,v),c(h,y,m)},d(h){h&&n(d),h&&n(u),h&&n(y)}}}function Wo(I){let d;return{c(){d=s("Anytype rules must be included after the 'hasType' rules and before the inference rules.")},l(u){d=o(u,"Anytype rules must be included after the 'hasType' rules and before the inference rules.")},m(u,v){c(u,d,v)},d(u){u&&n(d)}}}function Bo(I){let d,u,v,y,h,m,Bt,Yt,ye,Kt,Ut,me,gt,zt,Ze,E,A,Jt,ve,Qt,Vt,_e,Xt,Zt,en,D,tn,Te,nn,sn,Ee,on,an,ln,N,rn,we,pn,cn,ke,fn,un,dn,be,hn,et,x,yn,$e,mn,vn,tt,ee,_n,nt,_,Tn,Ce,En,wn,Le,kn,bn,Pe,$n,Cn,Oe,Ln,Pn,st,q,On,Se,Sn,In,ot,g,ko=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L4-L4</span>

istype <span class="token punctuation">&#123;</span> NamedType <span class="token punctuation">&#125;</span></code>`,at,T,An,Ie,Dn,Nn,Ae,Rn,xn,De,qn,Hn,Ne,Mn,Gn,lt,z,bo=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L6-L9</span>

<span class="token keyword">type</span> <span class="token class-name">GenericType</span> <span class="token punctuation">&#123;</span>
    base<span class="token operator">:</span> PiType<span class="token punctuation">;</span>
    kind<span class="token operator">:</span> GenericKind<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,rt,te,Fn,pt,ne,jn,ct,$,Wn,Re,Bn,Yn,se,xe,Kn,Un,it,H,gn,qe,zn,Jn,ft,J,$o=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L12-L12</span>

hastype <span class="token punctuation">&#123;</span> DocuExpression<span class="token punctuation">,</span> DocuType<span class="token punctuation">,</span> CalcFunction<span class="token punctuation">,</span> Parameter <span class="token punctuation">&#125;</span></code>`,ut,oe,Qn,dt,w,Vn,He,Xn,Zn,Me,es,ts,Ge,ns,ss,ht,Q,Co=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L18-L20</span>

CalcFunction <span class="token punctuation">&#123;</span>
    infertype self<span class="token punctuation">.</span>declaredType<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,yt,M,mt,C,os,Fe,as,ls,je,rs,ps,vt,G,cs,We,is,fs,_t,V,Lo=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L27-L29</span>

RiskAdjustmentRef <span class="token punctuation">&#123;</span>
    infertype PercentageType<span class="token operator">:</span>Percentage<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Tt,ae,us,Et,L,ds,Be,hs,ys,Ye,ms,vs,wt,X,Po=`<code class="language-ts"><span class="token comment">// docu-project/defs/typer-docu.type#L79-L86</span>

NamedType <span class="token punctuation">&#123;</span>
    equalsto aa<span class="token operator">:</span>NamedType where <span class="token punctuation">&#123;</span>
            aa<span class="token punctuation">.</span>name equalsto self<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    conformsto other<span class="token operator">:</span>NamedType where <span class="token punctuation">&#123;</span>
            other<span class="token punctuation">.</span>name equalsto self<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,kt,P,_s,Ke,Ts,Es,Ue,ws,ks,bt,k,bs,ge,$s,Cs,ze,Ls,Ps,le,Os,Ss,$t,F,Ct,j,Lt,re,Is,Pt,W,As,Je,Ds,Ns,Ot,Z,Oo=`<code class="language-ts"><span class="token comment">// typer-example/defs/projectY.type#L21-L28</span>

    conformsto PredefinedType<span class="token operator">:</span><span class="token constant">ANY</span><span class="token punctuation">;</span> <span class="token comment">// PredefinedType:ANY is the least specific type</span>
<span class="token punctuation">&#125;</span>

PredefinedType <span class="token punctuation">&#123;</span>
    PredefinedType<span class="token operator">:</span><span class="token constant">NULL</span> conformsto anytype<span class="token punctuation">;</span> <span class="token comment">// PredefinedType:NULL is the most specific type</span>
    <span class="token class-name"><span class="token constant">NUMBER</span></span> conformsto <span class="token constant">STRING</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code>`,St,B,It;return M=new Wt({props:{$$slots:{content:[Go]},$$scope:{ctx:I}}}),F=new Wt({props:{$$slots:{content:[Fo]},$$scope:{ctx:I}}}),j=new Wt({props:{$$slots:{content:[jo]},$$scope:{ctx:I}}}),B=new Wt({props:{$$slots:{content:[Wo]},$$scope:{ctx:I}}}),{c(){d=l("h1"),u=s("The Typer Definition File"),v=i(),y=l("p"),h=s("In the typer definition file (with extension "),m=l("code"),Bt=s(".type"),Yt=s(`) you can indicate typing rules for every
`),ye=l("em"),Kt=s("concept"),Ut=s(" or "),me=l("em"),gt=s("interface"),zt=s(` in your language. The typing rules come in four categories. Each category
is there to answer one of the following questions.`),Ze=i(),E=l("ol"),A=l("li"),Jt=s("Which "),ve=l("em"),Qt=s("concepts"),Vt=s(" or "),_e=l("em"),Xt=s("interfaces"),Zt=s(" are considered to be types?"),en=i(),D=l("li"),tn=s("Which "),Te=l("em"),nn=s("concepts"),sn=s(" or "),Ee=l("em"),on=s("interfaces"),an=s(" are considered to have a type?"),ln=i(),N=l("li"),rn=s("How to determine the type of a "),we=l("em"),pn=s("concept"),cn=s(" or "),ke=l("em"),fn=s("interface"),un=s("?"),dn=i(),be=l("li"),hn=s("Which types are considered to be equal or conforming?"),et=i(),x=l("p"),yn=s("Note that (for now) these sections need to be in the "),$e=l("code"),mn=s(".type"),vn=s(" file in this order."),tt=i(),ee=l("h2"),_n=s("Types or Type Concepts"),nt=i(),_=l("p"),Tn=s("In Freon all types are completely separate from the elements of your AST. These are called "),Ce=l("strong"),En=s("Type Concepts"),wn=s(`,
which all implements the interface `),Le=l("strong"),kn=s("PiType"),bn=s(`. Type Concepts can be defined in two ways. Either they are defined
in the `),Pe=l("code"),$n=s(".type"),Cn=s(" file, or some AST nodes are declared to be types. In the latter case, Freon generates a "),Oe=l("code"),Ln=s("Type Concept"),Pn=s(`
which holds a reference to the AST node.`),st=i(),q=l("p"),On=s(`To indicate which AST concepts are considered to be types in your language,
the keyword `),Se=l("code"),Sn=s("isType"),In=s(" is used, followed by all types in your language between curly brackets."),ot=i(),g=l("pre"),at=i(),T=l("p"),An=s(`To define new type concepts you can use a simplified version of the concept definition in the .ast files.
The properties may only be instances of other type concepts, or references to limited concepts. The property
`),Ie=l("code"),Dn=s("base"),Nn=s(" in the next example is an instance of the interface "),Ae=l("code"),Rn=s("PiType"),xn=s(", whereas the property "),De=l("code"),qn=s("kind"),Hn=s(` refers to
the limited concept `),Ne=l("code"),Mn=s("GenericKind"),Gn=s("."),lt=i(),z=l("pre"),rt=i(),te=l("p"),Fn=s(`Note that is it often good practise to have a common superclass or interface for all your types,
but this is not necessary.`),pt=i(),ne=l("h2"),jn=s("Terms That Have a Type"),ct=i(),$=l("p"),Wn=s(`Not all AST nodes need to have a type associated to it. Only those nodes for which you
need a validation rule, or have another reason to require a type, need to be marked as
having a type. We refer to those AST nodes as `),Re=l("strong"),Bn=s("terms"),Yn=s(`, so as not to confuse these with
`),se=l("a"),xe=l("code"),Kn=s("expression concepts"),Un=s(`,
which have a different meaning.`),it=i(),H=l("p"),gn=s("You can indicate which AST nodes are terms by the keyword "),qe=l("code"),zn=s("hasType"),Jn=s(` followed by all terms in
your language between curly brackets.`),ft=i(),J=l("pre"),ut=i(),oe=l("h2"),Qn=s("Inference Rules"),dt=i(),w=l("p"),Vn=s("In order to determine the type of a term, there need to be a rule, called  an "),He=l("strong"),Xn=s("inference rule"),Zn=s(`,
for each concept or interface that is marked `),Me=l("code"),es=s("hasType"),ts=s(`. Each of these rules should result in a type concept.
The following example gives an inference rule that states that the type of calculation function is the
value of its attribute `),Ge=l("code"),ns=s("declaredType"),ss=s("."),ht=i(),Q=l("pre"),yt=i(),qt(M.$$.fragment),mt=i(),C=l("p"),os=s("Concepts that are types (as indicated by "),Fe=l("code"),as=s("isType"),ls=s(`) can also be terms. If an inference rule
is present, this rule will determine the type of such a term. If no rule is
present, the type of the AST node is the `),je=l("code"),rs=s("type concept"),ps=s(" generated for this AST node."),vt=i(),G=l("p"),cs=s(`In an inference rule, as in other definition files, it is possible to use
the predefined instances of a `),We=l("strong"),is=s("limited concept"),fs=s("."),_t=i(),V=l("pre"),Tt=i(),ae=l("h2"),us=s("Type Equals and Type Conformance Rules"),Et=i(),L=l("p"),ds=s(`The last section in the type definition is where rules are given that state which types
are considered equal or conforming. Each rule can have two entries: the `),Be=l("strong"),hs=s("conformsto"),ys=s(` and
the `),Ye=l("strong"),ms=s("equalsto"),vs=s(` entries. In these it is also possible to use the predefined
instances of a limited concept.`),wt=i(),X=l("pre"),kt=i(),P=l("p"),_s=s("The "),Ke=l("strong"),Ts=s("where-clause"),Es=s(` in the above example can be used when a type has some structure. For every property
in the type concept a condition is given. If all conditions evaluate to true then the `),Ue=l("code"),ws=s("where-clause"),ks=s(" results in true."),bt=i(),k=l("p"),bs=s("In a condition of a "),ge=l("code"),$s=s("where-clause"),Cs=s(" you may use "),ze=l("code"),Ls=s("conformsto"),Ps=s(`. In that case, invocation of the rule will produce the cartesian product of
all super concepts of the properties in the conditions. For an
example, see `),le=l("a"),Os=s("Typer Example"),Ss=s("."),$t=i(),qt(F.$$.fragment),Ct=i(),qt(j.$$.fragment),Lt=i(),re=l("h2"),Is=s("Rules That Apply to Any Concept"),Pt=i(),W=l("p"),As=s("Conformance and other rules can also be defined to apply to "),Je=l("strong"),Ds=s("any"),Ns=s(` concept. Obviously, this means that
any instance of any concept conforms to the given value.`),Ot=i(),Z=l("pre"),St=i(),qt(B.$$.fragment),this.h()},l(e){d=r(e,"H1",{});var a=p(d);u=o(a,"The Typer Definition File"),a.forEach(n),v=f(e),y=r(e,"P",{});var b=p(y);h=o(b,"In the typer definition file (with extension "),m=r(b,"CODE",{});var Qe=p(m);Bt=o(Qe,".type"),Qe.forEach(n),Yt=o(b,`) you can indicate typing rules for every
`),ye=r(b,"EM",{});var Ve=p(ye);Kt=o(Ve,"concept"),Ve.forEach(n),Ut=o(b," or "),me=r(b,"EM",{});var Xe=p(me);gt=o(Xe,"interface"),Xe.forEach(n),zt=o(b,` in your language. The typing rules come in four categories. Each category
is there to answer one of the following questions.`),b.forEach(n),Ze=f(e),E=r(e,"OL",{});var Y=p(E);A=r(Y,"LI",{});var pe=p(A);Jt=o(pe,"Which "),ve=r(pe,"EM",{});var Rs=p(ve);Qt=o(Rs,"concepts"),Rs.forEach(n),Vt=o(pe," or "),_e=r(pe,"EM",{});var xs=p(_e);Xt=o(xs,"interfaces"),xs.forEach(n),Zt=o(pe," are considered to be types?"),pe.forEach(n),en=f(Y),D=r(Y,"LI",{});var ce=p(D);tn=o(ce,"Which "),Te=r(ce,"EM",{});var qs=p(Te);nn=o(qs,"concepts"),qs.forEach(n),sn=o(ce," or "),Ee=r(ce,"EM",{});var Hs=p(Ee);on=o(Hs,"interfaces"),Hs.forEach(n),an=o(ce," are considered to have a type?"),ce.forEach(n),ln=f(Y),N=r(Y,"LI",{});var ie=p(N);rn=o(ie,"How to determine the type of a "),we=r(ie,"EM",{});var Ms=p(we);pn=o(Ms,"concept"),Ms.forEach(n),cn=o(ie," or "),ke=r(ie,"EM",{});var Gs=p(ke);fn=o(Gs,"interface"),Gs.forEach(n),un=o(ie,"?"),ie.forEach(n),dn=f(Y),be=r(Y,"LI",{});var Fs=p(be);hn=o(Fs,"Which types are considered to be equal or conforming?"),Fs.forEach(n),Y.forEach(n),et=f(e),x=r(e,"P",{});var At=p(x);yn=o(At,"Note that (for now) these sections need to be in the "),$e=r(At,"CODE",{});var js=p($e);mn=o(js,".type"),js.forEach(n),vn=o(At," file in this order."),At.forEach(n),tt=f(e),ee=r(e,"H2",{});var Ws=p(ee);_n=o(Ws,"Types or Type Concepts"),Ws.forEach(n),nt=f(e),_=r(e,"P",{});var O=p(_);Tn=o(O,"In Freon all types are completely separate from the elements of your AST. These are called "),Ce=r(O,"STRONG",{});var Bs=p(Ce);En=o(Bs,"Type Concepts"),Bs.forEach(n),wn=o(O,`,
which all implements the interface `),Le=r(O,"STRONG",{});var Ys=p(Le);kn=o(Ys,"PiType"),Ys.forEach(n),bn=o(O,`. Type Concepts can be defined in two ways. Either they are defined
in the `),Pe=r(O,"CODE",{});var Ks=p(Pe);$n=o(Ks,".type"),Ks.forEach(n),Cn=o(O," file, or some AST nodes are declared to be types. In the latter case, Freon generates a "),Oe=r(O,"CODE",{});var Us=p(Oe);Ln=o(Us,"Type Concept"),Us.forEach(n),Pn=o(O,`
which holds a reference to the AST node.`),O.forEach(n),st=f(e),q=r(e,"P",{});var Dt=p(q);On=o(Dt,`To indicate which AST concepts are considered to be types in your language,
the keyword `),Se=r(Dt,"CODE",{});var gs=p(Se);Sn=o(gs,"isType"),gs.forEach(n),In=o(Dt," is used, followed by all types in your language between curly brackets."),Dt.forEach(n),ot=f(e),g=r(e,"PRE",{class:!0});var So=p(g);So.forEach(n),at=f(e),T=r(e,"P",{});var S=p(T);An=o(S,`To define new type concepts you can use a simplified version of the concept definition in the .ast files.
The properties may only be instances of other type concepts, or references to limited concepts. The property
`),Ie=r(S,"CODE",{});var zs=p(Ie);Dn=o(zs,"base"),zs.forEach(n),Nn=o(S," in the next example is an instance of the interface "),Ae=r(S,"CODE",{});var Js=p(Ae);Rn=o(Js,"PiType"),Js.forEach(n),xn=o(S,", whereas the property "),De=r(S,"CODE",{});var Qs=p(De);qn=o(Qs,"kind"),Qs.forEach(n),Hn=o(S,` refers to
the limited concept `),Ne=r(S,"CODE",{});var Vs=p(Ne);Mn=o(Vs,"GenericKind"),Vs.forEach(n),Gn=o(S,"."),S.forEach(n),lt=f(e),z=r(e,"PRE",{class:!0});var Io=p(z);Io.forEach(n),rt=f(e),te=r(e,"P",{});var Xs=p(te);Fn=o(Xs,`Note that is it often good practise to have a common superclass or interface for all your types,
but this is not necessary.`),Xs.forEach(n),pt=f(e),ne=r(e,"H2",{});var Zs=p(ne);jn=o(Zs,"Terms That Have a Type"),Zs.forEach(n),ct=f(e),$=r(e,"P",{});var fe=p($);Wn=o(fe,`Not all AST nodes need to have a type associated to it. Only those nodes for which you
need a validation rule, or have another reason to require a type, need to be marked as
having a type. We refer to those AST nodes as `),Re=r(fe,"STRONG",{});var eo=p(Re);Bn=o(eo,"terms"),eo.forEach(n),Yn=o(fe,`, so as not to confuse these with
`),se=r(fe,"A",{href:!0});var to=p(se);xe=r(to,"CODE",{});var no=p(xe);Kn=o(no,"expression concepts"),no.forEach(n),to.forEach(n),Un=o(fe,`,
which have a different meaning.`),fe.forEach(n),it=f(e),H=r(e,"P",{});var Nt=p(H);gn=o(Nt,"You can indicate which AST nodes are terms by the keyword "),qe=r(Nt,"CODE",{});var so=p(qe);zn=o(so,"hasType"),so.forEach(n),Jn=o(Nt,` followed by all terms in
your language between curly brackets.`),Nt.forEach(n),ft=f(e),J=r(e,"PRE",{class:!0});var Ao=p(J);Ao.forEach(n),ut=f(e),oe=r(e,"H2",{});var oo=p(oe);Qn=o(oo,"Inference Rules"),oo.forEach(n),dt=f(e),w=r(e,"P",{});var K=p(w);Vn=o(K,"In order to determine the type of a term, there need to be a rule, called  an "),He=r(K,"STRONG",{});var ao=p(He);Xn=o(ao,"inference rule"),ao.forEach(n),Zn=o(K,`,
for each concept or interface that is marked `),Me=r(K,"CODE",{});var lo=p(Me);es=o(lo,"hasType"),lo.forEach(n),ts=o(K,`. Each of these rules should result in a type concept.
The following example gives an inference rule that states that the type of calculation function is the
value of its attribute `),Ge=r(K,"CODE",{});var ro=p(Ge);ns=o(ro,"declaredType"),ro.forEach(n),ss=o(K,"."),K.forEach(n),ht=f(e),Q=r(e,"PRE",{class:!0});var Do=p(Q);Do.forEach(n),yt=f(e),Ht(M.$$.fragment,e),mt=f(e),C=r(e,"P",{});var ue=p(C);os=o(ue,"Concepts that are types (as indicated by "),Fe=r(ue,"CODE",{});var po=p(Fe);as=o(po,"isType"),po.forEach(n),ls=o(ue,`) can also be terms. If an inference rule
is present, this rule will determine the type of such a term. If no rule is
present, the type of the AST node is the `),je=r(ue,"CODE",{});var co=p(je);rs=o(co,"type concept"),co.forEach(n),ps=o(ue," generated for this AST node."),ue.forEach(n),vt=f(e),G=r(e,"P",{});var Rt=p(G);cs=o(Rt,`In an inference rule, as in other definition files, it is possible to use
the predefined instances of a `),We=r(Rt,"STRONG",{});var io=p(We);is=o(io,"limited concept"),io.forEach(n),fs=o(Rt,"."),Rt.forEach(n),_t=f(e),V=r(e,"PRE",{class:!0});var No=p(V);No.forEach(n),Tt=f(e),ae=r(e,"H2",{});var fo=p(ae);us=o(fo,"Type Equals and Type Conformance Rules"),fo.forEach(n),Et=f(e),L=r(e,"P",{});var de=p(L);ds=o(de,`The last section in the type definition is where rules are given that state which types
are considered equal or conforming. Each rule can have two entries: the `),Be=r(de,"STRONG",{});var uo=p(Be);hs=o(uo,"conformsto"),uo.forEach(n),ys=o(de,` and
the `),Ye=r(de,"STRONG",{});var ho=p(Ye);ms=o(ho,"equalsto"),ho.forEach(n),vs=o(de,` entries. In these it is also possible to use the predefined
instances of a limited concept.`),de.forEach(n),wt=f(e),X=r(e,"PRE",{class:!0});var Ro=p(X);Ro.forEach(n),kt=f(e),P=r(e,"P",{});var he=p(P);_s=o(he,"The "),Ke=r(he,"STRONG",{});var yo=p(Ke);Ts=o(yo,"where-clause"),yo.forEach(n),Es=o(he,` in the above example can be used when a type has some structure. For every property
in the type concept a condition is given. If all conditions evaluate to true then the `),Ue=r(he,"CODE",{});var mo=p(Ue);ws=o(mo,"where-clause"),mo.forEach(n),ks=o(he," results in true."),he.forEach(n),bt=f(e),k=r(e,"P",{});var U=p(k);bs=o(U,"In a condition of a "),ge=r(U,"CODE",{});var vo=p(ge);$s=o(vo,"where-clause"),vo.forEach(n),Cs=o(U," you may use "),ze=r(U,"CODE",{});var _o=p(ze);Ls=o(_o,"conformsto"),_o.forEach(n),Ps=o(U,`. In that case, invocation of the rule will produce the cartesian product of
all super concepts of the properties in the conditions. For an
example, see `),le=r(U,"A",{href:!0});var To=p(le);Os=o(To,"Typer Example"),To.forEach(n),Ss=o(U,"."),U.forEach(n),$t=f(e),Ht(F.$$.fragment,e),Ct=f(e),Ht(j.$$.fragment,e),Lt=f(e),re=r(e,"H2",{});var Eo=p(re);Is=o(Eo,"Rules That Apply to Any Concept"),Eo.forEach(n),Pt=f(e),W=r(e,"P",{});var xt=p(W);As=o(xt,"Conformance and other rules can also be defined to apply to "),Je=r(xt,"STRONG",{});var wo=p(Je);Ds=o(wo,"any"),wo.forEach(n),Ns=o(xt,` concept. Obviously, this means that
any instance of any concept conforms to the given value.`),xt.forEach(n),Ot=f(e),Z=r(e,"PRE",{class:!0});var xo=p(Z);xo.forEach(n),St=f(e),Ht(B.$$.fragment,e),this.h()},h(){R(g,"class","language-ts"),R(z,"class","language-ts"),R(se,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure"),R(J,"class","language-ts"),R(Q,"class","language-ts"),R(V,"class","language-ts"),R(X,"class","language-ts"),R(le,"href","/030_Developing_a_Language/020_Definition_Level/030_Typer_Definition/030_Example_Typer_Definition"),R(Z,"class","language-ts")},m(e,a){c(e,d,a),t(d,u),c(e,v,a),c(e,y,a),t(y,h),t(y,m),t(m,Bt),t(y,Yt),t(y,ye),t(ye,Kt),t(y,Ut),t(y,me),t(me,gt),t(y,zt),c(e,Ze,a),c(e,E,a),t(E,A),t(A,Jt),t(A,ve),t(ve,Qt),t(A,Vt),t(A,_e),t(_e,Xt),t(A,Zt),t(E,en),t(E,D),t(D,tn),t(D,Te),t(Te,nn),t(D,sn),t(D,Ee),t(Ee,on),t(D,an),t(E,ln),t(E,N),t(N,rn),t(N,we),t(we,pn),t(N,cn),t(N,ke),t(ke,fn),t(N,un),t(E,dn),t(E,be),t(be,hn),c(e,et,a),c(e,x,a),t(x,yn),t(x,$e),t($e,mn),t(x,vn),c(e,tt,a),c(e,ee,a),t(ee,_n),c(e,nt,a),c(e,_,a),t(_,Tn),t(_,Ce),t(Ce,En),t(_,wn),t(_,Le),t(Le,kn),t(_,bn),t(_,Pe),t(Pe,$n),t(_,Cn),t(_,Oe),t(Oe,Ln),t(_,Pn),c(e,st,a),c(e,q,a),t(q,On),t(q,Se),t(Se,Sn),t(q,In),c(e,ot,a),c(e,g,a),g.innerHTML=ko,c(e,at,a),c(e,T,a),t(T,An),t(T,Ie),t(Ie,Dn),t(T,Nn),t(T,Ae),t(Ae,Rn),t(T,xn),t(T,De),t(De,qn),t(T,Hn),t(T,Ne),t(Ne,Mn),t(T,Gn),c(e,lt,a),c(e,z,a),z.innerHTML=bo,c(e,rt,a),c(e,te,a),t(te,Fn),c(e,pt,a),c(e,ne,a),t(ne,jn),c(e,ct,a),c(e,$,a),t($,Wn),t($,Re),t(Re,Bn),t($,Yn),t($,se),t(se,xe),t(xe,Kn),t($,Un),c(e,it,a),c(e,H,a),t(H,gn),t(H,qe),t(qe,zn),t(H,Jn),c(e,ft,a),c(e,J,a),J.innerHTML=$o,c(e,ut,a),c(e,oe,a),t(oe,Qn),c(e,dt,a),c(e,w,a),t(w,Vn),t(w,He),t(He,Xn),t(w,Zn),t(w,Me),t(Me,es),t(w,ts),t(w,Ge),t(Ge,ns),t(w,ss),c(e,ht,a),c(e,Q,a),Q.innerHTML=Co,c(e,yt,a),Mt(M,e,a),c(e,mt,a),c(e,C,a),t(C,os),t(C,Fe),t(Fe,as),t(C,ls),t(C,je),t(je,rs),t(C,ps),c(e,vt,a),c(e,G,a),t(G,cs),t(G,We),t(We,is),t(G,fs),c(e,_t,a),c(e,V,a),V.innerHTML=Lo,c(e,Tt,a),c(e,ae,a),t(ae,us),c(e,Et,a),c(e,L,a),t(L,ds),t(L,Be),t(Be,hs),t(L,ys),t(L,Ye),t(Ye,ms),t(L,vs),c(e,wt,a),c(e,X,a),X.innerHTML=Po,c(e,kt,a),c(e,P,a),t(P,_s),t(P,Ke),t(Ke,Ts),t(P,Es),t(P,Ue),t(Ue,ws),t(P,ks),c(e,bt,a),c(e,k,a),t(k,bs),t(k,ge),t(ge,$s),t(k,Cs),t(k,ze),t(ze,Ls),t(k,Ps),t(k,le),t(le,Os),t(k,Ss),c(e,$t,a),Mt(F,e,a),c(e,Ct,a),Mt(j,e,a),c(e,Lt,a),c(e,re,a),t(re,Is),c(e,Pt,a),c(e,W,a),t(W,As),t(W,Je),t(Je,Ds),t(W,Ns),c(e,Ot,a),c(e,Z,a),Z.innerHTML=Oo,c(e,St,a),Mt(B,e,a),It=!0},p(e,[a]){const b={};a&1&&(b.$$scope={dirty:a,ctx:e}),M.$set(b);const Qe={};a&1&&(Qe.$$scope={dirty:a,ctx:e}),F.$set(Qe);const Ve={};a&1&&(Ve.$$scope={dirty:a,ctx:e}),j.$set(Ve);const Xe={};a&1&&(Xe.$$scope={dirty:a,ctx:e}),B.$set(Xe)},i(e){It||(Gt(M.$$.fragment,e),Gt(F.$$.fragment,e),Gt(j.$$.fragment,e),Gt(B.$$.fragment,e),It=!0)},o(e){Ft(M.$$.fragment,e),Ft(F.$$.fragment,e),Ft(j.$$.fragment,e),Ft(B.$$.fragment,e),It=!1},d(e){e&&n(d),e&&n(v),e&&n(y),e&&n(Ze),e&&n(E),e&&n(et),e&&n(x),e&&n(tt),e&&n(ee),e&&n(nt),e&&n(_),e&&n(st),e&&n(q),e&&n(ot),e&&n(g),e&&n(at),e&&n(T),e&&n(lt),e&&n(z),e&&n(rt),e&&n(te),e&&n(pt),e&&n(ne),e&&n(ct),e&&n($),e&&n(it),e&&n(H),e&&n(ft),e&&n(J),e&&n(ut),e&&n(oe),e&&n(dt),e&&n(w),e&&n(ht),e&&n(Q),e&&n(yt),jt(M,e),e&&n(mt),e&&n(C),e&&n(vt),e&&n(G),e&&n(_t),e&&n(V),e&&n(Tt),e&&n(ae),e&&n(Et),e&&n(L),e&&n(wt),e&&n(X),e&&n(kt),e&&n(P),e&&n(bt),e&&n(k),e&&n($t),jt(F,e),e&&n(Ct),jt(j,e),e&&n(Lt),e&&n(re),e&&n(Pt),e&&n(W),e&&n(Ot),e&&n(Z),e&&n(St),jt(B,e)}}}class go extends qo{constructor(d){super();Ho(this,d,null,Bo,Mo,{})}}export{go as default};
