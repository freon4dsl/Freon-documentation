import{S as op,i as lp,s as pp,e as p,t as s,k as d,w as we,c as i,a as r,h as a,d as t,m as f,x as Ee,b as v,g as l,H as n,y as _e,q as be,o as ve,B as $e}from"../../../../chunks/vendor-0dc77bd0.js";import{N as je}from"../../../../chunks/Note-b0db7989.js";/* empty css                                                            */function ip(w){let u;return{c(){u=s("Only direct properties are allowed")},l(c){u=a(c,"Only direct properties are allowed")},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function rp(w){let u,c,k,y;return{c(){u=s(`Only the properties that are directly owned by the concept or interface are allowed. For instance,
`),c=p("code"),k=s("self.declaredType.name"),y=s(" is not a valid property projection.")},l(h){u=a(h,`Only the properties that are directly owned by the concept or interface are allowed. For instance,
`),c=i(h,"CODE",{});var m=r(c);k=a(m,"self.declaredType.name"),m.forEach(t),y=a(h," is not a valid property projection.")},m(h,m){l(h,u,m),l(h,c,m),n(c,k),l(h,y,m)},d(h){h&&t(u),h&&t(c),h&&t(y)}}}function cp(w){let u,c,k;return{c(){u=p("code"),c=s("self"),k=s(" is optional")},l(y){u=i(y,"CODE",{});var h=r(u);c=a(h,"self"),h.forEach(t),k=a(y," is optional")},m(y,h){l(y,u,h),n(u,c),l(y,k,h)},d(y){y&&t(u),y&&t(k)}}}function up(w){let u,c,k,y;return{c(){u=s("Because you may only use direct properties, the prefix "),c=p("code"),k=s("self"),y=s(" may be omitted.")},l(h){u=a(h,"Because you may only use direct properties, the prefix "),c=i(h,"CODE",{});var m=r(c);k=a(m,"self"),m.forEach(t),y=a(h," may be omitted.")},m(h,m){l(h,u,m),l(h,c,m),n(c,k),l(h,y,m)},d(h){h&&t(u),h&&t(c),h&&t(y)}}}function dp(w){let u;return{c(){u=s("Newlines in terminator or separator are ignored")},l(c){u=a(c,"Newlines in terminator or separator are ignored")},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function fp(w){let u,c,k,y,h,m,W;return{c(){u=s(`A terminator or separator should not contain a newline character. Horizontal or vertical layout is
purely determined by the keywords `),c=p("code"),k=s("horizontal"),y=s(" and "),h=p("code"),m=s("vertical"),W=s(".")},l(E){u=a(E,`A terminator or separator should not contain a newline character. Horizontal or vertical layout is
purely determined by the keywords `),c=i(E,"CODE",{});var j=r(c);k=a(j,"horizontal"),j.forEach(t),y=a(E," and "),h=i(E,"CODE",{});var Pe=r(h);m=a(Pe,"vertical"),Pe.forEach(t),W=a(E,".")},m(E,j){l(E,u,j),l(E,c,j),n(c,k),l(E,y,j),l(E,h,j),n(h,m),l(E,W,j)},d(E){E&&t(u),E&&t(c),E&&t(y),E&&t(h),E&&t(W)}}}function hp(w){let u;return{c(){u=s(`Note that you only need to include one
table projection for both column and row based tables. ProjectIt will swap the entries when needed.`)},l(c){u=a(c,`Note that you only need to include one
table projection for both column and row based tables. ProjectIt will swap the entries when needed.`)},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function kp(w){let u;return{c(){u=s("Properties within a table are displayed according to their own projection")},l(c){u=a(c,"Properties within a table are displayed according to their own projection")},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function yp(w){let u;return{c(){u=s("The manner in which each of the properties of a single function are displayed, will be determined\nby their own projections. In this example, `self.parameters` is a list, and will be displayed as another table.\nThe inner table will be row-based, as this is the default.")},l(c){u=a(c,"The manner in which each of the properties of a single function are displayed, will be determined\nby their own projections. In this example, `self.parameters` is a list, and will be displayed as another table.\nThe inner table will be row-based, as this is the default.")},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function mp(w){let u;return{c(){u=s("Whitespace in headers is ignored")},l(c){u=a(c,"Whitespace in headers is ignored")},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function wp(w){let u;return{c(){u=s(`The whitespace between the headers is not needed. However, for clarity, it is probably
good style to align the column/row-separators.`)},l(c){u=a(c,`The whitespace between the headers is not needed. However, for clarity, it is probably
good style to align the column/row-separators.`)},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function Ep(w){let u;return{c(){u=s("Keywords defined within a projection overwrite the standard boolean keywords")},l(c){u=a(c,"Keywords defined within a projection overwrite the standard boolean keywords")},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function _p(w){let u;return{c(){u=s(`In the default editor you can define standard boolean keywords. These will not be used when either of the two keyword projections
is present.`)},l(c){u=a(c,`In the default editor you can define standard boolean keywords. These will not be used when either of the two keyword projections
is present.`)},m(c,k){l(c,u,k)},d(c){c&&t(u)}}}function bp(w){let u,c,k,y,h,m,W,E,j,Pe,ss,Qe,as,os,Ve,ls,ps,Jt,te,Hl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-indentation.edit#L6-L14</span>

Text <span class="token punctuation">&#123;</span>
<span class="token punctuation">[</span>
This <span class="token keyword">is</span>
        literal text
      that <span class="token keyword">is</span> projected <span class="token keyword">in</span> the
                editor
  <span class="token keyword">for</span> every concept <span class="token keyword">of</span> <span class="token keyword">type</span> <span class="token class-name">Text</span><span class="token punctuation">.</span>
<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span></code>`,Qt,Oe,is,Vt,S,rs,Xe,cs,us,Xt,_,ds,Ze,fs,hs,ge,ks,ys,et,ms,ws,tt,Es,_s,nt,bs,vs,st,$s,js,Zt,ne,Nl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-main-default.edit#L40-L46</span>

CalcFunction <span class="token punctuation">&#123;</span>
    <span class="token punctuation">[</span>
        $<span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span> $<span class="token punctuation">&#123;</span>parameters horizontal separator<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token operator">:</span> $<span class="token punctuation">&#123;</span>declaredType<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>
            $<span class="token punctuation">&#123;</span>body<span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span></code>`,gt,F,en,Y,tn,se,at,Ps,nn,G,Os,Te,Ts,Cs,sn,q,Ds,ot,Is,Ls,an,x,xs,lt,As,Hs,pt,Ns,Rs,on,ae,Rl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-specials.edit#L3-L9</span>

BaseProduct <span class="token punctuation">&#123;</span><span class="token punctuation">[</span>
    <span class="token comment">/* In this projection 'self.parts' is always shown according to the projection */</span>
    <span class="token comment">/* defined for concept InsurancePart in the editor 'comments'.                 */</span>
    Base Products $<span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span> <span class="token keyword">for</span> $<span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>theme<span class="token punctuation">&#125;</span>
        $<span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>parts<span class="token operator">:</span>comments<span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
</code>`,ln,Ce,Ms,pn,A,Bs,it,zs,Ws,rt,Ss,Fs,rn,H,Ys,De,Gs,qs,ct,Ks,Us,cn,Ie,Js,un,N,oe,Qs,ut,Vs,Xs,Zs,le,gs,dt,ea,ta,na,pe,sa,ft,aa,oa,dn,Le,la,fn,b,pa,ht,ia,ra,kt,ca,ua,yt,da,fa,mt,ha,ka,wt,ya,ma,Et,wa,Ea,hn,ie,Ml=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-main-default.edit#L27-L38</span>

InsuranceProduct <span class="token punctuation">&#123;</span><span class="token punctuation">[</span>
    Insurance Product $<span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span> <span class="token keyword">public</span> name<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>productName<span class="token punctuation">&#125;</span> <span class="token punctuation">)</span> <span class="token constant">USES</span> $<span class="token punctuation">&#123;</span>basedOn horizontal separator<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
        Themes<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>themes horizontal separator<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
        Premium<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>advertisedPremium<span class="token punctuation">&#125;</span> per $<span class="token punctuation">&#123;</span>nrPremiumDays<span class="token punctuation">&#125;</span>
        Insured risks<span class="token operator">:</span>
            $<span class="token punctuation">&#123;</span>parts vertical terminator <span class="token punctuation">[</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
        Calculation
            <span class="token punctuation">[</span><span class="token operator">?</span> Risk adjusted by <span class="token operator">=</span> $<span class="token punctuation">&#123;</span>riskAdjustment<span class="token punctuation">&#125;</span> <span class="token punctuation">]</span>
            calculated premium<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>calculation<span class="token punctuation">&#125;</span>
        <span class="token punctuation">[</span><span class="token operator">?</span>Helper functions<span class="token operator">:</span>
            $<span class="token punctuation">&#123;</span>helpers vertical<span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code>`,kn,K,yn,xe,mn,Ae,_a,wn,He,ba,En,Ne,va,_n,U,L,$a,_t,ja,Pa,bt,Oa,Ta,vt,Ca,Da,Ia,$t,La,bn,J,vn,R,xa,jt,Aa,Ha,Pt,Na,Ra,$n,re,Bl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-tables.edit#L13-L16</span>

BaseProduct <span class="token punctuation">&#123;</span><span class="token punctuation">[</span>
    Base Products $<span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span> <span class="token keyword">for</span> $<span class="token punctuation">&#123;</span>theme<span class="token punctuation">&#125;</span>
        $<span class="token punctuation">&#123;</span>parts table rows<span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code>`,jn,M,Ma,Ot,Ba,za,Tt,Wa,Sa,Pn,ce,zl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-tables.edit#L6-L11</span>

InsurancePart<span class="token punctuation">&#123;</span>
table <span class="token punctuation">[</span>
    Name    <span class="token operator">|</span> risk               <span class="token operator">|</span> pay out          <span class="token operator">|</span> <span class="token keyword">is</span> approved
    $<span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span> <span class="token operator">|</span> $<span class="token punctuation">&#123;</span>statisticalRisk<span class="token punctuation">&#125;</span> <span class="token operator">|</span> $<span class="token punctuation">&#123;</span>maximumPayOut<span class="token punctuation">&#125;</span> <span class="token operator">|</span> $<span class="token punctuation">&#123;</span>isApproved<span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span></code>`,On,Q,Tn,V,Cn,Re,Fa,Dn,B,Ya,Ct,Ga,qa,Dt,Ka,Ua,In,P,Ja,It,Qa,Va,Lt,Xa,Za,xt,ga,eo,At,to,no,Ln,ue,Wl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-main-default.edit#L27-L38</span>

InsuranceProduct <span class="token punctuation">&#123;</span><span class="token punctuation">[</span>
    Insurance Product $<span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span> <span class="token keyword">public</span> name<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>productName<span class="token punctuation">&#125;</span> <span class="token punctuation">)</span> <span class="token constant">USES</span> $<span class="token punctuation">&#123;</span>basedOn horizontal separator<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
        Themes<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>themes horizontal separator<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
        Premium<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>advertisedPremium<span class="token punctuation">&#125;</span> per $<span class="token punctuation">&#123;</span>nrPremiumDays<span class="token punctuation">&#125;</span>
        Insured risks<span class="token operator">:</span>
            $<span class="token punctuation">&#123;</span>parts vertical terminator <span class="token punctuation">[</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
        Calculation
            <span class="token punctuation">[</span><span class="token operator">?</span> Risk adjusted by <span class="token operator">=</span> $<span class="token punctuation">&#123;</span>riskAdjustment<span class="token punctuation">&#125;</span> <span class="token punctuation">]</span>
            calculated premium<span class="token operator">:</span> $<span class="token punctuation">&#123;</span>calculation<span class="token punctuation">&#125;</span>
        <span class="token punctuation">[</span><span class="token operator">?</span>Helper functions<span class="token operator">:</span>
            $<span class="token punctuation">&#123;</span>helpers vertical<span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code>`,xn,Me,so,An,Be,Hn,ze,ao,Nn,D,oo,Ht,lo,po,Nt,io,ro,Rt,co,uo,Rn,de,Sl=`<code class="language-ts"><span class="token comment">// docu-project/defs/language-extras.ast#L34-L37</span>

concept Entity <span class="token punctuation">&#123;</span>
    isCompany<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    reference baseEntity<span class="token operator">?</span><span class="token operator">:</span> Entity<span class="token punctuation">;</span></code>`,Mn,fe,Fl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-main-default.edit#L5-L5</span>

<span class="token builtin">boolean</span> <span class="token punctuation">[</span><span class="token constant">YES</span> <span class="token operator">|</span> <span class="token constant">NO</span><span class="token punctuation">]</span> <span class="token comment">// the strings used to display a boolean value</span></code>`,Bn,$,fo,Mt,ho,ko,Bt,yo,mo,zt,wo,Eo,Wt,_o,bo,St,vo,$o,zn,he,Yl=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-main-default.edit#L57-L59</span>

Entity <span class="token punctuation">&#123;</span><span class="token punctuation">[</span>
    $<span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>isCompany <span class="token punctuation">[</span><span class="token constant">COMPANY</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> $<span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code>`,Wn,We,jo,Sn,ke,Gl=`<code class="language-undefined">COMPANY entity PhilipsEnterPrises &#123; // the value of isCompany is true
  ...
&#125;
entity FritsPhilips &#123; // the value of isCompany is false
  ...
&#125;</code>`,Fn,X,Po,Ft,Oo,To,Yn,ye,ql=`<code class="language-ts"><span class="token comment">// docu-project/defs/editor-specials.edit#L11-L13</span>

    $<span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>isCompany <span class="token punctuation">[</span><span class="token constant">COMPANY</span> <span class="token operator">|</span> <span class="token constant">PERSON</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> $<span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
</code>`,Gn,Se,Co,qn,me,Kl=`<code class="language-undefined">COMPANY entity PhilipsEnterPrises &#123; // the value of isCompany is true
  ...
&#125;
PERSON entity FritsPhilips &#123; // the value of isCompany is false
  ...
&#125;</code>`,Kn,Z,Un;return F=new je({props:{$$slots:{content:[rp],header:[ip]},$$scope:{ctx:w}}}),Y=new je({props:{$$slots:{content:[up],header:[cp]},$$scope:{ctx:w}}}),K=new je({props:{$$slots:{content:[fp],header:[dp]},$$scope:{ctx:w}}}),J=new je({props:{$$slots:{content:[hp]},$$scope:{ctx:w}}}),Q=new je({props:{$$slots:{content:[yp],header:[kp]},$$scope:{ctx:w}}}),V=new je({props:{$$slots:{content:[wp],header:[mp]},$$scope:{ctx:w}}}),Z=new je({props:{$$slots:{content:[_p],header:[Ep]},$$scope:{ctx:w}}}),{c(){u=p("h1"),c=s("Projections"),k=d(),y=p("p"),h=s("In the "),m=p("code"),W=s(".edit"),E=s(" file a "),j=p("em"),Pe=s("projection"),ss=s(` is defined between angular brackets.
This is done in a style similar from markdown, what you see looks close to what you get.
Everything within the square brackets (`),Qe=p("code"),as=s("[]"),os=s(`), except
the parts surrounded by `),Ve=p("code"),ls=s("${}"),ps=s(", is taken literally."),Jt=d(),te=p("pre"),Qt=d(),Oe=p("h2"),is=s("Including Properties"),Vt=d(),S=p("p"),rs=s(`When you define a projection for a concept or interface, you will want to include its properties. For
this you need to use the special notation `),Xe=p("code"),cs=s("${}"),us=s(`. This tells ProjectIt to include a property, according to the projection
that is defined for the type of the property.`),Xt=d(),_=p("p"),ds=s("In the following example "),Ze=p("code"),fs=s("self.body"),hs=s(" is a property of type "),ge=p("code"),ks=s("DocuExpression"),ys=s(`.
It will be projected according to the projection for `),et=p("code"),ms=s("DocuExpression"),ws=s(", whereas "),tt=p("code"),Es=s("self.declaredType"),_s=s(`
is a property of type `),nt=p("code"),bs=s("DocuType"),vs=s(`, which is abstract. This property
will be projected according to the definition for the (non-abstract) subtype of `),st=p("code"),$s=s("DocuType"),js=s(` that is
currently found.`),Zt=d(),ne=p("pre"),gt=d(),we(F.$$.fragment),en=d(),we(Y.$$.fragment),tn=d(),se=p("h3"),at=p("a"),Ps=s(" Including a Property Projection from Another Editor"),nn=d(),G=p("p"),Os=s(`Normally, the property that you include will be displayed according to the projection of its type. This projection
will be found by ProjectIt using the `),Te=p("a"),Ts=s("ordering"),Cs=s(`
as defined in the configuration.`),sn=d(),q=p("p"),Ds=s("When you specifically want to use another projection, you can use a "),ot=p("strong"),Is=s("named property projection"),Ls=s(`. In that case,
ProjectIt will use the projection defined for the concept in the editor with the specified name.`),an=d(),x=p("p"),xs=s("In this example, the projection for "),lt=p("code"),As=s("self.parts"),Hs=s(" will first be searched in the editor named "),pt=p("code"),Ns=s("comments"),Rs=s(`.
If it cannot be found, the normal ordering of projections will proceed.`),on=d(),ae=p("pre"),ln=d(),Ce=p("h2"),Ms=s("Lists"),pn=d(),A=p("p"),Bs=s(`If a property is a list, you can indicate whether it should be projected horizontally or vertically.
Both keywords are optional. If neither of `),it=p("code"),zs=s("vertical"),Ws=s(" or "),rt=p("code"),Ss=s("horizontal"),Fs=s(` is present, the property will be displayed as
a vertical list.`),rn=d(),H=p("p"),Ys=s("You can also choose to project a list property as a "),De=p("a"),Gs=s("table"),qs=s(`.
However, its default projection will always be a list. This is the one that will be generated when a
projection is not present in the `),ct=p("code"),Ks=s(".edit"),Us=s(" files."),cn=d(),Ie=p("p"),Js=s("In a list, you can add one of the following."),un=d(),N=p("ul"),oe=p("li"),Qs=s("A "),ut=p("em"),Vs=s("separator"),Xs=s(" string, which will be shown in between all elements."),Zs=d(),le=p("li"),gs=s("A "),dt=p("em"),ea=s("terminator"),ta=s(" string, which will be shown after each element."),na=d(),pe=p("li"),sa=s("An "),ft=p("em"),aa=s("initiator"),oa=s(" string, which will be shown before every element of the list."),dn=d(),Le=p("p"),la=s("Each is optional. The default is a single space used as separator."),fn=d(),b=p("p"),pa=s("In the following example the list "),ht=p("code"),ia=s("parts"),ra=s(" is displayed vertically with the string "),kt=p("code"),ca=s("';'"),ua=s(` as terminator.
Whereas, the list `),yt=p("code"),da=s("themes"),fa=s(" is displayed horizontally with the string "),mt=p("code"),ha=s("', '"),ka=s(` as separator. Finally, the
list `),wt=p("code"),ya=s("helpers"),ma=s(` is shown as a vertical list without any separator, terminator or initiator. Actually, we
could omit the keyword `),Et=p("code"),wa=s("vertical"),Ea=s(", because this is the default projection for lists."),hn=d(),ie=p("pre"),kn=d(),we(K.$$.fragment),yn=d(),xe=p("a"),mn=d(),Ae=p("h2"),_a=s("Tables"),wn=d(),He=p("p"),ba=s(`If a property is a list, you can choose to project it as a table. Tables can be either row or column based.
Row based means that each element of the list is displayed in a row. Column based, obviously, means that
each element is displayed in a single column. The default is row based.`),En=d(),Ne=p("p"),va=s("Defining a table is a two-step process."),_n=d(),U=p("ol"),L=p("li"),$a=s("Add the keyword "),_t=p("code"),ja=s("table"),Pa=s(` to the list property that
you want to display as a table. Optionally, add one of the keywords `),bt=p("code"),Oa=s("rows"),Ta=s(" or "),vt=p("code"),Ca=s("columns"),Da=s("."),Ia=d(),$t=p("li"),La=s(`Add a table-projection to the type of the property. The table-projection defines
the headers of the table and which parts of the list elements are displayed in which row or column.`),bn=d(),we(J.$$.fragment),vn=d(),R=p("p"),xa=s("For example, to project the "),jt=p("code"),Aa=s("parts"),Ha=s(" property of concept "),Pt=p("code"),Na=s("BaseProduct"),Ra=s(" as a row based table, you can use the following code."),$n=d(),re=p("pre"),jn=d(),M=p("p"),Ma=s("Given the above example, there should also be a projection tagged "),Ot=p("code"),Ba=s("table"),za=s(" for the concept "),Tt=p("code"),Wa=s("InsurancePart"),Sa=s(`.
Below four columns/rows are defined, each with its own header.`),Pn=d(),ce=p("pre"),On=d(),we(Q.$$.fragment),Tn=d(),we(V.$$.fragment),Cn=d(),Re=p("h2"),Fa=s("Optional Projections"),Dn=d(),B=p("p"),Ya=s("When a property is marked optional in the language structure definition (the "),Ct=p("code"),Ga=s(".ast"),qa=s(` files), the projection
of this property should also be optional. This is indicated by `),Dt=p("code"),Ka=s("[?"),Ua=s("."),In=d(),P=p("p"),Ja=s("In the next example both the property "),It=p("code"),Qa=s("riskAdjustment"),Va=s(" and "),Lt=p("code"),Xa=s("helpers"),Za=s(` are only shown if they are present.
If they are not present, respectively the text `),xt=p("code"),ga=s("Risk adjusted by ="),eo=s(" or "),At=p("code"),to=s("Helper functions:"),no=s(" is omitted as well."),Ln=d(),ue=p("pre"),xn=d(),Me=p("p"),so=s("Note that optional projections for non-optional properties are not allowed."),An=d(),Be=p("a"),Hn=d(),ze=p("h2"),ao=s("Boolean Keyword Projections"),Nn=d(),D=p("p"),oo=s("The next example shows the special manner in which properties of type "),Ht=p("strong"),lo=s("boolean"),po=s(` can be
projected. The concept `),Nt=p("code"),io=s("Entity"),ro=s(" has a simple property of type boolean called "),Rt=p("code"),co=s("isCompany"),uo=s(`. Normally,
its value would be displayed according to the boolean keyword projection in the default editor.`),Rn=d(),de=p("pre"),Mn=d(),fe=p("pre"),Bn=d(),$=p("p"),fo=s("By defining that the property must be represented by a "),Mt=p("strong"),ho=s("keyword"),ko=s(`, we can change the default.
In the next example, the property `),Bt=p("code"),yo=s("isCompany"),mo=s(" will be shown as the keyword "),zt=p("code"),wo=s("COMPANY"),Eo=s(`. When the value
of the property is `),Wt=p("code"),_o=s("true"),bo=s(", the keyword is shown. When the value is "),St=p("code"),vo=s("false"),$o=s(", the keyword is not shown."),zn=d(),he=p("pre"),Wn=d(),We=p("p"),jo=s("This example would be displayed as one of \u2026"),Sn=d(),ke=p("pre"),Fn=d(),X=p("p"),Po=s("Another way to display boolean properties is to use "),Ft=p("strong"),Oo=s("two"),To=s(` keywords. Depending on
the value of the property either the first or second keyword is shown.`),Yn=d(),ye=p("pre"),Gn=d(),Se=p("p"),Co=s("This would be displayed as one of \u2026"),qn=d(),me=p("pre"),Kn=d(),we(Z.$$.fragment),this.h()},l(e){u=i(e,"H1",{});var o=r(u);c=a(o,"Projections"),o.forEach(t),k=f(e),y=i(e,"P",{});var C=r(y);h=a(C,"In the "),m=i(C,"CODE",{});var Yt=r(m);W=a(Yt,".edit"),Yt.forEach(t),E=a(C," file a "),j=i(C,"EM",{});var Gt=r(j);Pe=a(Gt,"projection"),Gt.forEach(t),ss=a(C,` is defined between angular brackets.
This is done in a style similar from markdown, what you see looks close to what you get.
Everything within the square brackets (`),Qe=i(C,"CODE",{});var qt=r(Qe);as=a(qt,"[]"),qt.forEach(t),os=a(C,`), except
the parts surrounded by `),Ve=i(C,"CODE",{});var Kt=r(Ve);ls=a(Kt,"${}"),Kt.forEach(t),ps=a(C,", is taken literally."),C.forEach(t),Jt=f(e),te=i(e,"PRE",{class:!0});var Jn=r(te);Jn.forEach(t),Qt=f(e),Oe=i(e,"H2",{});var Ut=r(Oe);is=a(Ut,"Including Properties"),Ut.forEach(t),Vt=f(e),S=i(e,"P",{});var Qn=r(S);rs=a(Qn,`When you define a projection for a concept or interface, you will want to include its properties. For
this you need to use the special notation `),Xe=i(Qn,"CODE",{});var Io=r(Xe);cs=a(Io,"${}"),Io.forEach(t),us=a(Qn,`. This tells ProjectIt to include a property, according to the projection
that is defined for the type of the property.`),Qn.forEach(t),Xt=f(e),_=i(e,"P",{});var O=r(_);ds=a(O,"In the following example "),Ze=i(O,"CODE",{});var Lo=r(Ze);fs=a(Lo,"self.body"),Lo.forEach(t),hs=a(O," is a property of type "),ge=i(O,"CODE",{});var xo=r(ge);ks=a(xo,"DocuExpression"),xo.forEach(t),ys=a(O,`.
It will be projected according to the projection for `),et=i(O,"CODE",{});var Ao=r(et);ms=a(Ao,"DocuExpression"),Ao.forEach(t),ws=a(O,", whereas "),tt=i(O,"CODE",{});var Ho=r(tt);Es=a(Ho,"self.declaredType"),Ho.forEach(t),_s=a(O,`
is a property of type `),nt=i(O,"CODE",{});var No=r(nt);bs=a(No,"DocuType"),No.forEach(t),vs=a(O,`, which is abstract. This property
will be projected according to the definition for the (non-abstract) subtype of `),st=i(O,"CODE",{});var Ro=r(st);$s=a(Ro,"DocuType"),Ro.forEach(t),js=a(O,` that is
currently found.`),O.forEach(t),Zt=f(e),ne=i(e,"PRE",{class:!0});var Ul=r(ne);Ul.forEach(t),gt=f(e),Ee(F.$$.fragment,e),en=f(e),Ee(Y.$$.fragment,e),tn=f(e),se=i(e,"H3",{});var Do=r(se);at=i(Do,"A",{name:!0}),r(at).forEach(t),Ps=a(Do," Including a Property Projection from Another Editor"),Do.forEach(t),nn=f(e),G=i(e,"P",{});var Vn=r(G);Os=a(Vn,`Normally, the property that you include will be displayed according to the projection of its type. This projection
will be found by ProjectIt using the `),Te=i(Vn,"A",{href:!0});var Mo=r(Te);Ts=a(Mo,"ordering"),Mo.forEach(t),Cs=a(Vn,`
as defined in the configuration.`),Vn.forEach(t),sn=f(e),q=i(e,"P",{});var Xn=r(q);Ds=a(Xn,"When you specifically want to use another projection, you can use a "),ot=i(Xn,"STRONG",{});var Bo=r(ot);Is=a(Bo,"named property projection"),Bo.forEach(t),Ls=a(Xn,`. In that case,
ProjectIt will use the projection defined for the concept in the editor with the specified name.`),Xn.forEach(t),an=f(e),x=i(e,"P",{});var Fe=r(x);xs=a(Fe,"In this example, the projection for "),lt=i(Fe,"CODE",{});var zo=r(lt);As=a(zo,"self.parts"),zo.forEach(t),Hs=a(Fe," will first be searched in the editor named "),pt=i(Fe,"CODE",{});var Wo=r(pt);Ns=a(Wo,"comments"),Wo.forEach(t),Rs=a(Fe,`.
If it cannot be found, the normal ordering of projections will proceed.`),Fe.forEach(t),on=f(e),ae=i(e,"PRE",{class:!0});var Jl=r(ae);Jl.forEach(t),ln=f(e),Ce=i(e,"H2",{});var So=r(Ce);Ms=a(So,"Lists"),So.forEach(t),pn=f(e),A=i(e,"P",{});var Ye=r(A);Bs=a(Ye,`If a property is a list, you can indicate whether it should be projected horizontally or vertically.
Both keywords are optional. If neither of `),it=i(Ye,"CODE",{});var Fo=r(it);zs=a(Fo,"vertical"),Fo.forEach(t),Ws=a(Ye," or "),rt=i(Ye,"CODE",{});var Yo=r(rt);Ss=a(Yo,"horizontal"),Yo.forEach(t),Fs=a(Ye,` is present, the property will be displayed as
a vertical list.`),Ye.forEach(t),rn=f(e),H=i(e,"P",{});var Ge=r(H);Ys=a(Ge,"You can also choose to project a list property as a "),De=i(Ge,"A",{href:!0});var Go=r(De);Gs=a(Go,"table"),Go.forEach(t),qs=a(Ge,`.
However, its default projection will always be a list. This is the one that will be generated when a
projection is not present in the `),ct=i(Ge,"CODE",{});var qo=r(ct);Ks=a(qo,".edit"),qo.forEach(t),Us=a(Ge," files."),Ge.forEach(t),cn=f(e),Ie=i(e,"P",{});var Ko=r(Ie);Js=a(Ko,"In a list, you can add one of the following."),Ko.forEach(t),un=f(e),N=i(e,"UL",{});var qe=r(N);oe=i(qe,"LI",{});var Zn=r(oe);Qs=a(Zn,"A "),ut=i(Zn,"EM",{});var Uo=r(ut);Vs=a(Uo,"separator"),Uo.forEach(t),Xs=a(Zn," string, which will be shown in between all elements."),Zn.forEach(t),Zs=f(qe),le=i(qe,"LI",{});var gn=r(le);gs=a(gn,"A "),dt=i(gn,"EM",{});var Jo=r(dt);ea=a(Jo,"terminator"),Jo.forEach(t),ta=a(gn," string, which will be shown after each element."),gn.forEach(t),na=f(qe),pe=i(qe,"LI",{});var es=r(pe);sa=a(es,"An "),ft=i(es,"EM",{});var Qo=r(ft);aa=a(Qo,"initiator"),Qo.forEach(t),oa=a(es," string, which will be shown before every element of the list."),es.forEach(t),qe.forEach(t),dn=f(e),Le=i(e,"P",{});var Vo=r(Le);la=a(Vo,"Each is optional. The default is a single space used as separator."),Vo.forEach(t),fn=f(e),b=i(e,"P",{});var T=r(b);pa=a(T,"In the following example the list "),ht=i(T,"CODE",{});var Xo=r(ht);ia=a(Xo,"parts"),Xo.forEach(t),ra=a(T," is displayed vertically with the string "),kt=i(T,"CODE",{});var Zo=r(kt);ca=a(Zo,"';'"),Zo.forEach(t),ua=a(T,` as terminator.
Whereas, the list `),yt=i(T,"CODE",{});var go=r(yt);da=a(go,"themes"),go.forEach(t),fa=a(T," is displayed horizontally with the string "),mt=i(T,"CODE",{});var el=r(mt);ha=a(el,"', '"),el.forEach(t),ka=a(T,` as separator. Finally, the
list `),wt=i(T,"CODE",{});var tl=r(wt);ya=a(tl,"helpers"),tl.forEach(t),ma=a(T,` is shown as a vertical list without any separator, terminator or initiator. Actually, we
could omit the keyword `),Et=i(T,"CODE",{});var nl=r(Et);wa=a(nl,"vertical"),nl.forEach(t),Ea=a(T,", because this is the default projection for lists."),T.forEach(t),hn=f(e),ie=i(e,"PRE",{class:!0});var Ql=r(ie);Ql.forEach(t),kn=f(e),Ee(K.$$.fragment,e),yn=f(e),xe=i(e,"A",{name:!0}),r(xe).forEach(t),mn=f(e),Ae=i(e,"H2",{});var sl=r(Ae);_a=a(sl,"Tables"),sl.forEach(t),wn=f(e),He=i(e,"P",{});var al=r(He);ba=a(al,`If a property is a list, you can choose to project it as a table. Tables can be either row or column based.
Row based means that each element of the list is displayed in a row. Column based, obviously, means that
each element is displayed in a single column. The default is row based.`),al.forEach(t),En=f(e),Ne=i(e,"P",{});var ol=r(Ne);va=a(ol,"Defining a table is a two-step process."),ol.forEach(t),_n=f(e),U=i(e,"OL",{});var ts=r(U);L=i(ts,"LI",{});var g=r(L);$a=a(g,"Add the keyword "),_t=i(g,"CODE",{});var ll=r(_t);ja=a(ll,"table"),ll.forEach(t),Pa=a(g,` to the list property that
you want to display as a table. Optionally, add one of the keywords `),bt=i(g,"CODE",{});var pl=r(bt);Oa=a(pl,"rows"),pl.forEach(t),Ta=a(g," or "),vt=i(g,"CODE",{});var il=r(vt);Ca=a(il,"columns"),il.forEach(t),Da=a(g,"."),g.forEach(t),Ia=f(ts),$t=i(ts,"LI",{});var rl=r($t);La=a(rl,`Add a table-projection to the type of the property. The table-projection defines
the headers of the table and which parts of the list elements are displayed in which row or column.`),rl.forEach(t),ts.forEach(t),bn=f(e),Ee(J.$$.fragment,e),vn=f(e),R=i(e,"P",{});var Ke=r(R);xa=a(Ke,"For example, to project the "),jt=i(Ke,"CODE",{});var cl=r(jt);Aa=a(cl,"parts"),cl.forEach(t),Ha=a(Ke," property of concept "),Pt=i(Ke,"CODE",{});var ul=r(Pt);Na=a(ul,"BaseProduct"),ul.forEach(t),Ra=a(Ke," as a row based table, you can use the following code."),Ke.forEach(t),$n=f(e),re=i(e,"PRE",{class:!0});var Vl=r(re);Vl.forEach(t),jn=f(e),M=i(e,"P",{});var Ue=r(M);Ma=a(Ue,"Given the above example, there should also be a projection tagged "),Ot=i(Ue,"CODE",{});var dl=r(Ot);Ba=a(dl,"table"),dl.forEach(t),za=a(Ue," for the concept "),Tt=i(Ue,"CODE",{});var fl=r(Tt);Wa=a(fl,"InsurancePart"),fl.forEach(t),Sa=a(Ue,`.
Below four columns/rows are defined, each with its own header.`),Ue.forEach(t),Pn=f(e),ce=i(e,"PRE",{class:!0});var Xl=r(ce);Xl.forEach(t),On=f(e),Ee(Q.$$.fragment,e),Tn=f(e),Ee(V.$$.fragment,e),Cn=f(e),Re=i(e,"H2",{});var hl=r(Re);Fa=a(hl,"Optional Projections"),hl.forEach(t),Dn=f(e),B=i(e,"P",{});var Je=r(B);Ya=a(Je,"When a property is marked optional in the language structure definition (the "),Ct=i(Je,"CODE",{});var kl=r(Ct);Ga=a(kl,".ast"),kl.forEach(t),qa=a(Je,` files), the projection
of this property should also be optional. This is indicated by `),Dt=i(Je,"CODE",{});var yl=r(Dt);Ka=a(yl,"[?"),yl.forEach(t),Ua=a(Je,"."),Je.forEach(t),In=f(e),P=i(e,"P",{});var z=r(P);Ja=a(z,"In the next example both the property "),It=i(z,"CODE",{});var ml=r(It);Qa=a(ml,"riskAdjustment"),ml.forEach(t),Va=a(z," and "),Lt=i(z,"CODE",{});var wl=r(Lt);Xa=a(wl,"helpers"),wl.forEach(t),Za=a(z,` are only shown if they are present.
If they are not present, respectively the text `),xt=i(z,"CODE",{});var El=r(xt);ga=a(El,"Risk adjusted by ="),El.forEach(t),eo=a(z," or "),At=i(z,"CODE",{});var _l=r(At);to=a(_l,"Helper functions:"),_l.forEach(t),no=a(z," is omitted as well."),z.forEach(t),Ln=f(e),ue=i(e,"PRE",{class:!0});var Zl=r(ue);Zl.forEach(t),xn=f(e),Me=i(e,"P",{});var bl=r(Me);so=a(bl,"Note that optional projections for non-optional properties are not allowed."),bl.forEach(t),An=f(e),Be=i(e,"A",{name:!0}),r(Be).forEach(t),Hn=f(e),ze=i(e,"H2",{});var vl=r(ze);ao=a(vl,"Boolean Keyword Projections"),vl.forEach(t),Nn=f(e),D=i(e,"P",{});var ee=r(D);oo=a(ee,"The next example shows the special manner in which properties of type "),Ht=i(ee,"STRONG",{});var $l=r(Ht);lo=a($l,"boolean"),$l.forEach(t),po=a(ee,` can be
projected. The concept `),Nt=i(ee,"CODE",{});var jl=r(Nt);io=a(jl,"Entity"),jl.forEach(t),ro=a(ee," has a simple property of type boolean called "),Rt=i(ee,"CODE",{});var Pl=r(Rt);co=a(Pl,"isCompany"),Pl.forEach(t),uo=a(ee,`. Normally,
its value would be displayed according to the boolean keyword projection in the default editor.`),ee.forEach(t),Rn=f(e),de=i(e,"PRE",{class:!0});var gl=r(de);gl.forEach(t),Mn=f(e),fe=i(e,"PRE",{class:!0});var ep=r(fe);ep.forEach(t),Bn=f(e),$=i(e,"P",{});var I=r($);fo=a(I,"By defining that the property must be represented by a "),Mt=i(I,"STRONG",{});var Ol=r(Mt);ho=a(Ol,"keyword"),Ol.forEach(t),ko=a(I,`, we can change the default.
In the next example, the property `),Bt=i(I,"CODE",{});var Tl=r(Bt);yo=a(Tl,"isCompany"),Tl.forEach(t),mo=a(I," will be shown as the keyword "),zt=i(I,"CODE",{});var Cl=r(zt);wo=a(Cl,"COMPANY"),Cl.forEach(t),Eo=a(I,`. When the value
of the property is `),Wt=i(I,"CODE",{});var Dl=r(Wt);_o=a(Dl,"true"),Dl.forEach(t),bo=a(I,", the keyword is shown. When the value is "),St=i(I,"CODE",{});var Il=r(St);vo=a(Il,"false"),Il.forEach(t),$o=a(I,", the keyword is not shown."),I.forEach(t),zn=f(e),he=i(e,"PRE",{class:!0});var tp=r(he);tp.forEach(t),Wn=f(e),We=i(e,"P",{});var Ll=r(We);jo=a(Ll,"This example would be displayed as one of \u2026"),Ll.forEach(t),Sn=f(e),ke=i(e,"PRE",{class:!0});var np=r(ke);np.forEach(t),Fn=f(e),X=i(e,"P",{});var ns=r(X);Po=a(ns,"Another way to display boolean properties is to use "),Ft=i(ns,"STRONG",{});var xl=r(Ft);Oo=a(xl,"two"),xl.forEach(t),To=a(ns,` keywords. Depending on
the value of the property either the first or second keyword is shown.`),ns.forEach(t),Yn=f(e),ye=i(e,"PRE",{class:!0});var sp=r(ye);sp.forEach(t),Gn=f(e),Se=i(e,"P",{});var Al=r(Se);Co=a(Al,"This would be displayed as one of \u2026"),Al.forEach(t),qn=f(e),me=i(e,"PRE",{class:!0});var ap=r(me);ap.forEach(t),Kn=f(e),Ee(Z.$$.fragment,e),this.h()},h(){v(te,"class","language-ts"),v(ne,"class","language-ts"),v(at,"name","named_projection"),v(Te,"href","/030_Developing_a_Language/020_Definition_Level/010_Editor_Definition/010_Edit_Files#ordering"),v(ae,"class","language-ts"),v(De,"href","/030_Developing_a_Language/020_Definition_Level/010_Editor_Definition/020_Projections#tables"),v(ie,"class","language-ts"),v(xe,"name","tables"),v(re,"class","language-ts"),v(ce,"class","language-ts"),v(ue,"class","language-ts"),v(Be,"name","booleans"),v(de,"class","language-ts"),v(fe,"class","language-ts"),v(he,"class","language-ts"),v(ke,"class","language-undefined"),v(ye,"class","language-ts"),v(me,"class","language-undefined")},m(e,o){l(e,u,o),n(u,c),l(e,k,o),l(e,y,o),n(y,h),n(y,m),n(m,W),n(y,E),n(y,j),n(j,Pe),n(y,ss),n(y,Qe),n(Qe,as),n(y,os),n(y,Ve),n(Ve,ls),n(y,ps),l(e,Jt,o),l(e,te,o),te.innerHTML=Hl,l(e,Qt,o),l(e,Oe,o),n(Oe,is),l(e,Vt,o),l(e,S,o),n(S,rs),n(S,Xe),n(Xe,cs),n(S,us),l(e,Xt,o),l(e,_,o),n(_,ds),n(_,Ze),n(Ze,fs),n(_,hs),n(_,ge),n(ge,ks),n(_,ys),n(_,et),n(et,ms),n(_,ws),n(_,tt),n(tt,Es),n(_,_s),n(_,nt),n(nt,bs),n(_,vs),n(_,st),n(st,$s),n(_,js),l(e,Zt,o),l(e,ne,o),ne.innerHTML=Nl,l(e,gt,o),_e(F,e,o),l(e,en,o),_e(Y,e,o),l(e,tn,o),l(e,se,o),n(se,at),n(se,Ps),l(e,nn,o),l(e,G,o),n(G,Os),n(G,Te),n(Te,Ts),n(G,Cs),l(e,sn,o),l(e,q,o),n(q,Ds),n(q,ot),n(ot,Is),n(q,Ls),l(e,an,o),l(e,x,o),n(x,xs),n(x,lt),n(lt,As),n(x,Hs),n(x,pt),n(pt,Ns),n(x,Rs),l(e,on,o),l(e,ae,o),ae.innerHTML=Rl,l(e,ln,o),l(e,Ce,o),n(Ce,Ms),l(e,pn,o),l(e,A,o),n(A,Bs),n(A,it),n(it,zs),n(A,Ws),n(A,rt),n(rt,Ss),n(A,Fs),l(e,rn,o),l(e,H,o),n(H,Ys),n(H,De),n(De,Gs),n(H,qs),n(H,ct),n(ct,Ks),n(H,Us),l(e,cn,o),l(e,Ie,o),n(Ie,Js),l(e,un,o),l(e,N,o),n(N,oe),n(oe,Qs),n(oe,ut),n(ut,Vs),n(oe,Xs),n(N,Zs),n(N,le),n(le,gs),n(le,dt),n(dt,ea),n(le,ta),n(N,na),n(N,pe),n(pe,sa),n(pe,ft),n(ft,aa),n(pe,oa),l(e,dn,o),l(e,Le,o),n(Le,la),l(e,fn,o),l(e,b,o),n(b,pa),n(b,ht),n(ht,ia),n(b,ra),n(b,kt),n(kt,ca),n(b,ua),n(b,yt),n(yt,da),n(b,fa),n(b,mt),n(mt,ha),n(b,ka),n(b,wt),n(wt,ya),n(b,ma),n(b,Et),n(Et,wa),n(b,Ea),l(e,hn,o),l(e,ie,o),ie.innerHTML=Ml,l(e,kn,o),_e(K,e,o),l(e,yn,o),l(e,xe,o),l(e,mn,o),l(e,Ae,o),n(Ae,_a),l(e,wn,o),l(e,He,o),n(He,ba),l(e,En,o),l(e,Ne,o),n(Ne,va),l(e,_n,o),l(e,U,o),n(U,L),n(L,$a),n(L,_t),n(_t,ja),n(L,Pa),n(L,bt),n(bt,Oa),n(L,Ta),n(L,vt),n(vt,Ca),n(L,Da),n(U,Ia),n(U,$t),n($t,La),l(e,bn,o),_e(J,e,o),l(e,vn,o),l(e,R,o),n(R,xa),n(R,jt),n(jt,Aa),n(R,Ha),n(R,Pt),n(Pt,Na),n(R,Ra),l(e,$n,o),l(e,re,o),re.innerHTML=Bl,l(e,jn,o),l(e,M,o),n(M,Ma),n(M,Ot),n(Ot,Ba),n(M,za),n(M,Tt),n(Tt,Wa),n(M,Sa),l(e,Pn,o),l(e,ce,o),ce.innerHTML=zl,l(e,On,o),_e(Q,e,o),l(e,Tn,o),_e(V,e,o),l(e,Cn,o),l(e,Re,o),n(Re,Fa),l(e,Dn,o),l(e,B,o),n(B,Ya),n(B,Ct),n(Ct,Ga),n(B,qa),n(B,Dt),n(Dt,Ka),n(B,Ua),l(e,In,o),l(e,P,o),n(P,Ja),n(P,It),n(It,Qa),n(P,Va),n(P,Lt),n(Lt,Xa),n(P,Za),n(P,xt),n(xt,ga),n(P,eo),n(P,At),n(At,to),n(P,no),l(e,Ln,o),l(e,ue,o),ue.innerHTML=Wl,l(e,xn,o),l(e,Me,o),n(Me,so),l(e,An,o),l(e,Be,o),l(e,Hn,o),l(e,ze,o),n(ze,ao),l(e,Nn,o),l(e,D,o),n(D,oo),n(D,Ht),n(Ht,lo),n(D,po),n(D,Nt),n(Nt,io),n(D,ro),n(D,Rt),n(Rt,co),n(D,uo),l(e,Rn,o),l(e,de,o),de.innerHTML=Sl,l(e,Mn,o),l(e,fe,o),fe.innerHTML=Fl,l(e,Bn,o),l(e,$,o),n($,fo),n($,Mt),n(Mt,ho),n($,ko),n($,Bt),n(Bt,yo),n($,mo),n($,zt),n(zt,wo),n($,Eo),n($,Wt),n(Wt,_o),n($,bo),n($,St),n(St,vo),n($,$o),l(e,zn,o),l(e,he,o),he.innerHTML=Yl,l(e,Wn,o),l(e,We,o),n(We,jo),l(e,Sn,o),l(e,ke,o),ke.innerHTML=Gl,l(e,Fn,o),l(e,X,o),n(X,Po),n(X,Ft),n(Ft,Oo),n(X,To),l(e,Yn,o),l(e,ye,o),ye.innerHTML=ql,l(e,Gn,o),l(e,Se,o),n(Se,Co),l(e,qn,o),l(e,me,o),me.innerHTML=Kl,l(e,Kn,o),_e(Z,e,o),Un=!0},p(e,[o]){const C={};o&2&&(C.$$scope={dirty:o,ctx:e}),F.$set(C);const Yt={};o&2&&(Yt.$$scope={dirty:o,ctx:e}),Y.$set(Yt);const Gt={};o&2&&(Gt.$$scope={dirty:o,ctx:e}),K.$set(Gt);const qt={};o&2&&(qt.$$scope={dirty:o,ctx:e}),J.$set(qt);const Kt={};o&2&&(Kt.$$scope={dirty:o,ctx:e}),Q.$set(Kt);const Jn={};o&2&&(Jn.$$scope={dirty:o,ctx:e}),V.$set(Jn);const Ut={};o&2&&(Ut.$$scope={dirty:o,ctx:e}),Z.$set(Ut)},i(e){Un||(be(F.$$.fragment,e),be(Y.$$.fragment,e),be(K.$$.fragment,e),be(J.$$.fragment,e),be(Q.$$.fragment,e),be(V.$$.fragment,e),be(Z.$$.fragment,e),Un=!0)},o(e){ve(F.$$.fragment,e),ve(Y.$$.fragment,e),ve(K.$$.fragment,e),ve(J.$$.fragment,e),ve(Q.$$.fragment,e),ve(V.$$.fragment,e),ve(Z.$$.fragment,e),Un=!1},d(e){e&&t(u),e&&t(k),e&&t(y),e&&t(Jt),e&&t(te),e&&t(Qt),e&&t(Oe),e&&t(Vt),e&&t(S),e&&t(Xt),e&&t(_),e&&t(Zt),e&&t(ne),e&&t(gt),$e(F,e),e&&t(en),$e(Y,e),e&&t(tn),e&&t(se),e&&t(nn),e&&t(G),e&&t(sn),e&&t(q),e&&t(an),e&&t(x),e&&t(on),e&&t(ae),e&&t(ln),e&&t(Ce),e&&t(pn),e&&t(A),e&&t(rn),e&&t(H),e&&t(cn),e&&t(Ie),e&&t(un),e&&t(N),e&&t(dn),e&&t(Le),e&&t(fn),e&&t(b),e&&t(hn),e&&t(ie),e&&t(kn),$e(K,e),e&&t(yn),e&&t(xe),e&&t(mn),e&&t(Ae),e&&t(wn),e&&t(He),e&&t(En),e&&t(Ne),e&&t(_n),e&&t(U),e&&t(bn),$e(J,e),e&&t(vn),e&&t(R),e&&t($n),e&&t(re),e&&t(jn),e&&t(M),e&&t(Pn),e&&t(ce),e&&t(On),$e(Q,e),e&&t(Tn),$e(V,e),e&&t(Cn),e&&t(Re),e&&t(Dn),e&&t(B),e&&t(In),e&&t(P),e&&t(Ln),e&&t(ue),e&&t(xn),e&&t(Me),e&&t(An),e&&t(Be),e&&t(Hn),e&&t(ze),e&&t(Nn),e&&t(D),e&&t(Rn),e&&t(de),e&&t(Mn),e&&t(fe),e&&t(Bn),e&&t($),e&&t(zn),e&&t(he),e&&t(Wn),e&&t(We),e&&t(Sn),e&&t(ke),e&&t(Fn),e&&t(X),e&&t(Yn),e&&t(ye),e&&t(Gn),e&&t(Se),e&&t(qn),e&&t(me),e&&t(Kn),$e(Z,e)}}}function vp(w){return[]}class Op extends op{constructor(u){super();lp(this,u,vp,bp,pp,{})}}export{Op as default};
