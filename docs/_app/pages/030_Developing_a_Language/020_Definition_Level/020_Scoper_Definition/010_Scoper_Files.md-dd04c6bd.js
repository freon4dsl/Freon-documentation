import{S as qe,i as ze,s as Ye,e as l,t as o,k as m,w as Ge,c as p,a as c,h as i,d as t,m as d,x as Je,b as g,g as a,H as s,y as Ke,q as Qe,o as Ue,B as Ve}from"../../../../chunks/vendor-0dc77bd0.js";import{N as We}from"../../../../chunks/Note-b0db7989.js";/* empty css                                                            */function Xe(j){let r;return{c(){r=o("Each model unit is a namespace.")},l(u){r=i(u,"Each model unit is a namespace.")},m(u,_){a(u,r,_)},d(u){u&&t(r)}}}function Ze(j){let r;return{c(){r=o("On all Levels of Customizations model units are always considered to be namespaces.")},l(u){r=i(u,"On all Levels of Customizations model units are always considered to be namespaces.")},m(u,_){a(u,r,_)},d(u){u&&t(r)}}}function ge(j){let r,u,_,T,ee,B,$,te,F,h,ne,C,se,ae,S,oe,ie,q,E,Oe=`<code class="language-ts"><span class="token comment">// docu-project/defs/scoper-docu.scope#L3-L3</span>

isnamespace <span class="token punctuation">&#123;</span> InsuranceProduct<span class="token punctuation">,</span> BaseProduct<span class="token punctuation">,</span> CalcFunction<span class="token punctuation">,</span> Entity <span class="token punctuation">&#125;</span></code>`,z,x,le,Y,b,G,L,pe,J,f,ce,H,re,ue,O,fe,me,R,de,he,D,ye,_e,K,k,Re=`<code class="language-ts"><span class="token comment">// docu-project/defs/language-extras.ast#L34-L38</span>

concept Entity <span class="token punctuation">&#123;</span>
    isCompany<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    reference baseEntity<span class="token operator">?</span><span class="token operator">:</span> Entity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Q,w,De=`<code class="language-ts"><span class="token comment">// docu-project/defs/scoper-docu.scope#L13-L15</span>

Entity <span class="token punctuation">&#123;</span>
    namespace_addition <span class="token operator">=</span> self<span class="token punctuation">.</span>baseEntity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,U,I,be,V,v,ve,N,Ee,ke,W,A,Ne=`<code class="language-ts"><span class="token comment">// docu-project/defs/scoper-docu.scope#L9-L11</span>

AttributeRef <span class="token punctuation">&#123;</span>
	scope <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span> container <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,X;return b=new We({props:{$$slots:{content:[Ze],header:[Xe]},$$scope:{ctx:j}}}),{c(){r=l("h1"),u=o("The Scoper Definition Files"),_=m(),T=l("p"),ee=o(`In the scoper definition you provide the information necessary to determine which names are visible from a certain
element of your user\u2019s model.`),B=m(),$=l("h2"),te=o("Namespaces"),F=m(),h=l("p"),ne=o("In the scoper definition you can mark a list of concepts to be "),C=l("strong"),se=o("namespaces"),ae=o(". Any "),S=l("em"),oe=o("namespace"),ie=o(` has its own
set of visible names. Any namespace shadows the visible names from its surrounding namespace (using lexical scope).
The default scoper simply regards the model of your user as the only namespace.`),q=m(),E=l("pre"),z=m(),x=l("p"),le=o(`Interfaces can be namespaces as well.
Any instance of a concept that implements the namespace interface is a
namespace, but only the properties of the interface will be visible.`),Y=m(),Ge(b.$$.fragment),G=m(),L=l("h2"),pe=o("Namespace Additions"),J=m(),f=l("p"),ce=o(`The standard namespaces can be added to. In that case, the visible elements from the addition are included.
By indicating an addition to a namespace you can, for instance, support inheritance. In the following example,
`),H=l("code"),re=o("baseEntity"),ue=o(" is in the language structure definition ("),O=l("code"),fe=o(".ast"),me=o(` file) defined to be the
super type of the `),R=l("code"),de=o("Entity"),he=o(" concept. The names visible in the "),D=l("code"),ye=o("baseEntity"),_e=o(`
are included in the namespace by defining the namespace-addition.`),K=m(),k=l("pre"),Q=m(),w=l("pre"),U=m(),I=l("h2"),be=o("Alternative Scopes"),V=m(),v=l("p"),ve=o(`You can also indicate that a different namespace altogether should be used. In the following example,
the elements visible in
an `),N=l("code"),Ee=o("AttributeRef"),ke=o(" are determined based on the type of its container, i.e. the type of its parent in the AST."),W=m(),A=l("pre"),this.h()},l(e){r=p(e,"H1",{});var n=c(r);u=i(n,"The Scoper Definition Files"),n.forEach(t),_=d(e),T=p(e,"P",{});var M=c(T);ee=i(M,`In the scoper definition you provide the information necessary to determine which names are visible from a certain
element of your user\u2019s model.`),M.forEach(t),B=d(e),$=p(e,"H2",{});var we=c($);te=i(we,"Namespaces"),we.forEach(t),F=d(e),h=p(e,"P",{});var P=c(h);ne=i(P,"In the scoper definition you can mark a list of concepts to be "),C=p(P,"STRONG",{});var Ae=c(C);se=i(Ae,"namespaces"),Ae.forEach(t),ae=i(P,". Any "),S=p(P,"EM",{});var Te=c(S);oe=i(Te,"namespace"),Te.forEach(t),ie=i(P,` has its own
set of visible names. Any namespace shadows the visible names from its surrounding namespace (using lexical scope).
The default scoper simply regards the model of your user as the only namespace.`),P.forEach(t),q=d(e),E=p(e,"PRE",{class:!0});var Me=c(E);Me.forEach(t),z=d(e),x=p(e,"P",{});var $e=c(x);le=i($e,`Interfaces can be namespaces as well.
Any instance of a concept that implements the namespace interface is a
namespace, but only the properties of the interface will be visible.`),$e.forEach(t),Y=d(e),Je(b.$$.fragment,e),G=d(e),L=p(e,"H2",{});var xe=c(L);pe=i(xe,"Namespace Additions"),xe.forEach(t),J=d(e),f=p(e,"P",{});var y=c(f);ce=i(y,`The standard namespaces can be added to. In that case, the visible elements from the addition are included.
By indicating an addition to a namespace you can, for instance, support inheritance. In the following example,
`),H=p(y,"CODE",{});var Le=c(H);re=i(Le,"baseEntity"),Le.forEach(t),ue=i(y," is in the language structure definition ("),O=p(y,"CODE",{});var Ie=c(O);fe=i(Ie,".ast"),Ie.forEach(t),me=i(y,` file) defined to be the
super type of the `),R=p(y,"CODE",{});var Pe=c(R);de=i(Pe,"Entity"),Pe.forEach(t),he=i(y," concept. The names visible in the "),D=p(y,"CODE",{});var Ce=c(D);ye=i(Ce,"baseEntity"),Ce.forEach(t),_e=i(y,`
are included in the namespace by defining the namespace-addition.`),y.forEach(t),K=d(e),k=p(e,"PRE",{class:!0});var je=c(k);je.forEach(t),Q=d(e),w=p(e,"PRE",{class:!0});var Be=c(w);Be.forEach(t),U=d(e),I=p(e,"H2",{});var Se=c(I);be=i(Se,"Alternative Scopes"),Se.forEach(t),V=d(e),v=p(e,"P",{});var Z=c(v);ve=i(Z,`You can also indicate that a different namespace altogether should be used. In the following example,
the elements visible in
an `),N=p(Z,"CODE",{});var He=c(N);Ee=i(He,"AttributeRef"),He.forEach(t),ke=i(Z," are determined based on the type of its container, i.e. the type of its parent in the AST."),Z.forEach(t),W=d(e),A=p(e,"PRE",{class:!0});var Fe=c(A);Fe.forEach(t),this.h()},h(){g(E,"class","language-ts"),g(k,"class","language-ts"),g(w,"class","language-ts"),g(A,"class","language-ts")},m(e,n){a(e,r,n),s(r,u),a(e,_,n),a(e,T,n),s(T,ee),a(e,B,n),a(e,$,n),s($,te),a(e,F,n),a(e,h,n),s(h,ne),s(h,C),s(C,se),s(h,ae),s(h,S),s(S,oe),s(h,ie),a(e,q,n),a(e,E,n),E.innerHTML=Oe,a(e,z,n),a(e,x,n),s(x,le),a(e,Y,n),Ke(b,e,n),a(e,G,n),a(e,L,n),s(L,pe),a(e,J,n),a(e,f,n),s(f,ce),s(f,H),s(H,re),s(f,ue),s(f,O),s(O,fe),s(f,me),s(f,R),s(R,de),s(f,he),s(f,D),s(D,ye),s(f,_e),a(e,K,n),a(e,k,n),k.innerHTML=Re,a(e,Q,n),a(e,w,n),w.innerHTML=De,a(e,U,n),a(e,I,n),s(I,be),a(e,V,n),a(e,v,n),s(v,ve),s(v,N),s(N,Ee),s(v,ke),a(e,W,n),a(e,A,n),A.innerHTML=Ne,X=!0},p(e,[n]){const M={};n&1&&(M.$$scope={dirty:n,ctx:e}),b.$set(M)},i(e){X||(Qe(b.$$.fragment,e),X=!0)},o(e){Ue(b.$$.fragment,e),X=!1},d(e){e&&t(r),e&&t(_),e&&t(T),e&&t(B),e&&t($),e&&t(F),e&&t(h),e&&t(q),e&&t(E),e&&t(z),e&&t(x),e&&t(Y),Ve(b,e),e&&t(G),e&&t(L),e&&t(J),e&&t(f),e&&t(K),e&&t(k),e&&t(Q),e&&t(w),e&&t(U),e&&t(I),e&&t(V),e&&t(v),e&&t(W),e&&t(A)}}}class st extends qe{constructor(r){super();ze(this,r,null,ge,Ye,{})}}export{st as default};
