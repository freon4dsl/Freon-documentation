import{S as dl,i as hl,s as _l,e as l,t as a,k as c,j as Ro,c as i,a as p,g as s,d as t,n as u,m as Uo,b as f,f as r,F as n,o as Bo,x as jo,u as Fo,v as No}from"../../../chunks/vendor-0216fdcb.js";import{N as Vo}from"../../../chunks/Note-1a08578a.js";/* empty css                                                         */function El(U){let m;return{c(){m=a("Models are never explicit in an editor")},l(d){m=s(d,"Models are never explicit in an editor")},m(d,x){r(d,m,x)},d(d){d&&t(m)}}}function kl(U){let m;return{c(){m=a(`The model is never shown in an editor as a whole. 
It is always shown in parts: the model units. However, the webapp does 'show' the model and the units, that are
part of it, in its left panel.`)},l(d){m=s(d,`The model is never shown in an editor as a whole. 
It is always shown in parts: the model units. However, the webapp does 'show' the model and the units, that are
part of it, in its left panel.`)},m(d,x){r(d,m,x)},d(d){d&&t(m)}}}function yl(U){let m;return{c(){m=a("No quotes around numbers and booleans.")},l(d){m=s(d,"No quotes around numbers and booleans.")},m(d,x){r(d,m,x)},d(d){d&&t(m)}}}function vl(U){let m;return{c(){m=a(`Quotes (double or single) are not allowed around the values of properties of
instances of limited concepts, for number and boolean types`)},l(d){m=s(d,`Quotes (double or single) are not allowed around the values of properties of
instances of limited concepts, for number and boolean types`)},m(d,x){r(d,m,x)},d(d){d&&t(m)}}}function bl(U){let m,d,x,g,_n,Pe,En,kn,Ce,yn,vn,kt,se,bn,yt,E,Ln,oe,xn,wn,le,Mn,gn,ie,An,Dn,pe,Pn,Cn,re,Tn,In,ce,$n,Sn,ue,Hn,On,vt,B,Te,Rn,bt,C,Un,Ie,Bn,jn,Lt,T,xt,j,qo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L3-L7</span>

model EntityModel <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    units<span class="token operator">:</span> EntityModelUnit<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    extraUnit<span class="token operator">:</span> SomeOtherModelUnit<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,wt,F,$e,Fn,Mt,A,Nn,Se,Vn,qn,fe,Qn,Wn,gt,me,Yn,At,N,Qo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L56-L61</span>

modelunit EntityModelUnit <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>

    functions<span class="token operator">:</span> EntityFunction<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    entities<span class="token operator">:</span> Entity<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Dt,V,He,Gn,Pt,I,zn,Oe,Jn,Kn,Ct,de,Xn,Tt,q,Wo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L26-L32</span>

concept Entity <span class="token keyword">implements</span> <span class="token class-name">Type</span> <span class="token punctuation">&#123;</span>
    isCompany<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    attributes<span class="token operator">:</span> AttributeWithLimitedType<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    entAttributes<span class="token operator">:</span> AttributeWithEntityType<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    functions<span class="token operator">:</span> EntityFunction<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    reference baseEntity<span class="token operator">?</span><span class="token operator">:</span> Entity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,It,Q,Re,Zn,$t,$,ea,Ue,ta,na,St,he,aa,Ht,W,Yo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L48-L50</span>

expression AbsExpression base EntityExpression <span class="token punctuation">&#123;</span>
    expr<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Ot,Y,Be,sa,Rt,k,oa,je,la,ia,Fe,pa,ra,Ne,ca,ua,Ve,fa,ma,qe,da,ha,Ut,D,_a,_e,Ea,ka,Ee,ya,va,Bt,ke,ba,jt,G,Go=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L118-L121</span>

<span class="token keyword">abstract</span> binary expression BinaryExpression base EntityExpression <span class="token punctuation">&#123;</span>
    left<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
    right<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Ft,z,Qe,La,Nt,S,xa,We,wa,Ma,Vt,ye,ga,qt,ve,Aa,Qt,J,zo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L34-L46</span>

limited AttributeType <span class="token keyword">implements</span> <span class="token class-name">BaseType</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// if the 'name' property was not provided, it would have been generated</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    extra<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    String <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span> <span class="token string">"extra"</span><span class="token operator">:</span> <span class="token number">199</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// notations 'name:' and '"name":' are both correct</span>
    Integer <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"Integer"</span><span class="token punctuation">,</span> <span class="token string">"extra"</span><span class="token operator">:</span> <span class="token number">240261</span><span class="token punctuation">&#125;</span>
    Boolean <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">"Boolean"</span><span class="token punctuation">,</span> <span class="token string">"extra"</span><span class="token operator">:</span> <span class="token number">5479</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// the following instance gets the name "ANY"</span>
    <span class="token constant">ANY</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">"extra"</span><span class="token operator">:</span> <span class="token number">456</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

limited MockEnumeration <span class="token punctuation">&#123;</span> EnumValue1<span class="token punctuation">;</span> EnumValue2<span class="token punctuation">;</span> EnumValue3<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code>`,Wt,H,Yt,K,Ye,Da,Gt,O,Pa,Ge,Ca,Ta,zt,X,Jo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L14-L17</span>

<span class="token keyword">interface</span> <span class="token class-name">BaseType</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    baseInterface_attr<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Jt,be,Ia,Kt,R,$a,ze,Sa,Ha,Xt,Le,h,Je,Oa,Ra,Ke,Ua,Ba,Xe,ja,Fa,Ze,Na,Va,et,qa,Qa,tt,Wa,Ya,nt,Ga,za,at,Ja,Ka,st,Xa,Za,ot,es,ts,Zt,Z,Ko=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L63-L65</span>

concept EntityFunction <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    aliases<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code>`,en,xe,b,lt,ns,as,it,ss,os,pt,ls,is,rt,ps,rs,ct,cs,us,tn,ee,Xo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L63-L67</span>

concept EntityFunction <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    aliases<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    expression<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
    parameters<span class="token operator">:</span> Variable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code>`,nn,we,y,ut,fs,ms,ft,ds,hs,mt,_s,Es,dt,ks,ys,ht,vs,bs,_t,Ls,xs,an,te,Zo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L101-L101</span>

reference variable<span class="token operator">:</span> Variable<span class="token punctuation">;</span></code>`,sn,ne,el=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L83-L84</span>

concept Variable <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span></code>`,on,Me,ws,ln,ge,Ms,pn,ae,tl=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L14-L17</span>

<span class="token keyword">interface</span> <span class="token class-name">BaseType</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    baseInterface_attr<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,rn;return T=new Vo({props:{$$slots:{content:[kl],header:[El]},$$scope:{ctx:U}}}),H=new Vo({props:{$$slots:{content:[vl],header:[yl]},$$scope:{ctx:U}}}),{c(){m=l("h1"),d=a("The Language Structure Definition"),x=c(),g=l("p"),_n=a("The abstract syntax tree (AST) of the language is described in files with the extension "),Pe=l("code"),En=a(".ast"),kn=a(`.
All files with this extension in the `),Ce=l("em"),yn=a("defs"),vn=a(` folder (i.e. the folder were you keep your definition files)
are combined into one AST definition.`),kt=c(),se=l("h2"),bn=a("Concepts"),yt=c(),E=l("p"),Ln=a(`The ProjectIt language structure, which describes the abstract syntax tree (AST), consists of a
list of a `),oe=l("a"),xn=a("Models"),wn=a(`,
`),le=l("a"),Mn=a("Model Units"),gn=a(`,
`),ie=l("a"),An=a("Concepts"),Dn=a(`,
`),pe=l("a"),Pn=a("Expression Concepts"),Cn=a(`,
`),re=l("a"),Tn=a("Binary Expression Concepts"),In=a(`,
`),ce=l("a"),$n=a("Limited Concepts"),Sn=a(`,
and/or `),ue=l("a"),Hn=a("Interfaces"),On=a("."),vt=c(),B=l("h3"),Te=l("a"),Rn=a(" Model"),bt=c(),C=l("p"),Un=a("A "),Ie=l("em"),Bn=a("model"),jn=a(` is the root of the abstract syntax tree, and as such the complete description specified by the user.
It may hold any number of model units as children. These model units may be of different type. For instance, you
can have model units that define the items in a home automation system, and other model units that define the rules
that apply in this system.`),Lt=c(),Ro(T.$$.fragment),xt=c(),j=l("pre"),wt=c(),F=l("h3"),$e=l("a"),Fn=a(" Model unit"),Mt=c(),A=l("p"),Nn=a("A "),Se=l("em"),Vn=a("model unit"),qn=a(` is a part of the model that can be edited independently of the rest of the model. A model unit is
always a direct child of a model. The name of a model unit must always be `),fe=l("a"),Qn=a("public"),Wn=a("."),gt=c(),me=l("p"),Yn=a("Model units may not extend other units or implement interfaces."),At=c(),N=l("pre"),Dt=c(),V=l("h3"),He=l("a"),Gn=a(" Concept"),Pt=c(),I=l("p"),zn=a("A "),Oe=l("em"),Jn=a("concept"),Kn=a(` is the basic element of your language definition. It defines which instances can be present in
a model created by your users.`),Ct=c(),de=l("p"),Xn=a("Concepts may extend one other concept, and implement multiple interfaces."),Tt=c(),q=l("pre"),It=c(),Q=l("h3"),Re=l("a"),Zn=a(" Expression Concept"),$t=c(),$=l("p"),ea=a("An "),Ue=l("em"),ta=a("expression concept"),na=a(` is a concept that is an expression. The editor will deal with these differently in
order to give your user a more natural editing experience.`),St=c(),he=l("p"),aa=a("Expression concepts may extend one other concept, and implement multiple interfaces."),Ht=c(),W=l("pre"),Ot=c(),Y=l("h3"),Be=l("a"),sa=a(" Binary Expression Concept"),Rt=c(),k=l("p"),oa=a("A "),je=l("em"),la=a("binary expression concept"),ia=a(` is an expression concept that has two sub expressions, left and right operands,
and an operator, which in the concrete syntax usually goes in the middle. For example, the expression `),Fe=l("code"),pa=a("4 + 5"),ra=a(`
has as left operand `),Ne=l("code"),ca=a("4"),ua=a(", as operator "),Ve=l("code"),fa=a("+"),ma=a(", and as right operand "),qe=l("code"),da=a("5"),ha=a("."),Ut=c(),D=l("p"),_a=a(`Any concrete binary expression concept needs to have a priority. The priority is used by ProjectIt to balance the
abstract syntax tree (see `),_e=l("a"),Ea=a("Projectional Editing"),ka=a(`). In
the `),Ee=l("a"),ya=a("second level tutorial"),va=a(` you can
find more information on how to set the operand.`),Bt=c(),ke=l("p"),ba=a("Binary expression concepts may extend one other concept, and implement multiple interfaces."),jt=c(),G=l("pre"),Ft=c(),z=l("h3"),Qe=l("a"),La=a(" Limited Concept"),Nt=c(),S=l("p"),xa=a("A "),We=l("em"),wa=a("limited concept"),Ma=a(` is a concept that has a limited number of predefined instances. Actually, it is an extended
version of an enumeration. All instances become part of the standard library of your language.`),Vt=c(),ye=l("p"),ga=a(`A limited concept must always have a name, but if this is not provided
in the definition then it is automatically created. Furthermore, when a predefined instance does not provide a
value for the name, the name of the instance is used. In this manner, you can define simple enumerations.`),qt=c(),ve=l("p"),Aa=a("Limited concepts may extend one other concept, and implement multiple interfaces."),Qt=c(),J=l("pre"),Wt=c(),Ro(H.$$.fragment),Yt=c(),K=l("h3"),Ye=l("a"),Da=a(" Interface"),Gt=c(),O=l("p"),Pa=a("An "),Ge=l("em"),Ca=a("interface"),Ta=a(" is a concept that has no instances."),zt=c(),X=l("pre"),Jt=c(),be=l("h2"),Ia=a("Properties"),Kt=c(),R=l("p"),$a=a("Each of the language structure elements have "),ze=l("strong"),Sa=a("Properties"),Ha=a(`, of which there are the
following three types.`),Xt=c(),Le=l("ul"),h=l("li"),Je=l("em"),Oa=a("Simple properties"),Ra=a(" have as type "),Ke=l("code"),Ua=a("identifier"),Ba=a(", "),Xe=l("code"),ja=a("string"),Fa=a(", "),Ze=l("code"),Na=a("number"),Va=a(", or "),et=l("code"),qa=a("boolean"),Qa=a(`, and are
always contained in the `),tt=l("em"),Wa=a("concept"),Ya=a(`. Simple properties may also be lists
of `),nt=l("code"),Ga=a("identifier"),za=a(", "),at=l("code"),Ja=a("string"),Ka=a(", "),st=l("code"),Xa=a("number"),Za=a(", or "),ot=l("code"),es=a("boolean"),ts=a("."),Zt=c(),Z=l("pre"),en=c(),xe=l("ul"),b=l("li"),lt=l("em"),ns=a("Parts"),as=a(" have as type one of the "),it=l("em"),ss=a("concepts"),os=a(" (including "),pt=l("em"),ls=a("expression concepts"),is=a(" and "),rt=l("em"),ps=a("limited concepts"),rs=a(`)
in the language, and are `),ct=l("em"),cs=a("contained in the concept"),us=a(` that holds the property (as in
the UML composition relationship). Note that simple properties are always considered to be parts.`),tn=c(),ee=l("pre"),nn=c(),we=l("ul"),y=l("li"),ut=l("em"),fs=a("References"),ms=a(" also have as type one of the "),ft=l("em"),ds=a("concepts"),hs=a(` in the language, but a reference is not contained
in its `),mt=l("em"),_s=a("concept"),Es=a(` (as in the UML association relationship). References are indicated by the keyword
`),dt=l("em"),ks=a("reference"),ys=a(" in front of the definition.References are always by name, therefore the referred concept must have a "),ht=l("code"),vs=a("name"),bs=a(" property of type "),_t=l("code"),Ls=a("identifier"),xs=a("."),an=c(),te=l("pre"),sn=c(),ne=l("pre"),on=c(),Me=l("h3"),ws=a("Optional Properties"),ln=c(),ge=l("p"),Ms=a("Properties may be optional. This is indicated using a question mark after the property name."),pn=c(),ae=l("pre"),this.h()},l(e){m=i(e,"H1",{});var o=p(m);d=s(o,"The Language Structure Definition"),o.forEach(t),x=u(e),g=i(e,"P",{});var P=p(g);_n=s(P,"The abstract syntax tree (AST) of the language is described in files with the extension "),Pe=i(P,"CODE",{});var Et=p(Pe);En=s(Et,".ast"),Et.forEach(t),kn=s(P,`.
All files with this extension in the `),Ce=i(P,"EM",{});var $s=p(Ce);yn=s($s,"defs"),$s.forEach(t),vn=s(P,` folder (i.e. the folder were you keep your definition files)
are combined into one AST definition.`),P.forEach(t),kt=u(e),se=i(e,"H2",{});var Ss=p(se);bn=s(Ss,"Concepts"),Ss.forEach(t),yt=u(e),E=i(e,"P",{});var v=p(E);Ln=s(v,`The ProjectIt language structure, which describes the abstract syntax tree (AST), consists of a
list of a `),oe=i(v,"A",{href:!0});var Hs=p(oe);xn=s(Hs,"Models"),Hs.forEach(t),wn=s(v,`,
`),le=i(v,"A",{href:!0});var Os=p(le);Mn=s(Os,"Model Units"),Os.forEach(t),gn=s(v,`,
`),ie=i(v,"A",{href:!0});var Rs=p(ie);An=s(Rs,"Concepts"),Rs.forEach(t),Dn=s(v,`,
`),pe=i(v,"A",{href:!0});var Us=p(pe);Pn=s(Us,"Expression Concepts"),Us.forEach(t),Cn=s(v,`,
`),re=i(v,"A",{href:!0});var Bs=p(re);Tn=s(Bs,"Binary Expression Concepts"),Bs.forEach(t),In=s(v,`,
`),ce=i(v,"A",{href:!0});var js=p(ce);$n=s(js,"Limited Concepts"),js.forEach(t),Sn=s(v,`,
and/or `),ue=i(v,"A",{href:!0});var Fs=p(ue);Hn=s(Fs,"Interfaces"),Fs.forEach(t),On=s(v,"."),v.forEach(t),vt=u(e),B=i(e,"H3",{});var gs=p(B);Te=i(gs,"A",{name:!0}),p(Te).forEach(t),Rn=s(gs," Model"),gs.forEach(t),bt=u(e),C=i(e,"P",{});var cn=p(C);Un=s(cn,"A "),Ie=i(cn,"EM",{});var Ns=p(Ie);Bn=s(Ns,"model"),Ns.forEach(t),jn=s(cn,` is the root of the abstract syntax tree, and as such the complete description specified by the user.
It may hold any number of model units as children. These model units may be of different type. For instance, you
can have model units that define the items in a home automation system, and other model units that define the rules
that apply in this system.`),cn.forEach(t),Lt=u(e),Uo(T.$$.fragment,e),xt=u(e),j=i(e,"PRE",{class:!0});var nl=p(j);nl.forEach(t),wt=u(e),F=i(e,"H3",{});var As=p(F);$e=i(As,"A",{name:!0}),p($e).forEach(t),Fn=s(As," Model unit"),As.forEach(t),Mt=u(e),A=i(e,"P",{});var Ae=p(A);Nn=s(Ae,"A "),Se=i(Ae,"EM",{});var Vs=p(Se);Vn=s(Vs,"model unit"),Vs.forEach(t),qn=s(Ae,` is a part of the model that can be edited independently of the rest of the model. A model unit is
always a direct child of a model. The name of a model unit must always be `),fe=i(Ae,"A",{href:!0});var qs=p(fe);Qn=s(qs,"public"),qs.forEach(t),Wn=s(Ae,"."),Ae.forEach(t),gt=u(e),me=i(e,"P",{});var Qs=p(me);Yn=s(Qs,"Model units may not extend other units or implement interfaces."),Qs.forEach(t),At=u(e),N=i(e,"PRE",{class:!0});var al=p(N);al.forEach(t),Dt=u(e),V=i(e,"H3",{});var Ds=p(V);He=i(Ds,"A",{name:!0}),p(He).forEach(t),Gn=s(Ds," Concept"),Ds.forEach(t),Pt=u(e),I=i(e,"P",{});var un=p(I);zn=s(un,"A "),Oe=i(un,"EM",{});var Ws=p(Oe);Jn=s(Ws,"concept"),Ws.forEach(t),Kn=s(un,` is the basic element of your language definition. It defines which instances can be present in
a model created by your users.`),un.forEach(t),Ct=u(e),de=i(e,"P",{});var Ys=p(de);Xn=s(Ys,"Concepts may extend one other concept, and implement multiple interfaces."),Ys.forEach(t),Tt=u(e),q=i(e,"PRE",{class:!0});var sl=p(q);sl.forEach(t),It=u(e),Q=i(e,"H3",{});var Ps=p(Q);Re=i(Ps,"A",{name:!0}),p(Re).forEach(t),Zn=s(Ps," Expression Concept"),Ps.forEach(t),$t=u(e),$=i(e,"P",{});var fn=p($);ea=s(fn,"An "),Ue=i(fn,"EM",{});var Gs=p(Ue);ta=s(Gs,"expression concept"),Gs.forEach(t),na=s(fn,` is a concept that is an expression. The editor will deal with these differently in
order to give your user a more natural editing experience.`),fn.forEach(t),St=u(e),he=i(e,"P",{});var zs=p(he);aa=s(zs,"Expression concepts may extend one other concept, and implement multiple interfaces."),zs.forEach(t),Ht=u(e),W=i(e,"PRE",{class:!0});var ol=p(W);ol.forEach(t),Ot=u(e),Y=i(e,"H3",{});var Cs=p(Y);Be=i(Cs,"A",{name:!0}),p(Be).forEach(t),sa=s(Cs," Binary Expression Concept"),Cs.forEach(t),Rt=u(e),k=i(e,"P",{});var w=p(k);oa=s(w,"A "),je=i(w,"EM",{});var Js=p(je);la=s(Js,"binary expression concept"),Js.forEach(t),ia=s(w,` is an expression concept that has two sub expressions, left and right operands,
and an operator, which in the concrete syntax usually goes in the middle. For example, the expression `),Fe=i(w,"CODE",{});var Ks=p(Fe);pa=s(Ks,"4 + 5"),Ks.forEach(t),ra=s(w,`
has as left operand `),Ne=i(w,"CODE",{});var Xs=p(Ne);ca=s(Xs,"4"),Xs.forEach(t),ua=s(w,", as operator "),Ve=i(w,"CODE",{});var Zs=p(Ve);fa=s(Zs,"+"),Zs.forEach(t),ma=s(w,", and as right operand "),qe=i(w,"CODE",{});var eo=p(qe);da=s(eo,"5"),eo.forEach(t),ha=s(w,"."),w.forEach(t),Ut=u(e),D=i(e,"P",{});var De=p(D);_a=s(De,`Any concrete binary expression concept needs to have a priority. The priority is used by ProjectIt to balance the
abstract syntax tree (see `),_e=i(De,"A",{href:!0});var to=p(_e);Ea=s(to,"Projectional Editing"),to.forEach(t),ka=s(De,`). In
the `),Ee=i(De,"A",{href:!0});var no=p(Ee);ya=s(no,"second level tutorial"),no.forEach(t),va=s(De,` you can
find more information on how to set the operand.`),De.forEach(t),Bt=u(e),ke=i(e,"P",{});var ao=p(ke);ba=s(ao,"Binary expression concepts may extend one other concept, and implement multiple interfaces."),ao.forEach(t),jt=u(e),G=i(e,"PRE",{class:!0});var ll=p(G);ll.forEach(t),Ft=u(e),z=i(e,"H3",{});var Ts=p(z);Qe=i(Ts,"A",{name:!0}),p(Qe).forEach(t),La=s(Ts," Limited Concept"),Ts.forEach(t),Nt=u(e),S=i(e,"P",{});var mn=p(S);xa=s(mn,"A "),We=i(mn,"EM",{});var so=p(We);wa=s(so,"limited concept"),so.forEach(t),Ma=s(mn,` is a concept that has a limited number of predefined instances. Actually, it is an extended
version of an enumeration. All instances become part of the standard library of your language.`),mn.forEach(t),Vt=u(e),ye=i(e,"P",{});var oo=p(ye);ga=s(oo,`A limited concept must always have a name, but if this is not provided
in the definition then it is automatically created. Furthermore, when a predefined instance does not provide a
value for the name, the name of the instance is used. In this manner, you can define simple enumerations.`),oo.forEach(t),qt=u(e),ve=i(e,"P",{});var lo=p(ve);Aa=s(lo,"Limited concepts may extend one other concept, and implement multiple interfaces."),lo.forEach(t),Qt=u(e),J=i(e,"PRE",{class:!0});var il=p(J);il.forEach(t),Wt=u(e),Uo(H.$$.fragment,e),Yt=u(e),K=i(e,"H3",{});var Is=p(K);Ye=i(Is,"A",{name:!0}),p(Ye).forEach(t),Da=s(Is," Interface"),Is.forEach(t),Gt=u(e),O=i(e,"P",{});var dn=p(O);Pa=s(dn,"An "),Ge=i(dn,"EM",{});var io=p(Ge);Ca=s(io,"interface"),io.forEach(t),Ta=s(dn," is a concept that has no instances."),dn.forEach(t),zt=u(e),X=i(e,"PRE",{class:!0});var pl=p(X);pl.forEach(t),Jt=u(e),be=i(e,"H2",{});var po=p(be);Ia=s(po,"Properties"),po.forEach(t),Kt=u(e),R=i(e,"P",{});var hn=p(R);$a=s(hn,"Each of the language structure elements have "),ze=i(hn,"STRONG",{});var ro=p(ze);Sa=s(ro,"Properties"),ro.forEach(t),Ha=s(hn,`, of which there are the
following three types.`),hn.forEach(t),Xt=u(e),Le=i(e,"UL",{});var co=p(Le);h=i(co,"LI",{});var _=p(h);Je=i(_,"EM",{});var uo=p(Je);Oa=s(uo,"Simple properties"),uo.forEach(t),Ra=s(_," have as type "),Ke=i(_,"CODE",{});var fo=p(Ke);Ua=s(fo,"identifier"),fo.forEach(t),Ba=s(_,", "),Xe=i(_,"CODE",{});var mo=p(Xe);ja=s(mo,"string"),mo.forEach(t),Fa=s(_,", "),Ze=i(_,"CODE",{});var ho=p(Ze);Na=s(ho,"number"),ho.forEach(t),Va=s(_,", or "),et=i(_,"CODE",{});var _o=p(et);qa=s(_o,"boolean"),_o.forEach(t),Qa=s(_,`, and are
always contained in the `),tt=i(_,"EM",{});var Eo=p(tt);Wa=s(Eo,"concept"),Eo.forEach(t),Ya=s(_,`. Simple properties may also be lists
of `),nt=i(_,"CODE",{});var ko=p(nt);Ga=s(ko,"identifier"),ko.forEach(t),za=s(_,", "),at=i(_,"CODE",{});var yo=p(at);Ja=s(yo,"string"),yo.forEach(t),Ka=s(_,", "),st=i(_,"CODE",{});var vo=p(st);Xa=s(vo,"number"),vo.forEach(t),Za=s(_,", or "),ot=i(_,"CODE",{});var bo=p(ot);es=s(bo,"boolean"),bo.forEach(t),ts=s(_,"."),_.forEach(t),co.forEach(t),Zt=u(e),Z=i(e,"PRE",{class:!0});var rl=p(Z);rl.forEach(t),en=u(e),xe=i(e,"UL",{});var Lo=p(xe);b=i(Lo,"LI",{});var M=p(b);lt=i(M,"EM",{});var xo=p(lt);ns=s(xo,"Parts"),xo.forEach(t),as=s(M," have as type one of the "),it=i(M,"EM",{});var wo=p(it);ss=s(wo,"concepts"),wo.forEach(t),os=s(M," (including "),pt=i(M,"EM",{});var Mo=p(pt);ls=s(Mo,"expression concepts"),Mo.forEach(t),is=s(M," and "),rt=i(M,"EM",{});var go=p(rt);ps=s(go,"limited concepts"),go.forEach(t),rs=s(M,`)
in the language, and are `),ct=i(M,"EM",{});var Ao=p(ct);cs=s(Ao,"contained in the concept"),Ao.forEach(t),us=s(M,` that holds the property (as in
the UML composition relationship). Note that simple properties are always considered to be parts.`),M.forEach(t),Lo.forEach(t),tn=u(e),ee=i(e,"PRE",{class:!0});var cl=p(ee);cl.forEach(t),nn=u(e),we=i(e,"UL",{});var Do=p(we);y=i(Do,"LI",{});var L=p(y);ut=i(L,"EM",{});var Po=p(ut);fs=s(Po,"References"),Po.forEach(t),ms=s(L," also have as type one of the "),ft=i(L,"EM",{});var Co=p(ft);ds=s(Co,"concepts"),Co.forEach(t),hs=s(L,` in the language, but a reference is not contained
in its `),mt=i(L,"EM",{});var To=p(mt);_s=s(To,"concept"),To.forEach(t),Es=s(L,` (as in the UML association relationship). References are indicated by the keyword
`),dt=i(L,"EM",{});var Io=p(dt);ks=s(Io,"reference"),Io.forEach(t),ys=s(L," in front of the definition.References are always by name, therefore the referred concept must have a "),ht=i(L,"CODE",{});var $o=p(ht);vs=s($o,"name"),$o.forEach(t),bs=s(L," property of type "),_t=i(L,"CODE",{});var So=p(_t);Ls=s(So,"identifier"),So.forEach(t),xs=s(L,"."),L.forEach(t),Do.forEach(t),an=u(e),te=i(e,"PRE",{class:!0});var ul=p(te);ul.forEach(t),sn=u(e),ne=i(e,"PRE",{class:!0});var fl=p(ne);fl.forEach(t),on=u(e),Me=i(e,"H3",{});var Ho=p(Me);ws=s(Ho,"Optional Properties"),Ho.forEach(t),ln=u(e),ge=i(e,"P",{});var Oo=p(ge);Ms=s(Oo,"Properties may be optional. This is indicated using a question mark after the property name."),Oo.forEach(t),pn=u(e),ae=i(e,"PRE",{class:!0});var ml=p(ae);ml.forEach(t),this.h()},h(){f(oe,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Model"),f(le,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Model_Unit"),f(ie,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Concept"),f(pe,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Expression_Concept"),f(re,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Binary_Expression_Concept"),f(ce,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Limited_Concept"),f(ue,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Interface"),f(Te,"name","Model"),f(j,"class","language-ts"),f($e,"name","Model_Unit"),f(fe,"href","/010_Intro/030_Models_and_Model_Units#public"),f(N,"class","language-ts"),f(He,"name","Concept"),f(q,"class","language-ts"),f(Re,"name","Expression_Concept"),f(W,"class","language-ts"),f(Be,"name","Binary_Expression_Concept"),f(_e,"href","/010_Intro/010_Projectional_Editing#tree-balancing"),f(Ee,"href","/030_Developing_a_Language/020_ProjectIt_Definition_Level/010_Editor_Definition#operand"),f(G,"class","language-ts"),f(Qe,"name","Limited_Concept"),f(J,"class","language-ts"),f(Ye,"name","Interface"),f(X,"class","language-ts"),f(Z,"class","language-ts"),f(ee,"class","language-ts"),f(te,"class","language-ts"),f(ne,"class","language-ts"),f(ae,"class","language-ts")},m(e,o){r(e,m,o),n(m,d),r(e,x,o),r(e,g,o),n(g,_n),n(g,Pe),n(Pe,En),n(g,kn),n(g,Ce),n(Ce,yn),n(g,vn),r(e,kt,o),r(e,se,o),n(se,bn),r(e,yt,o),r(e,E,o),n(E,Ln),n(E,oe),n(oe,xn),n(E,wn),n(E,le),n(le,Mn),n(E,gn),n(E,ie),n(ie,An),n(E,Dn),n(E,pe),n(pe,Pn),n(E,Cn),n(E,re),n(re,Tn),n(E,In),n(E,ce),n(ce,$n),n(E,Sn),n(E,ue),n(ue,Hn),n(E,On),r(e,vt,o),r(e,B,o),n(B,Te),n(B,Rn),r(e,bt,o),r(e,C,o),n(C,Un),n(C,Ie),n(Ie,Bn),n(C,jn),r(e,Lt,o),Bo(T,e,o),r(e,xt,o),r(e,j,o),j.innerHTML=qo,r(e,wt,o),r(e,F,o),n(F,$e),n(F,Fn),r(e,Mt,o),r(e,A,o),n(A,Nn),n(A,Se),n(Se,Vn),n(A,qn),n(A,fe),n(fe,Qn),n(A,Wn),r(e,gt,o),r(e,me,o),n(me,Yn),r(e,At,o),r(e,N,o),N.innerHTML=Qo,r(e,Dt,o),r(e,V,o),n(V,He),n(V,Gn),r(e,Pt,o),r(e,I,o),n(I,zn),n(I,Oe),n(Oe,Jn),n(I,Kn),r(e,Ct,o),r(e,de,o),n(de,Xn),r(e,Tt,o),r(e,q,o),q.innerHTML=Wo,r(e,It,o),r(e,Q,o),n(Q,Re),n(Q,Zn),r(e,$t,o),r(e,$,o),n($,ea),n($,Ue),n(Ue,ta),n($,na),r(e,St,o),r(e,he,o),n(he,aa),r(e,Ht,o),r(e,W,o),W.innerHTML=Yo,r(e,Ot,o),r(e,Y,o),n(Y,Be),n(Y,sa),r(e,Rt,o),r(e,k,o),n(k,oa),n(k,je),n(je,la),n(k,ia),n(k,Fe),n(Fe,pa),n(k,ra),n(k,Ne),n(Ne,ca),n(k,ua),n(k,Ve),n(Ve,fa),n(k,ma),n(k,qe),n(qe,da),n(k,ha),r(e,Ut,o),r(e,D,o),n(D,_a),n(D,_e),n(_e,Ea),n(D,ka),n(D,Ee),n(Ee,ya),n(D,va),r(e,Bt,o),r(e,ke,o),n(ke,ba),r(e,jt,o),r(e,G,o),G.innerHTML=Go,r(e,Ft,o),r(e,z,o),n(z,Qe),n(z,La),r(e,Nt,o),r(e,S,o),n(S,xa),n(S,We),n(We,wa),n(S,Ma),r(e,Vt,o),r(e,ye,o),n(ye,ga),r(e,qt,o),r(e,ve,o),n(ve,Aa),r(e,Qt,o),r(e,J,o),J.innerHTML=zo,r(e,Wt,o),Bo(H,e,o),r(e,Yt,o),r(e,K,o),n(K,Ye),n(K,Da),r(e,Gt,o),r(e,O,o),n(O,Pa),n(O,Ge),n(Ge,Ca),n(O,Ta),r(e,zt,o),r(e,X,o),X.innerHTML=Jo,r(e,Jt,o),r(e,be,o),n(be,Ia),r(e,Kt,o),r(e,R,o),n(R,$a),n(R,ze),n(ze,Sa),n(R,Ha),r(e,Xt,o),r(e,Le,o),n(Le,h),n(h,Je),n(Je,Oa),n(h,Ra),n(h,Ke),n(Ke,Ua),n(h,Ba),n(h,Xe),n(Xe,ja),n(h,Fa),n(h,Ze),n(Ze,Na),n(h,Va),n(h,et),n(et,qa),n(h,Qa),n(h,tt),n(tt,Wa),n(h,Ya),n(h,nt),n(nt,Ga),n(h,za),n(h,at),n(at,Ja),n(h,Ka),n(h,st),n(st,Xa),n(h,Za),n(h,ot),n(ot,es),n(h,ts),r(e,Zt,o),r(e,Z,o),Z.innerHTML=Ko,r(e,en,o),r(e,xe,o),n(xe,b),n(b,lt),n(lt,ns),n(b,as),n(b,it),n(it,ss),n(b,os),n(b,pt),n(pt,ls),n(b,is),n(b,rt),n(rt,ps),n(b,rs),n(b,ct),n(ct,cs),n(b,us),r(e,tn,o),r(e,ee,o),ee.innerHTML=Xo,r(e,nn,o),r(e,we,o),n(we,y),n(y,ut),n(ut,fs),n(y,ms),n(y,ft),n(ft,ds),n(y,hs),n(y,mt),n(mt,_s),n(y,Es),n(y,dt),n(dt,ks),n(y,ys),n(y,ht),n(ht,vs),n(y,bs),n(y,_t),n(_t,Ls),n(y,xs),r(e,an,o),r(e,te,o),te.innerHTML=Zo,r(e,sn,o),r(e,ne,o),ne.innerHTML=el,r(e,on,o),r(e,Me,o),n(Me,ws),r(e,ln,o),r(e,ge,o),n(ge,Ms),r(e,pn,o),r(e,ae,o),ae.innerHTML=tl,rn=!0},p(e,[o]){const P={};o&1&&(P.$$scope={dirty:o,ctx:e}),T.$set(P);const Et={};o&1&&(Et.$$scope={dirty:o,ctx:e}),H.$set(Et)},i(e){rn||(jo(T.$$.fragment,e),jo(H.$$.fragment,e),rn=!0)},o(e){Fo(T.$$.fragment,e),Fo(H.$$.fragment,e),rn=!1},d(e){e&&t(m),e&&t(x),e&&t(g),e&&t(kt),e&&t(se),e&&t(yt),e&&t(E),e&&t(vt),e&&t(B),e&&t(bt),e&&t(C),e&&t(Lt),No(T,e),e&&t(xt),e&&t(j),e&&t(wt),e&&t(F),e&&t(Mt),e&&t(A),e&&t(gt),e&&t(me),e&&t(At),e&&t(N),e&&t(Dt),e&&t(V),e&&t(Pt),e&&t(I),e&&t(Ct),e&&t(de),e&&t(Tt),e&&t(q),e&&t(It),e&&t(Q),e&&t($t),e&&t($),e&&t(St),e&&t(he),e&&t(Ht),e&&t(W),e&&t(Ot),e&&t(Y),e&&t(Rt),e&&t(k),e&&t(Ut),e&&t(D),e&&t(Bt),e&&t(ke),e&&t(jt),e&&t(G),e&&t(Ft),e&&t(z),e&&t(Nt),e&&t(S),e&&t(Vt),e&&t(ye),e&&t(qt),e&&t(ve),e&&t(Qt),e&&t(J),e&&t(Wt),No(H,e),e&&t(Yt),e&&t(K),e&&t(Gt),e&&t(O),e&&t(zt),e&&t(X),e&&t(Jt),e&&t(be),e&&t(Kt),e&&t(R),e&&t(Xt),e&&t(Le),e&&t(Zt),e&&t(Z),e&&t(en),e&&t(xe),e&&t(tn),e&&t(ee),e&&t(nn),e&&t(we),e&&t(an),e&&t(te),e&&t(sn),e&&t(ne),e&&t(on),e&&t(Me),e&&t(ln),e&&t(ge),e&&t(pn),e&&t(ae)}}}class Ml extends dl{constructor(m){super();hl(this,m,null,bl,_l,{})}}export{Ml as default};
