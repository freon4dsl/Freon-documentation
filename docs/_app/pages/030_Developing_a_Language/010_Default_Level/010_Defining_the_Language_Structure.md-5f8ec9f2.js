import{S as xl,i as Ll,s as wl,e as l,t as a,k as c,w as Wo,c as i,a as p,h as s,d as t,m as u,x as Yo,b as f,g as r,H as n,y as Go,q as zo,o as Jo,B as Ko}from"../../../chunks/vendor-492729b6.js";import{N as Qo}from"../../../chunks/Note-1bdf01a3.js";/* empty css                                                         */function Ml(B){let m;return{c(){m=a("Models are never explicit in an editor")},l(d){m=s(d,"Models are never explicit in an editor")},m(d,L){r(d,m,L)},d(d){d&&t(m)}}}function Dl(B){let m;return{c(){m=a(`The model is never shown in an editor as a whole. 
It is always shown in parts: the model units. However, the webapp does 'show' the model and the units, that are
part of it, in its left panel.`)},l(d){m=s(d,`The model is never shown in an editor as a whole. 
It is always shown in parts: the model units. However, the webapp does 'show' the model and the units, that are
part of it, in its left panel.`)},m(d,L){r(d,m,L)},d(d){d&&t(m)}}}function Al(B){let m;return{c(){m=a("No quotes around numbers and booleans.")},l(d){m=s(d,"No quotes around numbers and booleans.")},m(d,L){r(d,m,L)},d(d){d&&t(m)}}}function Pl(B){let m;return{c(){m=a(`For number and boolean types, quotes (double or single) are not allowed around the values of properties of
instances of limited concepts.`)},l(d){m=s(d,`For number and boolean types, quotes (double or single) are not allowed around the values of properties of
instances of limited concepts.`)},m(d,L){r(d,m,L)},d(d){d&&t(m)}}}function gl(B){let m,d,L,D,vn,Ce,bn,xn,Te,Ln,wn,vt,oe,Mn,bt,E,Dn,le,An,Pn,ie,gn,Cn,pe,Tn,In,re,$n,Hn,ce,Sn,On,ue,Rn,Un,fe,Bn,Fn,xt,F,Ie,Nn,Lt,C,jn,$e,qn,Vn,wt,T,Mt,N,Xo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L3-L7</span>

model EntityModel <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    units<span class="token operator">:</span> EntityModelUnit<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    extraUnit<span class="token operator">:</span> SomeOtherModelUnit<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Dt,j,He,Wn,At,A,Yn,Se,Gn,zn,me,Jn,Kn,Pt,de,Qn,gt,q,Zo=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L56-L61</span>

modelunit EntityModelUnit <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>

    functions<span class="token operator">:</span> EntityFunction<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    entities<span class="token operator">:</span> Entity<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Ct,he,Xn,Tt,V,Oe,Zn,It,I,ea,Re,ta,na,$t,_e,aa,Ht,W,el=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L26-L32</span>

concept Entity <span class="token keyword">implements</span> <span class="token class-name">Type</span> <span class="token punctuation">&#123;</span>
    isCompany<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    attributes<span class="token operator">:</span> AttributeWithLimitedType<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    entAttributes<span class="token operator">:</span> AttributeWithEntityType<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    functions<span class="token operator">:</span> EntityFunction<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    reference baseEntity<span class="token operator">?</span><span class="token operator">:</span> Entity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,St,Y,Ue,sa,Ot,$,oa,Be,la,ia,Rt,Ee,pa,Ut,G,tl=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L48-L50</span>

expression AbsExpression base EntityExpression <span class="token punctuation">&#123;</span>
    expr<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Bt,z,Fe,ra,Ft,k,ca,Ne,ua,fa,je,ma,da,qe,ha,_a,Ve,Ea,ka,We,ya,va,Nt,P,ba,ke,xa,La,ye,wa,Ma,jt,ve,Da,qt,J,nl=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L118-L121</span>

<span class="token keyword">abstract</span> binary expression BinaryExpression base EntityExpression <span class="token punctuation">&#123;</span>
    left<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
    right<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Vt,K,Ye,Aa,Wt,H,Pa,Ge,ga,Ca,Yt,S,Ta,ze,Ia,$a,Gt,be,Ha,zt,Q,al=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L34-L46</span>

limited AttributeType <span class="token keyword">implements</span> <span class="token class-name">BaseType</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// if the 'name' property was not provided, it would have been generated</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    extra<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    String <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span> extra<span class="token operator">:</span> <span class="token number">199</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// notations 'name:' and '"name":' are both correct</span>
    Integer <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"Integer"</span><span class="token punctuation">,</span> extra<span class="token operator">:</span> <span class="token number">240261</span><span class="token punctuation">&#125;</span>
    Boolean <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">"Boolean"</span><span class="token punctuation">,</span> extra<span class="token operator">:</span> <span class="token number">5479</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// the following instance gets the name "ANY"</span>
    <span class="token constant">ANY</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> extra<span class="token operator">:</span> <span class="token number">456</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

limited MockEnumeration <span class="token punctuation">&#123;</span> EnumValue1<span class="token punctuation">;</span> EnumValue2<span class="token punctuation">;</span> EnumValue3<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code>`,Jt,O,Kt,X,Je,Sa,Qt,R,Oa,Ke,Ra,Ua,Xt,Z,sl=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L14-L17</span>

<span class="token keyword">interface</span> <span class="token class-name">BaseType</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    baseInterface_attr<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Zt,xe,Ba,en,U,Fa,Qe,Na,ja,tn,Le,h,Xe,qa,Va,Ze,Wa,Ya,et,Ga,za,tt,Ja,Ka,nt,Qa,Xa,at,Za,es,st,ts,ns,ot,as,ss,lt,os,ls,it,is,ps,nn,ee,ol=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L63-L65</span>

concept EntityFunction <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    aliases<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code>`,an,we,b,pt,rs,cs,rt,us,fs,ct,ms,ds,ut,hs,_s,ft,Es,ks,sn,te,ll=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L63-L67</span>

concept EntityFunction <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    aliases<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    expression<span class="token operator">:</span> EntityExpression<span class="token punctuation">;</span>
    parameters<span class="token operator">:</span> Variable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code>`,on,Me,y,mt,ys,vs,dt,bs,xs,ht,Ls,ws,_t,Ms,Ds,Et,As,Ps,kt,gs,Cs,ln,ne,il=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L101-L101</span>

reference variable<span class="token operator">:</span> Variable<span class="token punctuation">;</span></code>`,pn,ae,pl=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L83-L84</span>

concept Variable <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span></code>`,rn,De,Ts,cn,Ae,Is,un,se,rl=`<code class="language-ts"><span class="token comment">// tutorial-language/defs/LanguageDefinition.ast#L14-L17</span>

<span class="token keyword">interface</span> <span class="token class-name">BaseType</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> identifier<span class="token punctuation">;</span>
    baseInterface_attr<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,fn;return T=new Qo({props:{$$slots:{content:[Dl],header:[Ml]},$$scope:{ctx:B}}}),O=new Qo({props:{$$slots:{content:[Pl],header:[Al]},$$scope:{ctx:B}}}),{c(){m=l("h1"),d=a("The Language Structure Definition"),L=c(),D=l("p"),vn=a("The abstract syntax tree (AST) of the language is described in files with the extension "),Ce=l("code"),bn=a(".ast"),xn=a(`.
All files with this extension in the `),Te=l("em"),Ln=a("defs"),wn=a(` folder (i.e. the folder were you keep your definition files)
are combined into one AST definition.`),vt=c(),oe=l("h2"),Mn=a("Concepts"),bt=c(),E=l("p"),Dn=a(`The ProjectIt language structure, which describes the abstract syntax tree (AST), consists of a
list of a `),le=l("a"),An=a("Models"),Pn=a(`,
`),ie=l("a"),gn=a("Model Units"),Cn=a(`,
`),pe=l("a"),Tn=a("Concepts"),In=a(`,
`),re=l("a"),$n=a("Expression Concepts"),Hn=a(`,
`),ce=l("a"),Sn=a("Binary Expression Concepts"),On=a(`,
`),ue=l("a"),Rn=a("Limited Concepts"),Un=a(`,
and/or `),fe=l("a"),Bn=a("Interfaces"),Fn=a("."),xt=c(),F=l("h3"),Ie=l("a"),Nn=a(" Model"),Lt=c(),C=l("p"),jn=a("A "),$e=l("em"),qn=a("model"),Vn=a(` is the root of the abstract syntax tree, and as such the complete description specified by the user.
It may hold any number of model units as children. These model units may be of different type. For instance, you
can have model units that define the items in a home automation system, and other model units that define the rules
that apply in this system.`),wt=c(),Wo(T.$$.fragment),Mt=c(),N=l("pre"),Dt=c(),j=l("h3"),He=l("a"),Wn=a(" Model unit"),At=c(),A=l("p"),Yn=a("A "),Se=l("em"),Gn=a("model unit"),zn=a(` is a part of the model that can be edited independently of the rest of the model. A model unit is
always a direct child of a model. The name of a model unit must always be `),me=l("a"),Jn=a("public"),Kn=a("."),Pt=c(),de=l("p"),Qn=a("Model units may not extend other units or implement interfaces."),gt=c(),q=l("pre"),Ct=c(),he=l("p"),Xn=a("TODO add file-extension to example"),Tt=c(),V=l("h3"),Oe=l("a"),Zn=a(" Concept"),It=c(),I=l("p"),ea=a("A "),Re=l("em"),ta=a("concept"),na=a(` is the basic element of your language definition. It defines which instances can be present in
a model created by your users.`),$t=c(),_e=l("p"),aa=a("Concepts may extend one other concept, and implement multiple interfaces."),Ht=c(),W=l("pre"),St=c(),Y=l("h3"),Ue=l("a"),sa=a(" Expression Concept"),Ot=c(),$=l("p"),oa=a("An "),Be=l("em"),la=a("expression concept"),ia=a(` is a concept that is an expression. The editor will deal with these differently in
order to give your user a more natural editing experience.`),Rt=c(),Ee=l("p"),pa=a("Expression concepts may extend one other concept, and implement multiple interfaces."),Ut=c(),G=l("pre"),Bt=c(),z=l("h3"),Fe=l("a"),ra=a(" Binary Expression Concept"),Ft=c(),k=l("p"),ca=a("A "),Ne=l("em"),ua=a("binary expression concept"),fa=a(` is an expression concept that has two sub expressions, left and right operands,
and an operator, which in the concrete syntax usually goes in the middle. For example, the expression `),je=l("code"),ma=a("4 + 5"),da=a(`
has as left operand `),qe=l("code"),ha=a("4"),_a=a(", as operator "),Ve=l("code"),Ea=a("+"),ka=a(", and as right operand "),We=l("code"),ya=a("5"),va=a("."),Nt=c(),P=l("p"),ba=a(`Any concrete binary expression concept needs to have a priority. The priority is used by ProjectIt to balance the
abstract syntax tree (see `),ke=l("a"),xa=a("Projectional Editing"),La=a(`). In
the `),ye=l("a"),wa=a("second level tutorial"),Ma=a(` you can
find more information on how to set the operand.`),jt=c(),ve=l("p"),Da=a("Binary expression concepts may extend one other concept, and implement multiple interfaces."),qt=c(),J=l("pre"),Vt=c(),K=l("h3"),Ye=l("a"),Aa=a(" Limited Concept"),Wt=c(),H=l("p"),Pa=a("A "),Ge=l("em"),ga=a("limited concept"),Ca=a(` is a concept that has a limited number of predefined instances. Actually, it is an extended
version of an enumeration. All instances become part of the standard library of your language.`),Yt=c(),S=l("p"),Ta=a("A limited concept must always have a name property ("),ze=l("code"),Ia=a("name: identifier;"),$a=a(`), but if this is not provided
in the definition then it is automatically created. Furthermore, when a predefined instance does not provide a
value for the name, the name of the instance is used. In this manner, you can define simple enumerations.`),Gt=c(),be=l("p"),Ha=a("Limited concepts may extend one other concept, and implement multiple interfaces."),zt=c(),Q=l("pre"),Jt=c(),Wo(O.$$.fragment),Kt=c(),X=l("h3"),Je=l("a"),Sa=a(" Interface"),Qt=c(),R=l("p"),Oa=a("An "),Ke=l("em"),Ra=a("interface"),Ua=a(" is a concept that has no instances."),Xt=c(),Z=l("pre"),Zt=c(),xe=l("h2"),Ba=a("Properties"),en=c(),U=l("p"),Fa=a("Each of the language structure elements have "),Qe=l("strong"),Na=a("Properties"),ja=a(`, of which there are the
following three types.`),tn=c(),Le=l("ul"),h=l("li"),Xe=l("em"),qa=a("Simple properties"),Va=a(" have as type "),Ze=l("code"),Wa=a("identifier"),Ya=a(", "),et=l("code"),Ga=a("string"),za=a(", "),tt=l("code"),Ja=a("number"),Ka=a(", or "),nt=l("code"),Qa=a("boolean"),Xa=a(`, and are
always contained in the `),at=l("em"),Za=a("concept"),es=a(`. Simple properties may also be lists
of `),st=l("code"),ts=a("identifier"),ns=a(", "),ot=l("code"),as=a("string"),ss=a(", "),lt=l("code"),os=a("number"),ls=a(", or "),it=l("code"),is=a("boolean"),ps=a("."),nn=c(),ee=l("pre"),an=c(),we=l("ul"),b=l("li"),pt=l("em"),rs=a("Parts"),cs=a(" have as type one of the "),rt=l("em"),us=a("concepts"),fs=a(" (including "),ct=l("em"),ms=a("expression concepts"),ds=a(" and "),ut=l("em"),hs=a("limited concepts"),_s=a(`)
in the language, and are `),ft=l("em"),Es=a("contained in the concept"),ks=a(` that holds the property (as in
the UML composition relationship). Note that simple properties are always considered to be parts.`),sn=c(),te=l("pre"),on=c(),Me=l("ul"),y=l("li"),mt=l("em"),ys=a("References"),vs=a(" also have as type one of the "),dt=l("em"),bs=a("concepts"),xs=a(` in the language, but a reference is not contained
in its `),ht=l("em"),Ls=a("concept"),ws=a(` (as in the UML association relationship). References are indicated by the keyword
`),_t=l("em"),Ms=a("reference"),Ds=a(" in front of the definition.References are always by name, therefore the referred concept must have a "),Et=l("code"),As=a("name"),Ps=a(" property of type "),kt=l("code"),gs=a("identifier"),Cs=a("."),ln=c(),ne=l("pre"),pn=c(),ae=l("pre"),rn=c(),De=l("h3"),Ts=a("Optional Properties"),cn=c(),Ae=l("p"),Is=a("Properties may be optional. This is indicated using a question mark after the property name."),un=c(),se=l("pre"),this.h()},l(e){m=i(e,"H1",{});var o=p(m);d=s(o,"The Language Structure Definition"),o.forEach(t),L=u(e),D=i(e,"P",{});var g=p(D);vn=s(g,"The abstract syntax tree (AST) of the language is described in files with the extension "),Ce=i(g,"CODE",{});var yt=p(Ce);bn=s(yt,".ast"),yt.forEach(t),xn=s(g,`.
All files with this extension in the `),Te=i(g,"EM",{});var Fs=p(Te);Ln=s(Fs,"defs"),Fs.forEach(t),wn=s(g,` folder (i.e. the folder were you keep your definition files)
are combined into one AST definition.`),g.forEach(t),vt=u(e),oe=i(e,"H2",{});var Ns=p(oe);Mn=s(Ns,"Concepts"),Ns.forEach(t),bt=u(e),E=i(e,"P",{});var v=p(E);Dn=s(v,`The ProjectIt language structure, which describes the abstract syntax tree (AST), consists of a
list of a `),le=i(v,"A",{href:!0});var js=p(le);An=s(js,"Models"),js.forEach(t),Pn=s(v,`,
`),ie=i(v,"A",{href:!0});var qs=p(ie);gn=s(qs,"Model Units"),qs.forEach(t),Cn=s(v,`,
`),pe=i(v,"A",{href:!0});var Vs=p(pe);Tn=s(Vs,"Concepts"),Vs.forEach(t),In=s(v,`,
`),re=i(v,"A",{href:!0});var Ws=p(re);$n=s(Ws,"Expression Concepts"),Ws.forEach(t),Hn=s(v,`,
`),ce=i(v,"A",{href:!0});var Ys=p(ce);Sn=s(Ys,"Binary Expression Concepts"),Ys.forEach(t),On=s(v,`,
`),ue=i(v,"A",{href:!0});var Gs=p(ue);Rn=s(Gs,"Limited Concepts"),Gs.forEach(t),Un=s(v,`,
and/or `),fe=i(v,"A",{href:!0});var zs=p(fe);Bn=s(zs,"Interfaces"),zs.forEach(t),Fn=s(v,"."),v.forEach(t),xt=u(e),F=i(e,"H3",{});var $s=p(F);Ie=i($s,"A",{name:!0}),p(Ie).forEach(t),Nn=s($s," Model"),$s.forEach(t),Lt=u(e),C=i(e,"P",{});var mn=p(C);jn=s(mn,"A "),$e=i(mn,"EM",{});var Js=p($e);qn=s(Js,"model"),Js.forEach(t),Vn=s(mn,` is the root of the abstract syntax tree, and as such the complete description specified by the user.
It may hold any number of model units as children. These model units may be of different type. For instance, you
can have model units that define the items in a home automation system, and other model units that define the rules
that apply in this system.`),mn.forEach(t),wt=u(e),Yo(T.$$.fragment,e),Mt=u(e),N=i(e,"PRE",{class:!0});var cl=p(N);cl.forEach(t),Dt=u(e),j=i(e,"H3",{});var Hs=p(j);He=i(Hs,"A",{name:!0}),p(He).forEach(t),Wn=s(Hs," Model unit"),Hs.forEach(t),At=u(e),A=i(e,"P",{});var Pe=p(A);Yn=s(Pe,"A "),Se=i(Pe,"EM",{});var Ks=p(Se);Gn=s(Ks,"model unit"),Ks.forEach(t),zn=s(Pe,` is a part of the model that can be edited independently of the rest of the model. A model unit is
always a direct child of a model. The name of a model unit must always be `),me=i(Pe,"A",{href:!0});var Qs=p(me);Jn=s(Qs,"public"),Qs.forEach(t),Kn=s(Pe,"."),Pe.forEach(t),Pt=u(e),de=i(e,"P",{});var Xs=p(de);Qn=s(Xs,"Model units may not extend other units or implement interfaces."),Xs.forEach(t),gt=u(e),q=i(e,"PRE",{class:!0});var ul=p(q);ul.forEach(t),Ct=u(e),he=i(e,"P",{});var Zs=p(he);Xn=s(Zs,"TODO add file-extension to example"),Zs.forEach(t),Tt=u(e),V=i(e,"H3",{});var Ss=p(V);Oe=i(Ss,"A",{name:!0}),p(Oe).forEach(t),Zn=s(Ss," Concept"),Ss.forEach(t),It=u(e),I=i(e,"P",{});var dn=p(I);ea=s(dn,"A "),Re=i(dn,"EM",{});var eo=p(Re);ta=s(eo,"concept"),eo.forEach(t),na=s(dn,` is the basic element of your language definition. It defines which instances can be present in
a model created by your users.`),dn.forEach(t),$t=u(e),_e=i(e,"P",{});var to=p(_e);aa=s(to,"Concepts may extend one other concept, and implement multiple interfaces."),to.forEach(t),Ht=u(e),W=i(e,"PRE",{class:!0});var fl=p(W);fl.forEach(t),St=u(e),Y=i(e,"H3",{});var Os=p(Y);Ue=i(Os,"A",{name:!0}),p(Ue).forEach(t),sa=s(Os," Expression Concept"),Os.forEach(t),Ot=u(e),$=i(e,"P",{});var hn=p($);oa=s(hn,"An "),Be=i(hn,"EM",{});var no=p(Be);la=s(no,"expression concept"),no.forEach(t),ia=s(hn,` is a concept that is an expression. The editor will deal with these differently in
order to give your user a more natural editing experience.`),hn.forEach(t),Rt=u(e),Ee=i(e,"P",{});var ao=p(Ee);pa=s(ao,"Expression concepts may extend one other concept, and implement multiple interfaces."),ao.forEach(t),Ut=u(e),G=i(e,"PRE",{class:!0});var ml=p(G);ml.forEach(t),Bt=u(e),z=i(e,"H3",{});var Rs=p(z);Fe=i(Rs,"A",{name:!0}),p(Fe).forEach(t),ra=s(Rs," Binary Expression Concept"),Rs.forEach(t),Ft=u(e),k=i(e,"P",{});var w=p(k);ca=s(w,"A "),Ne=i(w,"EM",{});var so=p(Ne);ua=s(so,"binary expression concept"),so.forEach(t),fa=s(w,` is an expression concept that has two sub expressions, left and right operands,
and an operator, which in the concrete syntax usually goes in the middle. For example, the expression `),je=i(w,"CODE",{});var oo=p(je);ma=s(oo,"4 + 5"),oo.forEach(t),da=s(w,`
has as left operand `),qe=i(w,"CODE",{});var lo=p(qe);ha=s(lo,"4"),lo.forEach(t),_a=s(w,", as operator "),Ve=i(w,"CODE",{});var io=p(Ve);Ea=s(io,"+"),io.forEach(t),ka=s(w,", and as right operand "),We=i(w,"CODE",{});var po=p(We);ya=s(po,"5"),po.forEach(t),va=s(w,"."),w.forEach(t),Nt=u(e),P=i(e,"P",{});var ge=p(P);ba=s(ge,`Any concrete binary expression concept needs to have a priority. The priority is used by ProjectIt to balance the
abstract syntax tree (see `),ke=i(ge,"A",{href:!0});var ro=p(ke);xa=s(ro,"Projectional Editing"),ro.forEach(t),La=s(ge,`). In
the `),ye=i(ge,"A",{href:!0});var co=p(ye);wa=s(co,"second level tutorial"),co.forEach(t),Ma=s(ge,` you can
find more information on how to set the operand.`),ge.forEach(t),jt=u(e),ve=i(e,"P",{});var uo=p(ve);Da=s(uo,"Binary expression concepts may extend one other concept, and implement multiple interfaces."),uo.forEach(t),qt=u(e),J=i(e,"PRE",{class:!0});var dl=p(J);dl.forEach(t),Vt=u(e),K=i(e,"H3",{});var Us=p(K);Ye=i(Us,"A",{name:!0}),p(Ye).forEach(t),Aa=s(Us," Limited Concept"),Us.forEach(t),Wt=u(e),H=i(e,"P",{});var _n=p(H);Pa=s(_n,"A "),Ge=i(_n,"EM",{});var fo=p(Ge);ga=s(fo,"limited concept"),fo.forEach(t),Ca=s(_n,` is a concept that has a limited number of predefined instances. Actually, it is an extended
version of an enumeration. All instances become part of the standard library of your language.`),_n.forEach(t),Yt=u(e),S=i(e,"P",{});var En=p(S);Ta=s(En,"A limited concept must always have a name property ("),ze=i(En,"CODE",{});var mo=p(ze);Ia=s(mo,"name: identifier;"),mo.forEach(t),$a=s(En,`), but if this is not provided
in the definition then it is automatically created. Furthermore, when a predefined instance does not provide a
value for the name, the name of the instance is used. In this manner, you can define simple enumerations.`),En.forEach(t),Gt=u(e),be=i(e,"P",{});var ho=p(be);Ha=s(ho,"Limited concepts may extend one other concept, and implement multiple interfaces."),ho.forEach(t),zt=u(e),Q=i(e,"PRE",{class:!0});var hl=p(Q);hl.forEach(t),Jt=u(e),Yo(O.$$.fragment,e),Kt=u(e),X=i(e,"H3",{});var Bs=p(X);Je=i(Bs,"A",{name:!0}),p(Je).forEach(t),Sa=s(Bs," Interface"),Bs.forEach(t),Qt=u(e),R=i(e,"P",{});var kn=p(R);Oa=s(kn,"An "),Ke=i(kn,"EM",{});var _o=p(Ke);Ra=s(_o,"interface"),_o.forEach(t),Ua=s(kn," is a concept that has no instances."),kn.forEach(t),Xt=u(e),Z=i(e,"PRE",{class:!0});var _l=p(Z);_l.forEach(t),Zt=u(e),xe=i(e,"H2",{});var Eo=p(xe);Ba=s(Eo,"Properties"),Eo.forEach(t),en=u(e),U=i(e,"P",{});var yn=p(U);Fa=s(yn,"Each of the language structure elements have "),Qe=i(yn,"STRONG",{});var ko=p(Qe);Na=s(ko,"Properties"),ko.forEach(t),ja=s(yn,`, of which there are the
following three types.`),yn.forEach(t),tn=u(e),Le=i(e,"UL",{});var yo=p(Le);h=i(yo,"LI",{});var _=p(h);Xe=i(_,"EM",{});var vo=p(Xe);qa=s(vo,"Simple properties"),vo.forEach(t),Va=s(_," have as type "),Ze=i(_,"CODE",{});var bo=p(Ze);Wa=s(bo,"identifier"),bo.forEach(t),Ya=s(_,", "),et=i(_,"CODE",{});var xo=p(et);Ga=s(xo,"string"),xo.forEach(t),za=s(_,", "),tt=i(_,"CODE",{});var Lo=p(tt);Ja=s(Lo,"number"),Lo.forEach(t),Ka=s(_,", or "),nt=i(_,"CODE",{});var wo=p(nt);Qa=s(wo,"boolean"),wo.forEach(t),Xa=s(_,`, and are
always contained in the `),at=i(_,"EM",{});var Mo=p(at);Za=s(Mo,"concept"),Mo.forEach(t),es=s(_,`. Simple properties may also be lists
of `),st=i(_,"CODE",{});var Do=p(st);ts=s(Do,"identifier"),Do.forEach(t),ns=s(_,", "),ot=i(_,"CODE",{});var Ao=p(ot);as=s(Ao,"string"),Ao.forEach(t),ss=s(_,", "),lt=i(_,"CODE",{});var Po=p(lt);os=s(Po,"number"),Po.forEach(t),ls=s(_,", or "),it=i(_,"CODE",{});var go=p(it);is=s(go,"boolean"),go.forEach(t),ps=s(_,"."),_.forEach(t),yo.forEach(t),nn=u(e),ee=i(e,"PRE",{class:!0});var El=p(ee);El.forEach(t),an=u(e),we=i(e,"UL",{});var Co=p(we);b=i(Co,"LI",{});var M=p(b);pt=i(M,"EM",{});var To=p(pt);rs=s(To,"Parts"),To.forEach(t),cs=s(M," have as type one of the "),rt=i(M,"EM",{});var Io=p(rt);us=s(Io,"concepts"),Io.forEach(t),fs=s(M," (including "),ct=i(M,"EM",{});var $o=p(ct);ms=s($o,"expression concepts"),$o.forEach(t),ds=s(M," and "),ut=i(M,"EM",{});var Ho=p(ut);hs=s(Ho,"limited concepts"),Ho.forEach(t),_s=s(M,`)
in the language, and are `),ft=i(M,"EM",{});var So=p(ft);Es=s(So,"contained in the concept"),So.forEach(t),ks=s(M,` that holds the property (as in
the UML composition relationship). Note that simple properties are always considered to be parts.`),M.forEach(t),Co.forEach(t),sn=u(e),te=i(e,"PRE",{class:!0});var kl=p(te);kl.forEach(t),on=u(e),Me=i(e,"UL",{});var Oo=p(Me);y=i(Oo,"LI",{});var x=p(y);mt=i(x,"EM",{});var Ro=p(mt);ys=s(Ro,"References"),Ro.forEach(t),vs=s(x," also have as type one of the "),dt=i(x,"EM",{});var Uo=p(dt);bs=s(Uo,"concepts"),Uo.forEach(t),xs=s(x,` in the language, but a reference is not contained
in its `),ht=i(x,"EM",{});var Bo=p(ht);Ls=s(Bo,"concept"),Bo.forEach(t),ws=s(x,` (as in the UML association relationship). References are indicated by the keyword
`),_t=i(x,"EM",{});var Fo=p(_t);Ms=s(Fo,"reference"),Fo.forEach(t),Ds=s(x," in front of the definition.References are always by name, therefore the referred concept must have a "),Et=i(x,"CODE",{});var No=p(Et);As=s(No,"name"),No.forEach(t),Ps=s(x," property of type "),kt=i(x,"CODE",{});var jo=p(kt);gs=s(jo,"identifier"),jo.forEach(t),Cs=s(x,"."),x.forEach(t),Oo.forEach(t),ln=u(e),ne=i(e,"PRE",{class:!0});var yl=p(ne);yl.forEach(t),pn=u(e),ae=i(e,"PRE",{class:!0});var vl=p(ae);vl.forEach(t),rn=u(e),De=i(e,"H3",{});var qo=p(De);Ts=s(qo,"Optional Properties"),qo.forEach(t),cn=u(e),Ae=i(e,"P",{});var Vo=p(Ae);Is=s(Vo,"Properties may be optional. This is indicated using a question mark after the property name."),Vo.forEach(t),un=u(e),se=i(e,"PRE",{class:!0});var bl=p(se);bl.forEach(t),this.h()},h(){f(le,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Model"),f(ie,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Model_Unit"),f(pe,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Concept"),f(re,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Expression_Concept"),f(ce,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Binary_Expression_Concept"),f(ue,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Limited_Concept"),f(fe,"href","/030_Developing_a_Language/010_Default_Level/010_Defining_the_Language_Structure#Interface"),f(Ie,"name","Model"),f(N,"class","language-ts"),f(He,"name","Model_Unit"),f(me,"href","/010_Intro/030_Models_and_Model_Units#public"),f(q,"class","language-ts"),f(Oe,"name","Concept"),f(W,"class","language-ts"),f(Ue,"name","Expression_Concept"),f(G,"class","language-ts"),f(Fe,"name","Binary_Expression_Concept"),f(ke,"href","/010_Intro/010_Projectional_Editing#tree-balancing"),f(ye,"href","/030_Developing_a_Language/020_ProjectIt_Definition_Level/010_Editor_Definition#operand"),f(J,"class","language-ts"),f(Ye,"name","Limited_Concept"),f(Q,"class","language-ts"),f(Je,"name","Interface"),f(Z,"class","language-ts"),f(ee,"class","language-ts"),f(te,"class","language-ts"),f(ne,"class","language-ts"),f(ae,"class","language-ts"),f(se,"class","language-ts")},m(e,o){r(e,m,o),n(m,d),r(e,L,o),r(e,D,o),n(D,vn),n(D,Ce),n(Ce,bn),n(D,xn),n(D,Te),n(Te,Ln),n(D,wn),r(e,vt,o),r(e,oe,o),n(oe,Mn),r(e,bt,o),r(e,E,o),n(E,Dn),n(E,le),n(le,An),n(E,Pn),n(E,ie),n(ie,gn),n(E,Cn),n(E,pe),n(pe,Tn),n(E,In),n(E,re),n(re,$n),n(E,Hn),n(E,ce),n(ce,Sn),n(E,On),n(E,ue),n(ue,Rn),n(E,Un),n(E,fe),n(fe,Bn),n(E,Fn),r(e,xt,o),r(e,F,o),n(F,Ie),n(F,Nn),r(e,Lt,o),r(e,C,o),n(C,jn),n(C,$e),n($e,qn),n(C,Vn),r(e,wt,o),Go(T,e,o),r(e,Mt,o),r(e,N,o),N.innerHTML=Xo,r(e,Dt,o),r(e,j,o),n(j,He),n(j,Wn),r(e,At,o),r(e,A,o),n(A,Yn),n(A,Se),n(Se,Gn),n(A,zn),n(A,me),n(me,Jn),n(A,Kn),r(e,Pt,o),r(e,de,o),n(de,Qn),r(e,gt,o),r(e,q,o),q.innerHTML=Zo,r(e,Ct,o),r(e,he,o),n(he,Xn),r(e,Tt,o),r(e,V,o),n(V,Oe),n(V,Zn),r(e,It,o),r(e,I,o),n(I,ea),n(I,Re),n(Re,ta),n(I,na),r(e,$t,o),r(e,_e,o),n(_e,aa),r(e,Ht,o),r(e,W,o),W.innerHTML=el,r(e,St,o),r(e,Y,o),n(Y,Ue),n(Y,sa),r(e,Ot,o),r(e,$,o),n($,oa),n($,Be),n(Be,la),n($,ia),r(e,Rt,o),r(e,Ee,o),n(Ee,pa),r(e,Ut,o),r(e,G,o),G.innerHTML=tl,r(e,Bt,o),r(e,z,o),n(z,Fe),n(z,ra),r(e,Ft,o),r(e,k,o),n(k,ca),n(k,Ne),n(Ne,ua),n(k,fa),n(k,je),n(je,ma),n(k,da),n(k,qe),n(qe,ha),n(k,_a),n(k,Ve),n(Ve,Ea),n(k,ka),n(k,We),n(We,ya),n(k,va),r(e,Nt,o),r(e,P,o),n(P,ba),n(P,ke),n(ke,xa),n(P,La),n(P,ye),n(ye,wa),n(P,Ma),r(e,jt,o),r(e,ve,o),n(ve,Da),r(e,qt,o),r(e,J,o),J.innerHTML=nl,r(e,Vt,o),r(e,K,o),n(K,Ye),n(K,Aa),r(e,Wt,o),r(e,H,o),n(H,Pa),n(H,Ge),n(Ge,ga),n(H,Ca),r(e,Yt,o),r(e,S,o),n(S,Ta),n(S,ze),n(ze,Ia),n(S,$a),r(e,Gt,o),r(e,be,o),n(be,Ha),r(e,zt,o),r(e,Q,o),Q.innerHTML=al,r(e,Jt,o),Go(O,e,o),r(e,Kt,o),r(e,X,o),n(X,Je),n(X,Sa),r(e,Qt,o),r(e,R,o),n(R,Oa),n(R,Ke),n(Ke,Ra),n(R,Ua),r(e,Xt,o),r(e,Z,o),Z.innerHTML=sl,r(e,Zt,o),r(e,xe,o),n(xe,Ba),r(e,en,o),r(e,U,o),n(U,Fa),n(U,Qe),n(Qe,Na),n(U,ja),r(e,tn,o),r(e,Le,o),n(Le,h),n(h,Xe),n(Xe,qa),n(h,Va),n(h,Ze),n(Ze,Wa),n(h,Ya),n(h,et),n(et,Ga),n(h,za),n(h,tt),n(tt,Ja),n(h,Ka),n(h,nt),n(nt,Qa),n(h,Xa),n(h,at),n(at,Za),n(h,es),n(h,st),n(st,ts),n(h,ns),n(h,ot),n(ot,as),n(h,ss),n(h,lt),n(lt,os),n(h,ls),n(h,it),n(it,is),n(h,ps),r(e,nn,o),r(e,ee,o),ee.innerHTML=ol,r(e,an,o),r(e,we,o),n(we,b),n(b,pt),n(pt,rs),n(b,cs),n(b,rt),n(rt,us),n(b,fs),n(b,ct),n(ct,ms),n(b,ds),n(b,ut),n(ut,hs),n(b,_s),n(b,ft),n(ft,Es),n(b,ks),r(e,sn,o),r(e,te,o),te.innerHTML=ll,r(e,on,o),r(e,Me,o),n(Me,y),n(y,mt),n(mt,ys),n(y,vs),n(y,dt),n(dt,bs),n(y,xs),n(y,ht),n(ht,Ls),n(y,ws),n(y,_t),n(_t,Ms),n(y,Ds),n(y,Et),n(Et,As),n(y,Ps),n(y,kt),n(kt,gs),n(y,Cs),r(e,ln,o),r(e,ne,o),ne.innerHTML=il,r(e,pn,o),r(e,ae,o),ae.innerHTML=pl,r(e,rn,o),r(e,De,o),n(De,Ts),r(e,cn,o),r(e,Ae,o),n(Ae,Is),r(e,un,o),r(e,se,o),se.innerHTML=rl,fn=!0},p(e,[o]){const g={};o&1&&(g.$$scope={dirty:o,ctx:e}),T.$set(g);const yt={};o&1&&(yt.$$scope={dirty:o,ctx:e}),O.$set(yt)},i(e){fn||(zo(T.$$.fragment,e),zo(O.$$.fragment,e),fn=!0)},o(e){Jo(T.$$.fragment,e),Jo(O.$$.fragment,e),fn=!1},d(e){e&&t(m),e&&t(L),e&&t(D),e&&t(vt),e&&t(oe),e&&t(bt),e&&t(E),e&&t(xt),e&&t(F),e&&t(Lt),e&&t(C),e&&t(wt),Ko(T,e),e&&t(Mt),e&&t(N),e&&t(Dt),e&&t(j),e&&t(At),e&&t(A),e&&t(Pt),e&&t(de),e&&t(gt),e&&t(q),e&&t(Ct),e&&t(he),e&&t(Tt),e&&t(V),e&&t(It),e&&t(I),e&&t($t),e&&t(_e),e&&t(Ht),e&&t(W),e&&t(St),e&&t(Y),e&&t(Ot),e&&t($),e&&t(Rt),e&&t(Ee),e&&t(Ut),e&&t(G),e&&t(Bt),e&&t(z),e&&t(Ft),e&&t(k),e&&t(Nt),e&&t(P),e&&t(jt),e&&t(ve),e&&t(qt),e&&t(J),e&&t(Vt),e&&t(K),e&&t(Wt),e&&t(H),e&&t(Yt),e&&t(S),e&&t(Gt),e&&t(be),e&&t(zt),e&&t(Q),e&&t(Jt),Ko(O,e),e&&t(Kt),e&&t(X),e&&t(Qt),e&&t(R),e&&t(Xt),e&&t(Z),e&&t(Zt),e&&t(xe),e&&t(en),e&&t(U),e&&t(tn),e&&t(Le),e&&t(nn),e&&t(ee),e&&t(an),e&&t(we),e&&t(sn),e&&t(te),e&&t(on),e&&t(Me),e&&t(ln),e&&t(ne),e&&t(pn),e&&t(ae),e&&t(rn),e&&t(De),e&&t(cn),e&&t(Ae),e&&t(un),e&&t(se)}}}class $l extends xl{constructor(m){super();Ll(this,m,null,gl,wl,{})}}export{$l as default};
