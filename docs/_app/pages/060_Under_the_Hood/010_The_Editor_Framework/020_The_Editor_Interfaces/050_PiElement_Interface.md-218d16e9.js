import{S as kn,i as mn,s as bn,e as p,t,k as m,c as l,a as i,h as a,d as e,m as b,b as En,g as c,H as s,J as sn}from"../../../../chunks/vendor-0dc77bd0.js";function wn(hn){let u,q,F,h,B,T,H,j,P,k,fn=`<code class="language-ts"><span class="token comment">/* File: core/src/language/PiElement.ts */</span>

<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">PiElement</span> <span class="token punctuation">&#123;</span>
	<span class="token function">piId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

	<span class="token function">piLanguageConcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

	<span class="token function">piContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PiContainerDescriptor<span class="token punctuation">;</span>

	<span class="token function">piIsModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

	<span class="token function">piIsUnit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

	<span class="token function">piIsExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

	<span class="token function">piIsBinaryExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,g,E,M,C,f,w,v,U,W,J,y,x,R,z,D,r,G,A,K,Q,I,V,X,S,Y,Z,L,_,$;return{c(){u=p("h1"),q=t("PiElement"),F=m(),h=p("p"),B=t(`As Freon uses the AST for projections and behavior, it needs to know about the type of elements in the AST.
To allow Freon to work, each element type that occurs in the AST needs to implement the `),T=p("code"),H=t("PiElement"),j=t(` interface.
This interface is kept as small as possible, to allow Freon to be used for any AST.`),P=m(),k=p("pre"),g=m(),E=p("p"),M=t("The main two elements in this interface are:"),C=m(),f=p("ul"),w=p("li"),v=p("code"),U=t("piId()"),W=t(", which should return en unique id for each element in the AST."),J=m(),y=p("li"),x=p("code"),R=t("piContainer()"),z=t(" which should return a descriptor for the container (parent) of an element in the AST."),D=m(),r=p("p"),G=t("The two functions "),A=p("code"),K=t("piIsExpression()"),Q=t(" and "),I=p("code"),V=t("piIsBinaryExpression()"),X=t(` are only needed when your language
contains expressions, as Freon includes special handling of expressions.
To start with, these functions can be defined to simply return `),S=p("code"),Y=t("false"),Z=t("."),L=m(),_=p("p"),$=t(`Note that Freon does not need to know anything about the structure of your language.
No need to know the available element type, nor the properties of en element type, nor anything else.
This is by design, as Freon is not meant to be a full Language Workbench,
but instead meant to be used with multiple language workbenches , or none.`),this.h()},l(n){u=l(n,"H1",{});var o=i(u);q=a(o,"PiElement"),o.forEach(e),F=b(n),h=l(n,"P",{});var O=i(h);B=a(O,`As Freon uses the AST for projections and behavior, it needs to know about the type of elements in the AST.
To allow Freon to work, each element type that occurs in the AST needs to implement the `),T=l(O,"CODE",{});var tn=i(T);H=a(tn,"PiElement"),tn.forEach(e),j=a(O,` interface.
This interface is kept as small as possible, to allow Freon to be used for any AST.`),O.forEach(e),P=b(n),k=l(n,"PRE",{class:!0});var dn=i(k);dn.forEach(e),g=b(n),E=l(n,"P",{});var an=i(E);M=a(an,"The main two elements in this interface are:"),an.forEach(e),C=b(n),f=l(n,"UL",{});var N=i(f);w=l(N,"LI",{});var nn=i(w);v=l(nn,"CODE",{});var on=i(v);U=a(on,"piId()"),on.forEach(e),W=a(nn,", which should return en unique id for each element in the AST."),nn.forEach(e),J=b(N),y=l(N,"LI",{});var en=i(y);x=l(en,"CODE",{});var pn=i(x);R=a(pn,"piContainer()"),pn.forEach(e),z=a(en," which should return a descriptor for the container (parent) of an element in the AST."),en.forEach(e),N.forEach(e),D=b(n),r=l(n,"P",{});var d=i(r);G=a(d,"The two functions "),A=l(d,"CODE",{});var ln=i(A);K=a(ln,"piIsExpression()"),ln.forEach(e),Q=a(d," and "),I=l(d,"CODE",{});var cn=i(I);V=a(cn,"piIsBinaryExpression()"),cn.forEach(e),X=a(d,` are only needed when your language
contains expressions, as Freon includes special handling of expressions.
To start with, these functions can be defined to simply return `),S=l(d,"CODE",{});var rn=i(S);Y=a(rn,"false"),rn.forEach(e),Z=a(d,"."),d.forEach(e),L=b(n),_=l(n,"P",{});var un=i(_);$=a(un,`Note that Freon does not need to know anything about the structure of your language.
No need to know the available element type, nor the properties of en element type, nor anything else.
This is by design, as Freon is not meant to be a full Language Workbench,
but instead meant to be used with multiple language workbenches , or none.`),un.forEach(e),this.h()},h(){En(k,"class","language-ts")},m(n,o){c(n,u,o),s(u,q),c(n,F,o),c(n,h,o),s(h,B),s(h,T),s(T,H),s(h,j),c(n,P,o),c(n,k,o),k.innerHTML=fn,c(n,g,o),c(n,E,o),s(E,M),c(n,C,o),c(n,f,o),s(f,w),s(w,v),s(v,U),s(w,W),s(f,J),s(f,y),s(y,x),s(x,R),s(y,z),c(n,D,o),c(n,r,o),s(r,G),s(r,A),s(A,K),s(r,Q),s(r,I),s(I,V),s(r,X),s(r,S),s(S,Y),s(r,Z),c(n,L,o),c(n,_,o),s(_,$)},p:sn,i:sn,o:sn,d(n){n&&e(u),n&&e(F),n&&e(h),n&&e(P),n&&e(k),n&&e(g),n&&e(E),n&&e(C),n&&e(f),n&&e(D),n&&e(r),n&&e(L),n&&e(_)}}}class _n extends kn{constructor(u){super();mn(this,u,null,wn,bn,{})}}export{_n as default};
