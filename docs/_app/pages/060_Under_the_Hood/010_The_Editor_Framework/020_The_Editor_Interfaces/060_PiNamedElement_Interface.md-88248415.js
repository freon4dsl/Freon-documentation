import{S as q,i as I,s as L,e as p,t as c,k as D,c as r,a as d,g as i,d as t,n as H,b as M,f as u,F as n,H as A}from"../../../../chunks/vendor-0216fdcb.js";function R(O){let s,P,_,a,v,f,x,N,E,b,y,h,T,w,k,m,F=`<code class="language-ts"><span class="token comment">/* File: core/src/language/PiNamedElement.ts  */</span>

<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">PiNamedElement</span> <span class="token keyword">extends</span> <span class="token class-name">PiElement</span> <span class="token punctuation">&#123;</span>
	name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`;return{c(){s=p("h1"),P=c("PiNamedElement"),_=D(),a=p("p"),v=c("An object that implements "),f=p("code"),x=c("PiNamedElement"),N=c(` can be a node in a model AST, similar to
xref:element-interface[`),E=p("code"),b=c("PiElement"),y=c(`]
implementations. The difference is that `),h=p("code"),T=c("PiNamedElements"),w=c(" have a name property."),k=D(),m=p("pre"),this.h()},l(e){s=r(e,"H1",{});var l=d(s);P=i(l,"PiNamedElement"),l.forEach(t),_=H(e),a=r(e,"P",{});var o=d(a);v=i(o,"An object that implements "),f=r(o,"CODE",{});var C=d(f);x=i(C,"PiNamedElement"),C.forEach(t),N=i(o,` can be a node in a model AST, similar to
xref:element-interface[`),E=r(o,"CODE",{});var S=d(E);b=i(S,"PiElement"),S.forEach(t),y=i(o,`]
implementations. The difference is that `),h=r(o,"CODE",{});var j=d(h);T=i(j,"PiNamedElements"),j.forEach(t),w=i(o," have a name property."),o.forEach(t),k=H(e),m=r(e,"PRE",{class:!0});var g=d(m);g.forEach(t),this.h()},h(){M(m,"class","language-ts")},m(e,l){u(e,s,l),n(s,P),u(e,_,l),u(e,a,l),n(a,v),n(a,f),n(f,x),n(a,N),n(a,E),n(E,b),n(a,y),n(a,h),n(h,T),n(a,w),u(e,k,l),u(e,m,l),m.innerHTML=F},p:A,i:A,o:A,d(e){e&&t(s),e&&t(_),e&&t(a),e&&t(k),e&&t(m)}}}class B extends q{constructor(s){super();I(this,s,null,R,L,{})}}export{B as default};
