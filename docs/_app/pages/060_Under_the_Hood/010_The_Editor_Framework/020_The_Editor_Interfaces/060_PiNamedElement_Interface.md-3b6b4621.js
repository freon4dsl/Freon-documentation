import{S as F,i as I,s as J,e as p,t as c,k as H,c as r,a as d,h as i,d as t,m as O,b as L,g as u,H as n,J as A}from"../../../../chunks/vendor-0dc77bd0.js";function M(j){let s,P,_,a,v,f,x,N,E,y,b,h,T,w,k,m,g=`<code class="language-ts"><span class="token comment">/* File: core/src/language/PiNamedElement.ts  */</span>

<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">PiNamedElement</span> <span class="token keyword">extends</span> <span class="token class-name">PiElement</span> <span class="token punctuation">&#123;</span>
	name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`;return{c(){s=p("h1"),P=c("PiNamedElement"),_=H(),a=p("p"),v=c("An object that implements "),f=p("code"),x=c("PiNamedElement"),N=c(` can be a node in a model AST, similar to
xref:element-interface[`),E=p("code"),y=c("PiElement"),b=c(`]
implementations. The difference is that `),h=p("code"),T=c("PiNamedElements"),w=c(" have a name property."),k=H(),m=p("pre"),this.h()},l(e){s=r(e,"H1",{});var l=d(s);P=i(l,"PiNamedElement"),l.forEach(t),_=O(e),a=r(e,"P",{});var o=d(a);v=i(o,"An object that implements "),f=r(o,"CODE",{});var C=d(f);x=i(C,"PiNamedElement"),C.forEach(t),N=i(o,` can be a node in a model AST, similar to
xref:element-interface[`),E=r(o,"CODE",{});var S=d(E);y=i(S,"PiElement"),S.forEach(t),b=i(o,`]
implementations. The difference is that `),h=r(o,"CODE",{});var D=d(h);T=i(D,"PiNamedElements"),D.forEach(t),w=i(o," have a name property."),o.forEach(t),k=O(e),m=r(e,"PRE",{class:!0});var q=d(m);q.forEach(t),this.h()},h(){L(m,"class","language-ts")},m(e,l){u(e,s,l),n(s,P),u(e,_,l),u(e,a,l),n(a,v),n(a,f),n(f,x),n(a,N),n(a,E),n(E,y),n(a,b),n(a,h),n(h,T),n(a,w),u(e,k,l),u(e,m,l),m.innerHTML=g},p:A,i:A,o:A,d(e){e&&t(s),e&&t(_),e&&t(a),e&&t(k),e&&t(m)}}}class z extends F{constructor(s){super();I(this,s,null,M,J,{})}}export{z as default};
