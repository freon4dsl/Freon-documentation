// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import { Flow, FlowRule, PageTransition, Topic, Page, Grade } from "../../language/gen/index.js";
import { EducationSyntaxAnalyser } from "./EducationSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class FlowSyntaxAnalyserPart {
    mainAnalyser: EducationSyntaxAnalyser;

    constructor(mainAnalyser: EducationSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Flow = identifier 'for' 'topic' __fre_reference
     *	 FlowRule* ;
     * @param branch
     * @private
     */
    public transformFlow(branch: SPPTBranch): Flow {
        // console.log('transformFlow called: ' + branch.name);
        let __name: string;
        let __topic: FreNodeReference<Topic>;
        let __rules: FlowRule[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __topic = this.mainAnalyser.freNodeRef<Topic>(children[3], "Topic"); // RHSRefEntry
        // RHSPartListEntry
        if (children[4].name !== "FlowRule") {
            __rules = this.mainAnalyser.transformSharedPackedParseTreeList<FlowRule>(children[4]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __rules = [];
            for (const child of children) {
                __rules.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return Flow.create({
            name: __name,
            topic: __topic,
            rules: __rules,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FlowRule = '-------------------------------------'
     *	 'Name:' identifier
     *	 'Description:' stringLiteral
     *	 'For' 'page' __fre_reference
     *	 PageTransition* ;
     * @param branch
     * @private
     */
    public transformFlowRule(branch: SPPTBranch): FlowRule {
        // console.log('transformFlowRule called: ' + branch.name);
        let __name: string;
        let __description: string;
        let __page: FreNodeReference<Page>;
        let __transitions: PageTransition[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPrimEntry
        __description = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        __page = this.mainAnalyser.freNodeRef<Page>(children[7], "Page"); // RHSRefEntry
        // RHSPartListEntry
        if (children[8].name !== "PageTransition") {
            __transitions = this.mainAnalyser.transformSharedPackedParseTreeList<PageTransition>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __transitions = [];
            for (const child of children) {
                __transitions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return FlowRule.create({
            name: __name,
            description: __description,
            page: __page,
            transitions: __transitions,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * PageTransition = 'when' Grade 'goto' 'page' __fre_reference ;
     * @param branch
     * @private
     */
    public transformPageTransition(branch: SPPTBranch): PageTransition {
        // console.log('transformPageTransition called: ' + branch.name);
        let __condition: FreNodeReference<Grade>;
        let __toPage: FreNodeReference<Page>;
        const children = this.mainAnalyser.getChildren(branch);
        __condition = this.mainAnalyser.freNodeRef<Grade>(children[1], "Grade"); // RHSLimitedRefEntry
        __toPage = this.mainAnalyser.freNodeRef<Page>(children[4], "Page"); // RHSRefEntry

        return PageTransition.create({
            condition: __condition,
            toPage: __toPage,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }
}
