// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import { Test, Scenario, Step, Topic, Flow, Page } from "../../language/gen/index.js";
import { EducationSyntaxAnalyser } from "./EducationSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class TestSyntaxAnalyserPart {
    mainAnalyser: EducationSyntaxAnalyser;

    constructor(mainAnalyser: EducationSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Test = 'Test' identifier '\{'
     *	 'scenarios'
     *	 Scenario*
     *	 'topic' __fre_reference
     *	 'flow' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformTest(branch: SPPTBranch): Test {
        // console.log('transformTest called: ' + branch.name);
        let __name: string;
        let __scenarios: Scenario[];
        let __topic: FreNodeReference<Topic>;
        let __flow: FreNodeReference<Flow>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[4].name !== "Scenario") {
            __scenarios = this.mainAnalyser.transformSharedPackedParseTreeList<Scenario>(children[4]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __scenarios = [];
            for (const child of children) {
                __scenarios.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        __topic = this.mainAnalyser.freNodeRef<Topic>(children[6], "Topic"); // RHSRefEntry
        __flow = this.mainAnalyser.freNodeRef<Flow>(children[8], "Flow"); // RHSRefEntry

        return Test.create({
            name: __name,
            scenarios: __scenarios,
            topic: __topic,
            flow: __flow,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Scenario = 'Scenario' '\{'
     *	 'description' stringLiteral
     *	 'steps'
     *	 Step*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformScenario(branch: SPPTBranch): Scenario {
        // console.log('transformScenario called: ' + branch.name);
        let __description: string;
        let __steps: Step[];
        const children = this.mainAnalyser.getChildren(branch);
        __description = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[5].name !== "Step") {
            __steps = this.mainAnalyser.transformSharedPackedParseTreeList<Step>(children[5]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __steps = [];
            for (const child of children) {
                __steps.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return Scenario.create({
            description: __description,
            steps: __steps,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Step = 'Step' '\{'
     *	 'fromPage' __fre_reference
     *	 'expectedPage' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformStep(branch: SPPTBranch): Step {
        // console.log('transformStep called: ' + branch.name);
        let __fromPage: FreNodeReference<Page>;
        let __expectedPage: FreNodeReference<Page>;
        const children = this.mainAnalyser.getChildren(branch);
        __fromPage = this.mainAnalyser.freNodeRef<Page>(children[3], "Page"); // RHSRefEntry
        __expectedPage = this.mainAnalyser.freNodeRef<Page>(children[5], "Page"); // RHSRefEntry

        return Step.create({
            fromPage: __fromPage,
            expectedPage: __expectedPage,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }
}
