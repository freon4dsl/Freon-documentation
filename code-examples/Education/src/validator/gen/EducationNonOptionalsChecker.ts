// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreWriter, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    Education,
    Flow,
    Topic,
    Test,
    FlowRule,
    PageTransition,
    Grade,
    GradeScore,
    QuestionReference,
    NumberLiteralExpression,
    BinaryExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessOrEqualsExpression,
    GreaterOrEqualsExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
    Page,
    Theory,
    Line,
    Video,
    WorkSheet,
    ExamplePage,
    InDepthMaterial,
    Question,
    SimpleNumber,
    Fraction,
    Scenario,
    Step,
} from "../../language/gen/index.js";
import { EducationDefaultWorker } from "../../utils/gen/index.js";
import { EducationCheckerInterface } from "./EducationValidator.js";

/**
 * Class EducationNonOptionalsChecker is part of the implementation of the default validator.
 * It checks whether non-optional properties, as such defined in the .ast definition, indeed
 * have a value.
 * Class EducationWalker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class EducationNonOptionalsChecker extends EducationDefaultWorker implements EducationCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeEducation(modelelement: Education): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.description === null || modelelement.description === undefined || modelelement.description?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'description' must have a value",
                    modelelement,
                    modelelement.name,
                    "description",
                    FreErrorSeverity.Error,
                ),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeFlow(modelelement: Flow): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.topic === null || modelelement.topic === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'topic' must have a value", modelelement, modelelement.name, "topic", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeTopic(modelelement: Topic): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.description === null || modelelement.description === undefined || modelelement.description?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'description' must have a value",
                    modelelement,
                    modelelement.name,
                    "description",
                    FreErrorSeverity.Error,
                ),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeTest(modelelement: Test): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.topic === null || modelelement.topic === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'topic' must have a value", modelelement, modelelement.name, "topic", FreErrorSeverity.Error),
            );
        }
        if (modelelement.flow === null || modelelement.flow === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'flow' must have a value", modelelement, modelelement.name, "flow", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeFlowRule(modelelement: FlowRule): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.description === null || modelelement.description === undefined || modelelement.description?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'description' must have a value",
                    modelelement,
                    modelelement.name,
                    "description",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.page === null || modelelement.page === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'page' must have a value", modelelement, modelelement.name, "page", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePageTransition(modelelement: PageTransition): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.condition === null || modelelement.condition === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'condition' must have a value", modelelement, "unnamed", "condition", FreErrorSeverity.Error),
            );
        }
        if (modelelement.toPage === null || modelelement.toPage === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'toPage' must have a value", modelelement, "unnamed", "toPage", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGrade(modelelement: Grade): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGradeScore(modelelement: GradeScore): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.expr === null || modelelement.expr === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'expr' must have a value", modelelement, "unnamed", "expr", FreErrorSeverity.Error));
        }
        if (modelelement.grade === null || modelelement.grade === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'grade' must have a value", modelelement, "unnamed", "grade", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeQuestionReference(modelelement: QuestionReference): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.question === null || modelelement.question === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'question' must have a value", modelelement, "unnamed", "question", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeNumberLiteralExpression(modelelement: NumberLiteralExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.value === null || modelelement.value === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'value' must have a value", modelelement, "unnamed", "value", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeBinaryExpression(modelelement: BinaryExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeAndExpression(modelelement: AndExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeOrExpression(modelelement: OrExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeComparisonExpression(modelelement: ComparisonExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeLessOrEqualsExpression(modelelement: LessOrEqualsExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGreaterOrEqualsExpression(modelelement: GreaterOrEqualsExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeLessThenExpression(modelelement: LessThenExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGreaterThenExpression(modelelement: GreaterThenExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeEqualsExpression(modelelement: EqualsExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePage(modelelement: Page): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.grading === null || modelelement.grading === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'grading' must have a value", modelelement, modelelement.name, "grading", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeTheory(modelelement: Theory): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.grading === null || modelelement.grading === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'grading' must have a value", modelelement, modelelement.name, "grading", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeLine(modelelement: Line): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.content === null || modelelement.content === undefined || modelelement.content?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'content' must have a value", modelelement, "unnamed", "content", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeVideo(modelelement: Video): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.url === null || modelelement.url === undefined || modelelement.url?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'url' must have a value", modelelement, modelelement.name, "url", FreErrorSeverity.Error),
            );
        }
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.grading === null || modelelement.grading === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'grading' must have a value", modelelement, modelelement.name, "grading", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeWorkSheet(modelelement: WorkSheet): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.grading === null || modelelement.grading === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'grading' must have a value", modelelement, modelelement.name, "grading", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeExamplePage(modelelement: ExamplePage): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.grading === null || modelelement.grading === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'grading' must have a value", modelelement, modelelement.name, "grading", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeInDepthMaterial(modelelement: InDepthMaterial): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.grading === null || modelelement.grading === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'grading' must have a value", modelelement, modelelement.name, "grading", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeQuestion(modelelement: Question): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.content === null || modelelement.content === undefined || modelelement.content?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'content' must have a value", modelelement, modelelement.name, "content", FreErrorSeverity.Error),
            );
        }
        if (modelelement.correctAnswer === null || modelelement.correctAnswer === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'correctAnswer' must have a value",
                    modelelement,
                    modelelement.name,
                    "correctAnswer",
                    FreErrorSeverity.Error,
                ),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeSimpleNumber(modelelement: SimpleNumber): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.value === null || modelelement.value === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'value' must have a value", modelelement, "unnamed", "value", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeFraction(modelelement: Fraction): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.numerator === null || modelelement.numerator === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'numerator' must have a value", modelelement, "unnamed", "numerator", FreErrorSeverity.Error),
            );
        }
        if (modelelement.denominator === null || modelelement.denominator === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'denominator' must have a value", modelelement, "unnamed", "denominator", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeScenario(modelelement: Scenario): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.description === null || modelelement.description === undefined || modelelement.description?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'description' must have a value", modelelement, "unnamed", "description", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeStep(modelelement: Step): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.fromPage === null || modelelement.fromPage === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'fromPage' must have a value", modelelement, "unnamed", "fromPage", FreErrorSeverity.Error),
            );
        }
        if (modelelement.expectedPage === null || modelelement.expectedPage === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'expectedPage' must have a value", modelelement, "unnamed", "expectedPage", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }
}
