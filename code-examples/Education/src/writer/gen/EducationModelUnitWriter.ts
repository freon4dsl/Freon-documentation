// Generated by the Freon Language Generator.
import { FreNamedNode, FreNodeReference, FreWriter, FreNode } from "@freon4dsl/core";
import {
    Flow,
    Topic,
    Test,
    FlowRule,
    PageTransition,
    Grade,
    GradeList,
    GradeScore,
    ScoreExpression,
    QuestionReference,
    NrOfCorrectAnswers,
    NumberLiteralExpression,
    BinaryExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessOrEqualsExpression,
    GreaterOrEqualsExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
    Page,
    Theory,
    Line,
    Video,
    WorkSheet,
    ExamplePage,
    InDepthMaterial,
    Question,
    NumberConcept,
    SimpleNumber,
    Fraction,
    Scenario,
    Step,
} from "../../language/gen/index.js";

/**
 * SeparatorType is used to unparse lists.
 * NONE means only space(s) between the elements.
 * Terminator means that every element is terminated with a certain string.
 * Separator means that in between elements a certain string is placed.
 */
enum SeparatorType {
    NONE = "NONE",
    Terminator = "Terminator",
    Separator = "Separator",
    Initiator = "Initiator",
}

/**
 * Class EducationModelUnitWriter provides methods to return a string representation of an instance of
 * elements of language Education.
 * It is, amongst others, used to create error messages in the validator.
 */
export class EducationModelUnitWriter implements FreWriter {
    output: string[] = []; // stores the result, one line per array element
    currentLine: number = 0; // keeps track of the element in 'output' that we are working on

    /**
     * Returns a string representation of 'modelelement'.
     * If 'short' is present and true, then a single-line result will be given.
     * Otherwise, the result is always a multi-line string.
     * Note that the single-line-string cannot be parsed into a correct model.
     *
     * @param modelelement
     * @param startIndent
     * @param short
     */
    public writeToString(modelelement: FreNode, startIndent?: number, short?: boolean): string {
        this.writeToLines(modelelement, startIndent, short);
        return `${this.output
            .map((line) => `${line.trimEnd()}`)
            .join("\n")
            .trimEnd()}`;
    }

    /**
     * Returns a string representation of 'modelelement', divided into an array of strings,
     * each of which contain a single line (without newline).
     * If 'short' is present and true, then a single-line result will be given.
     * Otherwise, the result is always a multi-line string.
     *
     * @param modelelement
     * @param startIndent
     * @param short
     */
    public writeToLines(modelelement: FreNode, startIndent?: number, short?: boolean): string[] {
        // set default for optional parameters
        if (startIndent === undefined) {
            startIndent = 0;
        }
        if (short === undefined) {
            short = false;
        }

        // make sure the global variables are reset
        this.output = [];
        this.currentLine = 0;

        // begin the unparsing with an indent if asked for
        let indentString: string = "";
        for (let _i = 0; _i < startIndent; _i++) {
            indentString += " ";
        }
        this.output[this.currentLine] = indentString;

        // do the actual work
        this.unparse(modelelement, short);
        return this.output;
    }

    /**
     * Returns the name of 'modelelement' if it has one, else returns
     * a short unparsing of 'modelelement'.
     * Used by the validator to produce readable error messages.
     *
     * @param modelelement
     */
    public writeNameOnly(modelelement: FreNode): string {
        if (!modelelement) {
            return "";
        }

        if (modelelement instanceof Flow) {
            return modelelement.name;
        } else if (modelelement instanceof Topic) {
            return modelelement.name;
        } else if (modelelement instanceof Test) {
            return modelelement.name;
        } else if (modelelement instanceof FlowRule) {
            return modelelement.name;
        } else if (modelelement instanceof Grade) {
            return modelelement.name;
        } else if (modelelement instanceof Page) {
            return modelelement.name;
        } else if (modelelement instanceof Theory) {
            return modelelement.name;
        } else if (modelelement instanceof Video) {
            return modelelement.name;
        } else if (modelelement instanceof WorkSheet) {
            return modelelement.name;
        } else if (modelelement instanceof ExamplePage) {
            return modelelement.name;
        } else if (modelelement instanceof InDepthMaterial) {
            return modelelement.name;
        } else if (modelelement instanceof Question) {
            return modelelement.name;
        } else {
            // make sure the global variables are reset
            this.output = [];
            this.currentLine = 0;
            // do not care about indent, we just need a single line
            this.output[this.currentLine] = "";
            // do the actual work
            this.unparse(modelelement, true);
            return this.output[0].trimEnd();
        }
    }

    private unparse(modelelement: FreNode, short: boolean) {
        if (!modelelement) {
            return;
        }
        switch (modelelement.freLanguageConcept()) {
            case "FlowRule":
                this.unparseFlowRule(modelelement as FlowRule, short);
                break;
            case "PageTransition":
                this.unparsePageTransition(modelelement as PageTransition, short);
                break;
            case "Grade":
                this.unparseGrade(modelelement as Grade, short);
                break;
            case "GradeList":
                this.unparseGradeList(modelelement as GradeList, short);
                break;
            case "GradeScore":
                this.unparseGradeScore(modelelement as GradeScore, short);
                break;
            case "ScoreExpression":
                this.unparseScoreExpression(modelelement as ScoreExpression, short);
                break;
            case "QuestionReference":
                this.unparseQuestionReference(modelelement as QuestionReference, short);
                break;
            case "NrOfCorrectAnswers":
                this.unparseNrOfCorrectAnswers(modelelement as NrOfCorrectAnswers, short);
                break;
            case "NumberLiteralExpression":
                this.unparseNumberLiteralExpression(modelelement as NumberLiteralExpression, short);
                break;
            case "BinaryExpression":
                this.unparseBinaryExpression(modelelement as BinaryExpression, short);
                break;
            case "AndExpression":
                this.unparseAndExpression(modelelement as AndExpression, short);
                break;
            case "OrExpression":
                this.unparseOrExpression(modelelement as OrExpression, short);
                break;
            case "ComparisonExpression":
                this.unparseComparisonExpression(modelelement as ComparisonExpression, short);
                break;
            case "LessOrEqualsExpression":
                this.unparseLessOrEqualsExpression(modelelement as LessOrEqualsExpression, short);
                break;
            case "GreaterOrEqualsExpression":
                this.unparseGreaterOrEqualsExpression(modelelement as GreaterOrEqualsExpression, short);
                break;
            case "LessThenExpression":
                this.unparseLessThenExpression(modelelement as LessThenExpression, short);
                break;
            case "GreaterThenExpression":
                this.unparseGreaterThenExpression(modelelement as GreaterThenExpression, short);
                break;
            case "EqualsExpression":
                this.unparseEqualsExpression(modelelement as EqualsExpression, short);
                break;
            case "Page":
                this.unparsePage(modelelement as Page, short);
                break;
            case "Theory":
                this.unparseTheory(modelelement as Theory, short);
                break;
            case "Line":
                this.unparseLine(modelelement as Line, short);
                break;
            case "Video":
                this.unparseVideo(modelelement as Video, short);
                break;
            case "WorkSheet":
                this.unparseWorkSheet(modelelement as WorkSheet, short);
                break;
            case "ExamplePage":
                this.unparseExamplePage(modelelement as ExamplePage, short);
                break;
            case "InDepthMaterial":
                this.unparseInDepthMaterial(modelelement as InDepthMaterial, short);
                break;
            case "Question":
                this.unparseQuestion(modelelement as Question, short);
                break;
            case "NumberConcept":
                this.unparseNumberConcept(modelelement as NumberConcept, short);
                break;
            case "SimpleNumber":
                this.unparseSimpleNumber(modelelement as SimpleNumber, short);
                break;
            case "Fraction":
                this.unparseFraction(modelelement as Fraction, short);
                break;
            case "Scenario":
                this.unparseScenario(modelelement as Scenario, short);
                break;
            case "Step":
                this.unparseStep(modelelement as Step, short);
                break;
            case "Flow":
                this.unparseFlow(modelelement as Flow, short);
                break;
            case "Topic":
                this.unparseTopic(modelelement as Topic, short);
                break;
            case "Test":
                this.unparseTest(modelelement as Test, short);
                break;
        }
    }

    /**
     * Unparsing of 'Flow' according to projection 'default'.
     */
    private unparseFlow(modelelement: Flow, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `for topic `;
        this._unparseReference(modelelement.topic, short);

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 0);
            this._unparseList(
                modelelement.rules,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
        }
    }

    /**
     * Unparsing of 'FlowRule' according to projection 'default'.
     */
    private unparseFlowRule(modelelement: FlowRule, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `------------------------------------- `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `Name: `;
            this.output[this.currentLine] += `${modelelement.name} `;
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Description: `;
            this.output[this.currentLine] += `"${modelelement.description}" `;
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `For page `;
            this._unparseReference(modelelement.page, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this._unparseList(
                modelelement.transitions,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
        }
    }

    /**
     * Unparsing of 'PageTransition' according to projection 'default'.
     */
    private unparsePageTransition(modelelement: PageTransition, short: boolean) {
        this.output[this.currentLine] += `when `;
        this._unparseReference(modelelement.condition, short);
        this.output[this.currentLine] += `goto page `;
        this._unparseReference(modelelement.toPage, short);
    }

    /**
     * Unparsing of 'Topic' according to projection 'default'.
     */
    private unparseTopic(modelelement: Topic, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Topic: `;
        this.output[this.currentLine] += `${modelelement.name} `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `Description: `;
            this.output[this.currentLine] += `"${modelelement.description}" `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `Pages: `;
            this.newlineAndIndentation(blockIndent + 0);
            this._unparseList(
                modelelement.pages,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
        }
    }

    /**
     * Unparsing of 'Page' according to projection 'default'.
     */
    private unparsePage(modelelement: Page, short: boolean) {
        this.output[this.currentLine] += `${modelelement.name} `;
    }

    /**
     * Unparsing of 'Theory' according to projection 'default'.
     */
    private unparseTheory(modelelement: Theory, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `---------------------------------------------------- `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `Theory `;
            this.unparsePage(modelelement, short);
            this.newlineAndIndentation(blockIndent + 4);
            this._unparseList(
                modelelement.content,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this.unparsePage_footing(modelelement, short);
        }
    }

    /**
     * Unparsing of 'Video' according to projection 'default'.
     */
    private unparseVideo(modelelement: Video, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `---------------------------------------------------- `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `Video `;
            this.unparsePage(modelelement, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Maybe this video will help you understand. `;
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `"${modelelement.url}" `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this.unparsePage_footing(modelelement, short);
        }
    }

    /**
     * Unparsing of 'WorkSheet' according to projection 'default'.
     */
    private unparseWorkSheet(modelelement: WorkSheet, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `---------------------------------------------------- `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `Worksheet `;
            this.unparsePage(modelelement, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `See if you can answer the following questions. `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this.unparsePage_footing(modelelement, short);
        }
    }

    /**
     * Unparsing of 'ExamplePage' according to projection 'default'.
     */
    private unparseExamplePage(modelelement: ExamplePage, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `---------------------------------------------------- `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `Example `;
            this.unparsePage(modelelement, short);
            this.newlineAndIndentation(blockIndent + 4);
            this._unparseList(
                modelelement.content,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Now, please, answer the following questions. `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this.unparsePage_footing(modelelement, short);
        }
    }

    /**
     * Unparsing of 'InDepthMaterial' according to projection 'default'.
     */
    private unparseInDepthMaterial(modelelement: InDepthMaterial, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `---------------------------------------------------- `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.unparsePage(modelelement, short);
            this.newlineAndIndentation(blockIndent + 4);
            this._unparseList(
                modelelement.content,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Test your understanding by answering the following questions. `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += "";
            ("");
            this.newlineAndIndentation(blockIndent + 4);
            this.unparsePage_footing(modelelement, short);
        }
    }

    /**
     * Unparsing of 'Question' according to projection 'default'.
     */
    private unparseQuestion(modelelement: Question, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `${modelelement.name} `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `"${modelelement.content}" `;
        }
    }

    /**
     * Unparsing of 'GradeList' according to projection 'default'.
     */
    private unparseGradeList(modelelement: GradeList, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `GradeList `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `list `;
            this.newlineAndIndentation(blockIndent + 8);
            this._unparseList(
                modelelement.list,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'GradeScore' according to projection 'default'.
     */
    private unparseGradeScore(modelelement: GradeScore, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `GradeScore `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `expr `;
            this.unparse(modelelement.expr, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `grade `;
            this._unparseReference(modelelement.grade, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'QuestionReference' according to projection 'default'.
     */
    private unparseQuestionReference(modelelement: QuestionReference, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `QuestionReference `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `question `;
            this._unparseReference(modelelement.question, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'NrOfCorrectAnswers' according to projection 'default'.
     */
    private unparseNrOfCorrectAnswers(modelelement: NrOfCorrectAnswers, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `NrOfCorrectAnswers `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'NumberLiteralExpression' according to projection 'default'.
     */
    private unparseNumberLiteralExpression(modelelement: NumberLiteralExpression, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `NumberLiteralExpression `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `value `;
            this.output[this.currentLine] += `${modelelement.value} `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'Line' according to projection 'default'.
     */
    private unparseLine(modelelement: Line, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Line `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `content `;
            this.output[this.currentLine] += `"${modelelement.content}" `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'SimpleNumber' according to projection 'default'.
     */
    private unparseSimpleNumber(modelelement: SimpleNumber, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `SimpleNumber `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `value `;
            this.output[this.currentLine] += `${modelelement.value} `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'Fraction' according to projection 'default'.
     */
    private unparseFraction(modelelement: Fraction, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Fraction `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `numerator `;
            this.output[this.currentLine] += `${modelelement.numerator} `;
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `denominator `;
            this.output[this.currentLine] += `${modelelement.denominator} `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'Scenario' according to projection 'default'.
     */
    private unparseScenario(modelelement: Scenario, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Scenario `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `description `;
            this.output[this.currentLine] += `"${modelelement.description}" `;
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `steps `;
            this.newlineAndIndentation(blockIndent + 8);
            this._unparseList(
                modelelement.steps,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'Step' according to projection 'default'.
     */
    private unparseStep(modelelement: Step, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Step `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `fromPage `;
            this._unparseReference(modelelement.fromPage, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `expectedPage `;
            this._unparseReference(modelelement.expectedPage, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'Test' according to projection 'default'.
     */
    private unparseTest(modelelement: Test, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Test `;
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `scenarios `;
            this.newlineAndIndentation(blockIndent + 8);
            this._unparseList(
                modelelement.scenarios,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `topic `;
            this._unparseReference(modelelement.topic, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `flow `;
            this._unparseReference(modelelement.flow, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }
    /**
     * See the public unparse method.
     */
    private unparseAndExpression(modelelement: AndExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "AndExpression ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseOrExpression(modelelement: OrExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "OrExpression ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseLessOrEqualsExpression(modelelement: LessOrEqualsExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "LessOrEqualsExpression ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseGreaterOrEqualsExpression(modelelement: GreaterOrEqualsExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "GreaterOrEqualsExpression ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseLessThenExpression(modelelement: LessThenExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "LessThenExpression ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseGreaterThenExpression(modelelement: GreaterThenExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "GreaterThenExpression ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseEqualsExpression(modelelement: EqualsExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "EqualsExpression ";
        this.unparse(modelelement.right, short);
    }
    /**
     * The limited concept 'Grade' is unparsed as its name.
     */
    private unparseGrade(modelelement: Grade, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The abstract concept 'ScoreExpression' is not unparsed.
     */
    private unparseScoreExpression(modelelement: ScoreExpression, short: boolean) {
        throw new Error("Method unparseScoreExpression should be implemented by its (concrete) subclasses.");
    }
    /**
     * The abstract concept 'BinaryExpression' is not unparsed.
     */
    private unparseBinaryExpression(modelelement: BinaryExpression, short: boolean) {
        throw new Error("Method unparseBinaryExpression should be implemented by its (concrete) subclasses.");
    }
    /**
     * The abstract concept 'ComparisonExpression' is not unparsed.
     */
    private unparseComparisonExpression(modelelement: ComparisonExpression, short: boolean) {
        throw new Error("Method unparseComparisonExpression should be implemented by its (concrete) subclasses.");
    }
    /**
     * The abstract concept 'NumberConcept' is not unparsed.
     */
    private unparseNumberConcept(modelelement: NumberConcept, short: boolean) {
        throw new Error("Method unparseNumberConcept should be implemented by its (concrete) subclasses.");
    }

    /**
     * Unparsing of 'Page' according to projection 'footing'.
     */
    private unparsePage_footing(modelelement: Page, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Questions: `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this._unparseList(
                modelelement.questions,
                ". ",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
        }
    }

    /**
     *
     */
    private _unparseReference(modelelement: FreNodeReference<FreNamedNode>, short: boolean) {
        if (!!modelelement) {
            const type: FreNamedNode = modelelement?.referred;
            if (!!type) {
                if (type instanceof Grade) {
                    this.unparseGrade(type, short);
                } else {
                    this.output[this.currentLine] += modelelement.pathnameToString(".") + " ";
                }
            } else {
                this.output[this.currentLine] += modelelement.pathnameToString(".") + " ";
            }
        }
    }

    /**
     * Adds a string representation of 'list' to the 'output', using 'sepText' , and 'sepType' to include either a separator string
     * or a terminator string. Param 'vertical' indicates whether the list should be represented vertically or horizontally.
     * If 'short' is false, then a multi-line result will be given. Otherwise, only one single-line string is added.
     * @param list
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     * @param method
     * @private
     */
    private _unparseList(
        list: FreNode[],
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean,
        method: (modelelement: FreNode, short: boolean) => void,
    ) {
        list.forEach((listElem, index) => {
            const isLastInList: boolean = index === list.length - 1;
            this.doInitiator(sepText, sepType);
            method(listElem, short);
            this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
        });
    }

    /**
     * Adds a string representation of a list of references, where every reference
     * is replaced by the name of its referred element. The use of params
     * 'sepText' and 'SepType' are equals to those in the private method _unparseList.
     * @param list
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     */
    private _unparseReferenceList(
        list: FreNodeReference<FreNamedNode>[],
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean,
    ) {
        list.forEach((listElem, index) => {
            const isLastInList: boolean = index === list.length - 1;
            this.doInitiator(sepText, sepType);
            this._unparseReference(listElem, short);
            this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
        });
    }

    /**
     * Adds a string representation of 'list' to the 'output', using 'sepText' , and 'sepType' to include either a separator string
     * or a terminator string. Param 'vertical' indicates whether the list should be represented vertically or horizontally.
     * If 'short' is false, then a multi-line result will be given. Otherwise, only one single-line string is added.
     * @param list
     * @param isIdentifier indicates whether the value should be surrounded with double quotes
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     */
    private _unparseListOfPrimitiveValues(
        list: (string | number | boolean)[],
        isIdentifier: boolean,
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean,
    ) {
        if (!!list) {
            list.forEach((listElem, index) => {
                const isLastInList: boolean = index === list.length - 1;
                if (typeof listElem === "string" && !isIdentifier) {
                    this.output[this.currentLine] += `"${listElem}"`;
                } else {
                    this.output[this.currentLine] += `${listElem}`;
                }
                this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
            });
        }
    }

    /**
     * Adds a separator, terminator, or initiator text (followed or preceded by a newline and the right amount of indentation)
     * to the output, depending on the parameters.
     * @param sepType
     * @param isLastInList
     * @param sepText
     * @param vertical
     * @param short
     * @param indent
     */
    // tslint:disable-next-line:max-line-length
    private doSeparatorOrTerminatorAndNewline(
        sepType: SeparatorType,
        isLastInList: boolean,
        sepText: string,
        vertical: boolean,
        short: boolean,
        indent: number,
    ) {
        // first eliminate any whitespace at the end of the line
        this.output[this.currentLine] = this.output[this.currentLine].trimEnd();

        if (!vertical && (!sepText || sepText.length == 0)) {
            // at least separate the items by a space to avoid things
            // like "IntegerFunction", which should be "Integer Function"
            sepText = " ";
        }

        // then add the right separator or terminator
        switch (sepType) {
            case SeparatorType.Separator: {
                if (!isLastInList) {
                    this.output[this.currentLine] += sepText;
                }
                break;
            }
            case SeparatorType.Terminator: {
                this.output[this.currentLine] += sepText;
                break;
            }
            case SeparatorType.Initiator: {
                break;
            }
            case SeparatorType.NONE: {
                if (!vertical) {
                    // at least separate the items by a space to avoid things
                    // like "IntegerFunction", which should be "Integer Function"
                    this.output[this.currentLine] += " ";
                }
                break;
            }
        }

        // then add newline and indentation
        if (vertical && !isLastInList) {
            if (!short) {
                this.newlineAndIndentation(indent);
            } else {
                // stop after 1 line
                // note that the following cannot be parsed
                this.output[this.currentLine] += ` ...`;
            }
        } else if (isLastInList) {
            // end with a space to avoid things
            // like "666after", which should be "666 after"
            if (this.output[this.currentLine][this.output[this.currentLine].length - 1] !== " ") {
                this.output[this.currentLine] += ` `;
            }
        }
    }

    /**
     * Makes a new entry in the 'output' array
     * and adds the indentation of 'number' spaces
     * to the new entry/line.
     * @param indent
     */
    private newlineAndIndentation(indent: number) {
        this.currentLine += 1;
        let indentation: string = "";
        for (let _i = 0; _i < indent; _i++) {
            indentation += " ";
        }
        this.output[this.currentLine] = indentation;
    }

    /**
     * Adds the 'initiator' text
     * @param sepText
     * @param sepType
     * @private
     */
    private doInitiator(sepText: string, sepType: SeparatorType) {
        if (sepType === SeparatorType.Initiator) {
            this.output[this.currentLine] += sepText;
        }
    }
}
