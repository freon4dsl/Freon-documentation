// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreCompositeTyper, FreWriter, FreNamedNode, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    DocuExpression,
    Literal,
    EuroLiteral,
    NumberLiteral,
    PercentageLiteral,
    BooleanLiteral,
    BinaryExpression,
    PlusExpression,
    MinusExpression,
    MultiplyExpression,
    DivideExpression,
    FunctionCallExpression,
    InsurancePartRef,
    RiskAdjustmentRef,
    ParameterRef,
    AttributeRef,
    RiskRef,
    PayoutRef,
    Text,
    Text2,
    Text3,
    Text4,
    GenericKind,
    GenericTypeDecl,
    GenericLiteral,
    Entity,
    EntityAttribute,
    BaseProduct,
    InsurancePart,
    InsuranceProduct,
    CalcFunction,
    Description,
    Parameter,
    DocuType,
    InsurancePartType,
    PercentageType,
    NumberType,
    BooleanType,
    EuroType,
    TypeRef,
    InsuranceTheme,
    PremiumDays,
    NamedType,
    Part,
    Product,
} from "../../language/gen/index.js";
import { InsuranceModelDefaultWorker } from "../../utils/gen/index.js";
import { InsuranceModelCheckerInterface } from "./InsuranceModelValidator.js";
import { reservedWordsInTypescript } from "./ReservedWords.js";

/**
 * Class InsuranceModelValidationRulesChecker is the part of validator that is generated from, if present,
 * the validator definition. As the other checkers, it uses the visitor pattern.
 * Class InsuranceModelDefaultWorker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class InsuranceModelValidationRulesChecker extends InsuranceModelDefaultWorker implements InsuranceModelCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'typer' is used to implement the 'typecheck' rules in the validator definition
    typer: FreCompositeTyper = FreLanguageEnvironment.getInstance().typer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeInsuranceProduct(modelelement: InsuranceProduct): boolean {
        let hasFatalError: boolean = false;
        // @notEmpty parts
        if (modelelement.parts.length === 0) {
            this.errorList.push(
                new FreError("List 'parts' may not be empty", modelelement, modelelement.name, "parts", FreErrorSeverity.NONE),
            );
        } // isunique name in parts
        let uniqueNameInParts: string[] = [];
        modelelement.parts.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'parts' has no value`,
                        modelelement.parts[index].referred,
                        modelelement.name,
                        "name",
                        FreErrorSeverity.NONE,
                    ),
                );
            } else {
                if (!uniqueNameInParts.includes(elem.name)) {
                    uniqueNameInParts.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${elem.name}") is not unique in list 'parts'`,
                            modelelement.parts[index].referred,
                            modelelement.name,
                            "name",
                            FreErrorSeverity.NONE,
                        ),
                    );
                }
            }
        }); // isunique name in helpers
        let uniqueNameInHelpers: string[] = [];
        modelelement.helpers.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'helpers' has no value`,
                        modelelement.helpers[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.NONE,
                    ),
                );
            } else {
                if (!uniqueNameInHelpers.includes(elem.name)) {
                    uniqueNameInHelpers.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'helpers'`,
                            modelelement.helpers[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.NONE,
                        ),
                    );
                }
            }
        });
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeMinusExpression(modelelement: MinusExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, right )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(modelelement.right);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforePlusExpression(modelelement: PlusExpression): boolean {
        let hasFatalError: boolean = false;

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeMultiplyExpression(modelelement: MultiplyExpression): boolean {
        let hasFatalError: boolean = false;

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeDivideExpression(modelelement: DivideExpression): boolean {
        let hasFatalError: boolean = false;

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeBaseProduct(modelelement: BaseProduct): boolean {
        let hasFatalError: boolean = false;
        // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeInsurancePart(modelelement: InsurancePart): boolean {
        let hasFatalError: boolean = false;
        // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeCalcFunction(modelelement: CalcFunction): boolean {
        let hasFatalError: boolean = false;
        // isunique name in parameters
        let uniqueNameInParameters: string[] = [];
        modelelement.parameters.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'parameters' has no value`,
                        modelelement.parameters[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.NONE,
                    ),
                );
            } else {
                if (!uniqueNameInParameters.includes(elem.name)) {
                    uniqueNameInParameters.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'parameters'`,
                            modelelement.parameters[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.NONE,
                        ),
                    );
                }
            }
        }); // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    `El nombre '${self.name}' no es un identificador correcto.`,
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.Error,
                ),
            );
            hasFatalError = true;
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeEntityAttribute(modelelement: EntityAttribute): boolean {
        let hasFatalError: boolean = false;
        // numVal >= 12
        if (!(modelelement.numVal >= 12)) {
            this.errorList.push(new FreError("'numVal >= 12' is false", modelelement, "unnamed", FreErrorSeverity.NONE));
        } // numVal <= 30
        if (!(modelelement.numVal <= 30)) {
            this.errorList.push(new FreError("'numVal <= 30' is false", modelelement, "unnamed", FreErrorSeverity.NONE));
        }
        return hasFatalError;
    }

    /**
     * Returns true if 'name' is a valid identifier
     * @param name
     */
    private isValidName(name: string): boolean {
        if (!!!name) return false;
        // cannot start with number
        if (/[0-9]/.test(name[0])) return false;
        // may contain letters, numbers, '$', and '_', but no other characters
        if (/[.|,|!|?|@|~|%|^|&|*|-|=|+|(|)|{|}|"|'|:|;|<|>|?]/.test(name)) return false;
        if (/\\/.test(name)) return false;
        if (/[/|[|]]/.test(name)) return false;
        // may not contain whitespaces
        if (/[\t|\n|\r| ]/.test(name)) return false;
        // may not be a Typescript keyword
        return !reservedWordsInTypescript.includes(name);
    }
}
