// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreWriter, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    InsuranceModel,
    Part,
    Product,
    EuroLiteral,
    NumberLiteral,
    PercentageLiteral,
    BooleanLiteral,
    BinaryExpression,
    PlusExpression,
    MinusExpression,
    MultiplyExpression,
    DivideExpression,
    FunctionCallExpression,
    InsurancePartRef,
    RiskAdjustmentRef,
    ParameterRef,
    AttributeRef,
    RiskRef,
    PayoutRef,
    GenericKind,
    GenericTypeDecl,
    GenericLiteral,
    Entity,
    EntityAttribute,
    BaseProduct,
    InsurancePart,
    InsuranceProduct,
    CalcFunction,
    Description,
    Parameter,
    InsurancePartType,
    PercentageType,
    NumberType,
    BooleanType,
    EuroType,
    TypeRef,
    InsuranceTheme,
    PremiumDays,
} from "../../language/gen/index.js";
import { InsuranceModelDefaultWorker } from "../../utils/gen/index.js";
import { InsuranceModelCheckerInterface } from "./InsuranceModelValidator.js";

/**
 * Class InsuranceModelNonOptionalsChecker is part of the implementation of the default validator.
 * It checks whether non-optional properties, as such defined in the .ast definition, indeed
 * have a value.
 * Class InsuranceModelWalker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class InsuranceModelNonOptionalsChecker extends InsuranceModelDefaultWorker implements InsuranceModelCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeInsuranceModel(modelelement: InsuranceModel): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePart(modelelement: Part): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.part === null || modelelement.part === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'part' must have a value", modelelement, modelelement.name, "part", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeProduct(modelelement: Product): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.product === null || modelelement.product === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'product' must have a value", modelelement, modelelement.name, "product", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeEuroLiteral(modelelement: EuroLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.euros === null || modelelement.euros === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'euros' must have a value", modelelement, "unnamed", "euros", FreErrorSeverity.Error),
            );
        }
        if (modelelement.cents === null || modelelement.cents === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'cents' must have a value", modelelement, "unnamed", "cents", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeNumberLiteral(modelelement: NumberLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.value === null || modelelement.value === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'value' must have a value", modelelement, "unnamed", "value", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePercentageLiteral(modelelement: PercentageLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.value === null || modelelement.value === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'value' must have a value", modelelement, "unnamed", "value", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeBooleanLiteral(modelelement: BooleanLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.value === null || modelelement.value === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'value' must have a value", modelelement, "unnamed", "value", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeBinaryExpression(modelelement: BinaryExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePlusExpression(modelelement: PlusExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeMinusExpression(modelelement: MinusExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeMultiplyExpression(modelelement: MultiplyExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeDivideExpression(modelelement: DivideExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeFunctionCallExpression(modelelement: FunctionCallExpression): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.funcDefinition === null || modelelement.funcDefinition === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'funcDefinition' must have a value",
                    modelelement,
                    "unnamed",
                    "funcDefinition",
                    FreErrorSeverity.Error,
                ),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeInsurancePartRef(modelelement: InsurancePartRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.part === null || modelelement.part === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'part' must have a value", modelelement, "unnamed", "part", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeRiskAdjustmentRef(modelelement: RiskAdjustmentRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeParameterRef(modelelement: ParameterRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.parameter === null || modelelement.parameter === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'parameter' must have a value", modelelement, "unnamed", "parameter", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeAttributeRef(modelelement: AttributeRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeRiskRef(modelelement: RiskRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePayoutRef(modelelement: PayoutRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGenericKind(modelelement: GenericKind): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGenericTypeDecl(modelelement: GenericTypeDecl): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.baseType === null || modelelement.baseType === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'baseType' must have a value", modelelement, "unnamed", "baseType", FreErrorSeverity.Error),
            );
        }
        if (modelelement.kind === null || modelelement.kind === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'kind' must have a value", modelelement, "unnamed", "kind", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGenericLiteral(modelelement: GenericLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.kind === null || modelelement.kind === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'kind' must have a value", modelelement, "unnamed", "kind", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeEntity(modelelement: Entity): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.isCompany === null || modelelement.isCompany === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'isCompany' must have a value",
                    modelelement,
                    modelelement.name,
                    "isCompany",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeEntityAttribute(modelelement: EntityAttribute): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.numVal === null || modelelement.numVal === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'numVal' must have a value", modelelement, "unnamed", "numVal", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeBaseProduct(modelelement: BaseProduct): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.isUnderConstruction === null || modelelement.isUnderConstruction === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'isUnderConstruction' must have a value",
                    modelelement,
                    modelelement.name,
                    "isUnderConstruction",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.isApprovedLevel1 === null || modelelement.isApprovedLevel1 === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'isApprovedLevel1' must have a value",
                    modelelement,
                    modelelement.name,
                    "isApprovedLevel1",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.isApprovedLevel2 === null || modelelement.isApprovedLevel2 === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'isApprovedLevel2' must have a value",
                    modelelement,
                    modelelement.name,
                    "isApprovedLevel2",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.isApprovedLevel3 === null || modelelement.isApprovedLevel3 === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'isApprovedLevel3' must have a value",
                    modelelement,
                    modelelement.name,
                    "isApprovedLevel3",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.yieldsProfit === null || modelelement.yieldsProfit === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'yieldsProfit' must have a value",
                    modelelement,
                    modelelement.name,
                    "yieldsProfit",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.range === null || modelelement.range === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'range' must have a value", modelelement, modelelement.name, "range", FreErrorSeverity.Error),
            );
        }
        if (modelelement.nrOfUse === null || modelelement.nrOfUse === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'nrOfUse' must have a value", modelelement, modelelement.name, "nrOfUse", FreErrorSeverity.Error),
            );
        }
        if (modelelement.date === null || modelelement.date === undefined || modelelement.date?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'date' must have a value", modelelement, modelelement.name, "date", FreErrorSeverity.Error),
            );
        }
        if (modelelement.theme === null || modelelement.theme === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'theme' must have a value", modelelement, modelelement.name, "theme", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeInsurancePart(modelelement: InsurancePart): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.isApproved === null || modelelement.isApproved === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'isApproved' must have a value",
                    modelelement,
                    modelelement.name,
                    "isApproved",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.statisticalRisk === null || modelelement.statisticalRisk === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'statisticalRisk' must have a value",
                    modelelement,
                    modelelement.name,
                    "statisticalRisk",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.maximumPayOut === null || modelelement.maximumPayOut === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'maximumPayOut' must have a value",
                    modelelement,
                    modelelement.name,
                    "maximumPayOut",
                    FreErrorSeverity.Error,
                ),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeInsuranceProduct(modelelement: InsuranceProduct): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.productName === null || modelelement.productName === undefined || modelelement.productName?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'productName' must have a value",
                    modelelement,
                    modelelement.name,
                    "productName",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.advertisedPremium === null || modelelement.advertisedPremium === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'advertisedPremium' must have a value",
                    modelelement,
                    modelelement.name,
                    "advertisedPremium",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.calculation === null || modelelement.calculation === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'calculation' must have a value",
                    modelelement,
                    modelelement.name,
                    "calculation",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.nrPremiumDays === null || modelelement.nrPremiumDays === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'nrPremiumDays' must have a value",
                    modelelement,
                    modelelement.name,
                    "nrPremiumDays",
                    FreErrorSeverity.Error,
                ),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeCalcFunction(modelelement: CalcFunction): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.declaredType === null || modelelement.declaredType === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'declaredType' must have a value",
                    modelelement,
                    modelelement.name,
                    "declaredType",
                    FreErrorSeverity.Error,
                ),
            );
        }
        if (modelelement.body === null || modelelement.body === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'body' must have a value", modelelement, modelelement.name, "body", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeDescription(modelelement: Description): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.content === null || modelelement.content === undefined || modelelement.content?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'content' must have a value", modelelement, "unnamed", "content", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeParameter(modelelement: Parameter): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.declaredType === null || modelelement.declaredType === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError(
                    "Property 'declaredType' must have a value",
                    modelelement,
                    modelelement.name,
                    "declaredType",
                    FreErrorSeverity.Error,
                ),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeInsurancePartType(modelelement: InsurancePartType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePercentageType(modelelement: PercentageType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeNumberType(modelelement: NumberType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeBooleanType(modelelement: BooleanType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeEuroType(modelelement: EuroType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeTypeRef(modelelement: TypeRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.type === null || modelelement.type === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'type' must have a value", modelelement, "unnamed", "type", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeInsuranceTheme(modelelement: InsuranceTheme): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePremiumDays(modelelement: PremiumDays): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error),
            );
        }
        if (modelelement.nrOfDays === null || modelelement.nrOfDays === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'nrOfDays' must have a value", modelelement, modelelement.name, "nrOfDays", FreErrorSeverity.Error),
            );
        }

        return hasFatalError;
    }
}
