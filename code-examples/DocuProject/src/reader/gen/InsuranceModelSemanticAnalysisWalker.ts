// Generated by the Freon Language Generator.
import {
    FunctionCallExpression,
    ParameterRef,
    InsurancePartRef,
    CalcFunction,
    Parameter,
    InsurancePart,
} from "../../language/gen/index.js";
import { InsuranceModelWorker, InsuranceModelDefaultWorker } from "../../utils/gen/index.js";
import { FreNamedNode, FreLanguage, FreLanguageEnvironment, FreNodeReference, FreNode } from "@freon4dsl/core";

export class InsuranceModelSemanticAnalysisWalker extends InsuranceModelDefaultWorker implements InsuranceModelWorker {
    changesToBeMade: Map<FreNode, FreNode> = null;

    constructor(changesToBeMade: Map<FreNode, FreNode>) {
        super();
        this.changesToBeMade = changesToBeMade;
    }

    /**
     * Test whether the references in 'modelelement' are correct.
     * If not, find possible replacements.
     * @param modelelement
     */
    public execBeforeFunctionCallExpression(modelelement: FunctionCallExpression): boolean {
        let referredElem: FreNodeReference<FreNamedNode>;
        referredElem = modelelement.funcDefinition;
        if (!!modelelement.funcDefinition && modelelement.funcDefinition.referred === null) {
            // cannot find a 'funcDefinition' with this name
            this.findReplacement(modelelement, referredElem);
        }
        return false;
    }

    /**
     * Test whether the references in 'modelelement' are correct.
     * If not, find possible replacements.
     * @param modelelement
     */
    public execBeforeParameterRef(modelelement: ParameterRef): boolean {
        let referredElem: FreNodeReference<FreNamedNode>;
        referredElem = modelelement.parameter;
        if (!!modelelement.parameter && modelelement.parameter.referred === null) {
            // cannot find a 'parameter' with this name
            this.findReplacement(modelelement, referredElem);
        }
        return false;
    }

    /**
     * Test whether the references in 'modelelement' are correct.
     * If not, find possible replacements.
     * @param modelelement
     */
    public execBeforeInsurancePartRef(modelelement: InsurancePartRef): boolean {
        let referredElem: FreNodeReference<FreNamedNode>;
        referredElem = modelelement.part;
        if (!!modelelement.part && modelelement.part.referred === null) {
            // cannot find a 'part' with this name
            this.findReplacement(modelelement, referredElem);
        }
        return false;
    }

    private findReplacement(modelelement: FreNode, referredElem: FreNodeReference<FreNamedNode>) {
        const scoper = FreLanguageEnvironment.getInstance().scoper;
        const possibles = scoper.getVisibleElements(modelelement).filter((elem) => elem.name === referredElem.name);
        if (possibles.length > 0) {
            // element probably refers to something with another type
            let replacement: FreNode = null;
            for (const elem of possibles) {
                const metatype = elem.freLanguageConcept();
                if (FreLanguage.getInstance().metaConformsToType(elem, "CalcFunction")) {
                    replacement = FunctionCallExpression.create({
                        funcDefinition: FreNodeReference.create<CalcFunction>(referredElem.name, metatype),
                    });
                } else if (FreLanguage.getInstance().metaConformsToType(elem, "Parameter")) {
                    replacement = ParameterRef.create({ parameter: FreNodeReference.create<Parameter>(referredElem.name, metatype) });
                } else if (FreLanguage.getInstance().metaConformsToType(elem, "InsurancePart")) {
                    replacement = InsurancePartRef.create({ part: FreNodeReference.create<InsurancePart>(referredElem.name, metatype) });
                } else {
                    throw new Error(
                        "Semantic analysis error: cannot replace reference: " + referredElem.name + " of type " + metatype + ".",
                    );
                }
            }
            this.changesToBeMade.set(modelelement, replacement);
        } else {
            // true error, or boolean "true" or "false"
        }
    }
}
