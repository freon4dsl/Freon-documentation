// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import { Part, BaseProduct, InsurancePart, InsuranceTheme, PercentageLiteral, EuroLiteral } from "../../language/gen/index.js";
import { InsuranceModelSyntaxAnalyser } from "./InsuranceModelSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class PartSyntaxAnalyserPart {
    mainAnalyser: InsuranceModelSyntaxAnalyser;

    constructor(mainAnalyser: InsuranceModelSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Part = BaseProduct ;
     * @param branch
     * @private
     */
    public transformPart(branch: SPPTBranch): Part {
        // console.log('transformPart called: ' + branch.name);
        let __part: BaseProduct;
        const children = this.mainAnalyser.getChildren(branch);
        __part = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry

        return Part.create({
            part: __part,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * BaseProduct = 'Base' 'Products' identifier 'for' InsuranceTheme
     *	 'is' 'still' 'under' 'construction:' booleanLiteral
     *	 'is' 'approved' 'level1:' ( 'Sure' | 'NoWay' )
     *	 'is' 'approved' 'level2:' booleanLiteral
     *	 'is' 'approved' 'level3:' booleanLiteral
     *	 'yields' 'profit:' ( 'Plenty' | 'Little' )
     *	 'expected' 'nr' 'of' 'use:' numberLiteral
     *	 'range:' numberLiteral
     *	 InsurancePart* ;
     * @param branch
     * @private
     */
    public transformBaseProduct(branch: SPPTBranch): BaseProduct {
        // console.log('transformBaseProduct called: ' + branch.name);
        let __name: string;
        let __theme: FreNodeReference<InsuranceTheme>;
        let __isUnderConstruction: boolean;
        let __isApprovedLevel1: boolean;
        let __isApprovedLevel2: boolean;
        let __isApprovedLevel3: boolean;
        let __yieldsProfit: boolean;
        let __nrOfUse: number;
        let __range: number;
        let __parts: InsurancePart[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPrimEntry
        __theme = this.mainAnalyser.freNodeRef<InsuranceTheme>(children[4], "InsuranceTheme"); // RHSLimitedRefEntry
        __isUnderConstruction = this.mainAnalyser.transformSharedPackedParseTreeNode(children[9]); // RHSPrimEntry
        // RHSBooleanWithDoubleKeyWord
        if (children[13].nonSkipMatchedText === "Sure") {
            __isApprovedLevel1 = true;
        } else if (children[13].nonSkipMatchedText === "NoWay") {
            __isApprovedLevel1 = false;
        }
        __isApprovedLevel2 = this.mainAnalyser.transformSharedPackedParseTreeNode(children[17]); // RHSPrimEntry
        __isApprovedLevel3 = this.mainAnalyser.transformSharedPackedParseTreeNode(children[21]); // RHSPrimEntry
        // RHSBooleanWithDoubleKeyWord
        if (children[24].nonSkipMatchedText === "Plenty") {
            __yieldsProfit = true;
        } else if (children[24].nonSkipMatchedText === "Little") {
            __yieldsProfit = false;
        }
        __nrOfUse = this.mainAnalyser.transformSharedPackedParseTreeNode(children[29]); // RHSPrimEntry
        __range = this.mainAnalyser.transformSharedPackedParseTreeNode(children[31]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[32].name !== "InsurancePart") {
            __parts = this.mainAnalyser.transformSharedPackedParseTreeList<InsurancePart>(children[32]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __parts = [];
            for (const child of children) {
                __parts.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return BaseProduct.create({
            name: __name,
            theme: __theme,
            isUnderConstruction: __isUnderConstruction,
            isApprovedLevel1: __isApprovedLevel1,
            isApprovedLevel2: __isApprovedLevel2,
            isApprovedLevel3: __isApprovedLevel3,
            yieldsProfit: __yieldsProfit,
            nrOfUse: __nrOfUse,
            range: __range,
            parts: __parts,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * InsurancePart = 'Insurance' 'Part' identifier
     *	 'risk' 'assessment:' PercentageLiteral
     *	 'maximum' 'payout:' EuroLiteral
     *	 'is' 'approved:' ( 'JA' | 'NEE' ) ;
     * @param branch
     * @private
     */
    public transformInsurancePart(branch: SPPTBranch): InsurancePart {
        // console.log('transformInsurancePart called: ' + branch.name);
        let __name: string;
        let __statisticalRisk: PercentageLiteral;
        let __maximumPayOut: EuroLiteral;
        let __isApproved: boolean;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPrimEntry
        __statisticalRisk = this.mainAnalyser.transformSharedPackedParseTreeNode(children[5]); // RHSPartEntry
        __maximumPayOut = this.mainAnalyser.transformSharedPackedParseTreeNode(children[8]); // RHSPartEntry
        // RHSBooleanWithDoubleKeyWord
        if (children[11].nonSkipMatchedText === "JA") {
            __isApproved = true;
        } else if (children[11].nonSkipMatchedText === "NEE") {
            __isApproved = false;
        }
        return InsurancePart.create({
            name: __name,
            statisticalRisk: __statisticalRisk,
            maximumPayOut: __maximumPayOut,
            isApproved: __isApproved,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }
}
