// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by InsuranceModelModelUnitReader

export const InsuranceModelGrammarStr = `
namespace InsuranceModelLanguage
grammar InsuranceModelGrammar {

// rules for "Part"
Part = BaseProduct ;

BaseProduct = 'Base' 'Products' identifier 'for' InsuranceTheme
	 'is' 'still' 'under' 'construction:' booleanLiteral
	 'is' 'approved' 'level1:' ( 'Sure' | 'NoWay' )
	 'is' 'approved' 'level2:' booleanLiteral
	 'is' 'approved' 'level3:' booleanLiteral
	 'yields' 'profit:' ( 'Plenty' | 'Little' )
	 'expected' 'nr' 'of' 'use:' numberLiteral
	 'range:' numberLiteral
	 InsurancePart* ;

InsurancePart = 'Insurance' 'Part' identifier
	 'risk' 'assessment:' PercentageLiteral
	 'maximum' 'payout:' EuroLiteral
	 'is' 'approved:' ( 'JA' | 'NEE' ) ;

// rules for "Product"
Product = InsuranceProduct ;

InsuranceProduct = 'Insurance' 'Product' identifier '(' 'public' 'name:' stringLiteral ')' 'USES' [ __fre_reference / ',' ]*
	 'Themes:' [ InsuranceTheme / ',' ]*
	 'Premium:' EuroLiteral 'per' PremiumDays
	 'Insured' 'risks:'
	 ( __fre_reference ';' )*
	 'Calculation'
	 ( 'Risk' 'adjusted' 'by' '=' PercentageLiteral )?
	 'calculated' 'premium:' DocuExpression
	 ( 'Helper' 'functions:' CalcFunction* )? ;

NumberLiteral = numberLiteral ;

BooleanLiteral = booleanLiteral ;

FunctionCallExpression = __fre_reference '(' [ DocuExpression / ',' ]* ')' ;

InsurancePartRef = __fre_reference ;

RiskAdjustmentRef = 'riskAdjustment' ;

ParameterRef = __fre_reference ( '.' AttributeRef )? ;

RiskRef = 'statisticalRisk' ;

PayoutRef = 'maximumPayOut' ;

GenericLiteral = GenericKind '\{' [ DocuExpression / ',' ]* '}' ;

CalcFunction = identifier '(' [ Parameter / ',' ]* '):' DocuType '\{'
	 DocuExpression
	 '}' ;

Description = stringLiteral ;

GenericTypeDecl = GenericKind '<' DocuType '>' ;

TypeRef = __fre_reference ;

Parameter = identifier ':' DocuType ;

DocuExpression = Literal 
    | FunctionCallExpression 
    | InsurancePartRef 
    | ParameterRef 
    | GenericLiteral 
    | RiskAdjustmentRef 
    | __fre_binary_DocuExpression ;

Literal = EuroLiteral 
    | NumberLiteral 
    | PercentageLiteral 
    | BooleanLiteral  ;

AttributeRef = RiskRef 
    | PayoutRef  ;

DocuType = GenericTypeDecl 
    | TypeRef  ;

__fre_binary_DocuExpression = [DocuExpression / __fre_binary_operator]2+ ;
leaf __fre_binary_operator = '+' | '-' | '*' | '/' ;

GenericKind = 'Set'
	| 'Sequence'
	| 'Bag'
	| 'Collection' ;

PremiumDays = 'Week'
	| 'Month'
	| 'Quarter'
	| 'Semester'
	| 'Year' ;

// common rules
PercentageLiteral = numberLiteral '%' ;

EuroLiteral = 'EUR' numberLiteral ',' numberLiteral ;

InsuranceTheme = 'HomeTheme'
	| 'HealthTheme'
	| 'LegalTheme' ;

__fre_reference = [ identifier / ':' ]+ ;

// white space and comments
skip WHITE_SPACE = "\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\r\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\*[^*]*\\*+(?:[^*/][^*]*\\*+)*/" ;

// the predefined basic types
leaf identifier          = "[a-zA-Z_][a-zA-Z0-9_]*" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '"' "[^\\"\\\\]*(\\\\.[^\\"\\\\]*)*" '"' ;
leaf numberLiteral       = "[0-9]+";
leaf booleanLiteral      = 'NO' | 'YES';

}`; // end of grammar
