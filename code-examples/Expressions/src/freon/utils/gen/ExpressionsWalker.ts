// Generated by the Freon Language Generator.
// import { FreNode } from "../../language/gen/index.js";
import {
    DivideExpression,
    MinusExpression,
    PlusExpression,
    MultiplyExpression,
    FunctionCallExpression,
    ParameterRef,
    BinaryExpression,
    NumberLiteralExpression,
    Parameter,
    Function,
    Expression,
    Type,
    ExpressionUnit,
    Expressions,
} from "../../language/gen/index.js";
import { ExpressionsWorker } from "./ExpressionsWorker.js";
import { FreLogger, FreNode } from "@freon4dsl/core";

const LOGGER = new FreLogger("ExpressionsWalker");

/**
 * Class ExpressionsWalker implements the extended visitor pattern of instances of language Expressions.
 * This class implements the traversal of the model tree, classes that implement ExpressionsWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class ExpressionsWalker {
    myWorkers: ExpressionsWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: FreNode, includeChildren?: (elem: FreNode) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof DivideExpression) {
                return this.walkDivideExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof MinusExpression) {
                return this.walkMinusExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof PlusExpression) {
                return this.walkPlusExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof MultiplyExpression) {
                return this.walkMultiplyExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof FunctionCallExpression) {
                return this.walkFunctionCallExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof ParameterRef) {
                return this.walkParameterRef(modelelement, includeChildren);
            }
            if (modelelement instanceof BinaryExpression) {
                return this.walkBinaryExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof NumberLiteralExpression) {
                return this.walkNumberLiteralExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof Parameter) {
                return this.walkParameter(modelelement, includeChildren);
            }
            if (modelelement instanceof Function) {
                return this.walkFunction(modelelement, includeChildren);
            }
            if (modelelement instanceof Expression) {
                return this.walkExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof Type) {
                return this.walkType(modelelement, includeChildren);
            }
            if (modelelement instanceof ExpressionUnit) {
                return this.walkExpressionUnit(modelelement, includeChildren);
            }
            if (modelelement instanceof Expressions) {
                return this.walkExpressions(modelelement, includeChildren);
            }
        } else {
            LOGGER.error("No worker found.");
        }
    }

    private walkDivideExpression(modelelement: DivideExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDivideExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDivideExpression(modelelement);
            }
        }
    }

    private walkMinusExpression(modelelement: MinusExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMinusExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMinusExpression(modelelement);
            }
        }
    }

    private walkPlusExpression(modelelement: PlusExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePlusExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPlusExpression(modelelement);
            }
        }
    }

    private walkMultiplyExpression(modelelement: MultiplyExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMultiplyExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMultiplyExpression(modelelement);
            }
        }
    }

    private walkFunctionCallExpression(modelelement: FunctionCallExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeFunctionCallExpression(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.arguments.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterFunctionCallExpression(modelelement);
            }
        }
    }

    private walkParameterRef(modelelement: ParameterRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeParameterRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterParameterRef(modelelement);
            }
        }
    }

    private walkBinaryExpression(modelelement: BinaryExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBinaryExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBinaryExpression(modelelement);
            }
        }
    }

    private walkNumberLiteralExpression(modelelement: NumberLiteralExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNumberLiteralExpression(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNumberLiteralExpression(modelelement);
            }
        }
    }

    private walkParameter(modelelement: Parameter, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeParameter(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterParameter(modelelement);
            }
        }
    }

    private walkFunction(modelelement: Function, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeFunction(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.body)) {
            this.walk(modelelement.body, includeChildren);
        }
        modelelement.parameters.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterFunction(modelelement);
            }
        }
    }

    private walkExpression(modelelement: Expression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeExpression(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterExpression(modelelement);
            }
        }
    }

    private walkType(modelelement: Type, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterType(modelelement);
            }
        }
    }

    private walkExpressionUnit(modelelement: ExpressionUnit, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeExpressionUnit(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.functions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.expressions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterExpressionUnit(modelelement);
            }
        }
    }

    private walkExpressions(modelelement: Expressions, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeExpressions(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.units.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterExpressions(modelelement);
            }
        }
    }
}
