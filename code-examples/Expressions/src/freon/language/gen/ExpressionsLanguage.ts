// Generated by the Freon Language Generator.
// Generated by Freon LanguageTemplate
import {
    FreLanguage,
    FreLanguageModel,
    FreLanguageModelUnit,
    FreLanguageProperty,
    FreLanguageConcept,
    FreLanguageInterface,
    FreNodeReference,
} from "@freon4dsl/core";

// Import as MyLanguage to avoid naming conflicts in generated constructors
import * as MyLanguage from "./internal.js";
import { ExpressionsStdlib } from "../../stdlib/gen/ExpressionsStdlib.js";

/**
 * Creates an in-memory representation of structure of the language metamodel, used in e.g. the (de)serializer.
 */
export function initializeLanguage() {
    FreLanguage.getInstance().name = "Expressions";
    FreLanguage.getInstance().id = "";
    FreLanguage.getInstance().addModel(describeExpressions());
    FreLanguage.getInstance().addUnit(describeExpressionUnit());
    FreLanguage.getInstance().addConcept(describeType());
    FreLanguage.getInstance().addConcept(describeExpression());
    FreLanguage.getInstance().addConcept(describeNumberLiteralExpression());
    FreLanguage.getInstance().addConcept(describeBinaryExpression());
    FreLanguage.getInstance().addConcept(describeMultiplyExpression());
    FreLanguage.getInstance().addConcept(describePlusExpression());
    FreLanguage.getInstance().addConcept(describeMinusExpression());
    FreLanguage.getInstance().addConcept(describeDivideExpression());
    FreLanguage.getInstance().addConcept(describeFunction());
    FreLanguage.getInstance().addConcept(describeParameter());
    FreLanguage.getInstance().addConcept(describeParameterRef());
    FreLanguage.getInstance().addConcept(describeFunctionCallExpression());

    FreLanguage.getInstance().addReferenceCreator((name: string, type: string) => {
        return !!name ? FreNodeReference.create(name, type) : null;
    });
    FreLanguage.getInstance().stdLib = ExpressionsStdlib.getInstance();
}

function describeExpressions(): FreLanguageModel {
    const model: FreLanguageModel = {
        typeName: "Expressions",
        id: "-id-Expressions",
        key: "-key-Expressions",
        isNamespace: true,
        language: "-key-Expressions",
        constructor: (id?: string) => {
            return new MyLanguage.Expressions(id);
        },
        creator: (data: Partial<MyLanguage.Expressions>) => {
            return MyLanguage.Expressions.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
    };
    model.properties.set("name", {
        name: "name",
        id: "-id-Expressions-name",
        key: "-key-Expressions-name",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "primitive",
    });
    model.properties.set("units", {
        name: "units",
        id: "-id-Expressions-units",
        key: "-key-Expressions-units",
        type: "ExpressionUnit",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });

    return model;
}

function describeExpressionUnit(): FreLanguageModelUnit {
    const modelunit: FreLanguageModelUnit = {
        typeName: "ExpressionUnit",
        id: "-id-ExpressionUnit",
        key: "-key-ExpressionUnit",
        isNamedElement: true,
        language: "-key-Expressions",
        fileExtension: "exp",
        subConceptNames: [], // Nothing yet, but may change in the future
        constructor: (id?: string) => {
            return new MyLanguage.ExpressionUnit(id);
        },
        creator: (data: Partial<MyLanguage.ExpressionUnit>) => {
            return MyLanguage.ExpressionUnit.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        trigger: "ExpressionUnit",
    };
    modelunit.properties.set("name", {
        name: "name",
        id: "-id-ExpressionUnit-name",
        key: "-key-ExpressionUnit-name",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "primitive",
    });
    modelunit.properties.set("functions", {
        name: "functions",
        id: "-id-ExpressionUnit-functions",
        key: "-key-ExpressionUnit-functions",
        type: "Function",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    modelunit.properties.set("expressions", {
        name: "expressions",
        id: "-id-ExpressionUnit-expressions",
        key: "-key-ExpressionUnit-expressions",
        type: "Expression",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });

    return modelunit;
}

function describeType(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Type",
        id: "-id-Type",
        key: "-key-Type",
        isAbstract: false,
        isPublic: true,
        isLimited: true,
        instanceNames: ["String", "Integer", "Boolean", "ANY"],
        language: "-key-Expressions",
        isNamedElement: true,
        trigger: "Type",
        constructor: (id?: string) => {
            return new MyLanguage.Type(id);
        },
        creator: (data: Partial<MyLanguage.Type>) => {
            return MyLanguage.Type.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-Type-name",
        key: "-key-Type-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Expressions",
        propertyKind: "primitive",
    });

    return concept;
}

function describeExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Expression",
        id: "-id-Expression",
        key: "-key-Expression",
        isAbstract: true,
        isPublic: false,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "Expression",
        constructor: (id?: string) => {
            return null;
        },
        creator: (data: Partial<MyLanguage.Expression>) => {
            return null;
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [
            "NumberLiteralExpression",
            "BinaryExpression",
            "MultiplyExpression",
            "PlusExpression",
            "MinusExpression",
            "DivideExpression",
            "ParameterRef",
            "FunctionCallExpression",
        ],
    };

    return concept;
}

function describeNumberLiteralExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "NumberLiteralExpression",
        id: "-id-NumberLiteralExpression",
        key: "-key-NumberLiteralExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "NumberLiteralExpression",
        constructor: (id?: string) => {
            return new MyLanguage.NumberLiteralExpression(id);
        },
        creator: (data: Partial<MyLanguage.NumberLiteralExpression>) => {
            return MyLanguage.NumberLiteralExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "Expression",
        subConceptNames: [],
    };
    concept.properties.set("value", {
        name: "value",
        id: "-id-NumberLiteralExpression-value",
        key: "-key-NumberLiteralExpression-value",
        type: "number",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Expressions",
        propertyKind: "primitive",
    });

    return concept;
}

function describeBinaryExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "BinaryExpression",
        id: "-id-BinaryExpression",
        key: "-key-BinaryExpression",
        isAbstract: true,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "BinaryExpression",
        constructor: (id?: string) => {
            return null;
        },
        creator: (data: Partial<MyLanguage.BinaryExpression>) => {
            return null;
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "Expression",
        subConceptNames: ["MultiplyExpression", "PlusExpression", "MinusExpression", "DivideExpression"],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });

    return concept;
}

function describeMultiplyExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "MultiplyExpression",
        id: "-id-MultiplyExpression",
        key: "-key-MultiplyExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "MultiplyExpression",
        constructor: (id?: string) => {
            return new MyLanguage.MultiplyExpression(id);
        },
        creator: (data: Partial<MyLanguage.MultiplyExpression>) => {
            return MyLanguage.MultiplyExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });

    return concept;
}

function describePlusExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "PlusExpression",
        id: "-id-PlusExpression",
        key: "-key-PlusExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "PlusExpression",
        constructor: (id?: string) => {
            return new MyLanguage.PlusExpression(id);
        },
        creator: (data: Partial<MyLanguage.PlusExpression>) => {
            return MyLanguage.PlusExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });

    return concept;
}

function describeMinusExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "MinusExpression",
        id: "-id-MinusExpression",
        key: "-key-MinusExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "MinusExpression",
        constructor: (id?: string) => {
            return new MyLanguage.MinusExpression(id);
        },
        creator: (data: Partial<MyLanguage.MinusExpression>) => {
            return MyLanguage.MinusExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });

    return concept;
}

function describeDivideExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "DivideExpression",
        id: "-id-DivideExpression",
        key: "-key-DivideExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "DivideExpression",
        constructor: (id?: string) => {
            return new MyLanguage.DivideExpression(id);
        },
        creator: (data: Partial<MyLanguage.DivideExpression>) => {
            return MyLanguage.DivideExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });

    return concept;
}

function describeFunction(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Function",
        id: "-id-Function",
        key: "-key-Function",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: true,
        trigger: "Function",
        constructor: (id?: string) => {
            return new MyLanguage.Function(id);
        },
        creator: (data: Partial<MyLanguage.Function>) => {
            return MyLanguage.Function.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-Function-name",
        key: "-key-Function-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Expressions",
        propertyKind: "primitive",
    });
    concept.properties.set("body", {
        name: "body",
        id: "-id-Function-body",
        key: "-key-Function-body",
        type: "Expression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("parameters", {
        name: "parameters",
        id: "-id-Function-parameters",
        key: "-key-Function-parameters",
        type: "Parameter",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("declaredType", {
        name: "declaredType",
        id: "-id-Function-declaredType",
        key: "-key-Function-declaredType",
        type: "Type",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "reference",
    });
    return concept;
}

function describeParameter(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Parameter",
        id: "-id-Parameter",
        key: "-key-Parameter",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: true,
        trigger: "Parameter",
        constructor: (id?: string) => {
            return new MyLanguage.Parameter(id);
        },
        creator: (data: Partial<MyLanguage.Parameter>) => {
            return MyLanguage.Parameter.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-Parameter-name",
        key: "-key-Parameter-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Expressions",
        propertyKind: "primitive",
    });

    concept.properties.set("declaredType", {
        name: "declaredType",
        id: "-id-Parameter-declaredType",
        key: "-key-Parameter-declaredType",
        type: "Type",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "reference",
    });
    return concept;
}

function describeParameterRef(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "ParameterRef",
        id: "-id-ParameterRef",
        key: "-key-ParameterRef",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "ParameterRef",
        constructor: (id?: string) => {
            return new MyLanguage.ParameterRef(id);
        },
        creator: (data: Partial<MyLanguage.ParameterRef>) => {
            return MyLanguage.ParameterRef.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "Expression",
        subConceptNames: [],
    };

    concept.properties.set("parameter", {
        name: "parameter",
        id: "-id-ParameterRef-parameter",
        key: "-key-ParameterRef-parameter",
        type: "Parameter",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "reference",
    });
    return concept;
}

function describeFunctionCallExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "FunctionCallExpression",
        id: "-id-FunctionCallExpression",
        key: "-key-FunctionCallExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Expressions",
        isNamedElement: false,
        trigger: "FunctionCallExpression",
        constructor: (id?: string) => {
            return new MyLanguage.FunctionCallExpression(id);
        },
        creator: (data: Partial<MyLanguage.FunctionCallExpression>) => {
            return MyLanguage.FunctionCallExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "Expression",
        subConceptNames: [],
    };

    concept.properties.set("arguments", {
        name: "arguments",
        id: "-id-FunctionCallExpression-arguments",
        key: "-key-FunctionCallExpression-arguments",
        type: "Expression",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "part",
    });
    concept.properties.set("calledFunction", {
        name: "calledFunction",
        id: "-id-FunctionCallExpression-calledFunction",
        key: "-key-FunctionCallExpression-calledFunction",
        type: "Function",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Expressions",
        propertyKind: "reference",
    });
    return concept;
}
