// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    ExpressionUnit,
    Function,
    NumberLiteralExpression,
    ParameterRef,
    FunctionCallExpression,
    Parameter,
    Expression,
    Type,
    MultiplyExpression,
    PlusExpression,
    MinusExpression,
    DivideExpression,
} from "../../language/gen/index.js";
import { ExpressionsSyntaxAnalyser } from "./ExpressionsSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class ExpressionUnitSyntaxAnalyserPart {
    mainAnalyser: ExpressionsSyntaxAnalyser;

    constructor(mainAnalyser: ExpressionsSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * ExpressionUnit = 'Functions:'
     *	 Function*
     *	 'Expressions'
     *	 Expression* ;
     * @param branch
     * @private
     */
    public transformExpressionUnit(branch: SPPTBranch): ExpressionUnit {
        // console.log('transformExpressionUnit called: ' + branch.name);
        let __functions: Function[];
        let __expressions: Expression[];
        const children = this.mainAnalyser.getChildren(branch); // RHSPartListEntry
        if (children[1].name !== "Function") {
            __functions = this.mainAnalyser.transformSharedPackedParseTreeList<Function>(children[1]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __functions = [];
            for (const child of children) {
                __functions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[3].name !== "Expression") {
            __expressions = this.mainAnalyser.transformSharedPackedParseTreeList<Expression>(children[3]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __expressions = [];
            for (const child of children) {
                __expressions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return ExpressionUnit.create({
            functions: __functions,
            expressions: __expressions,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Function = 'function' identifier '(' Parameter* '):' Type
     *	 '\{'
     *	 Expression
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFunction(branch: SPPTBranch): Function {
        // console.log('transformFunction called: ' + branch.name);
        let __name: string;
        let __parameters: Parameter[];
        let __declaredType: FreNodeReference<Type>;
        let __body: Expression;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[3].name !== "Parameter") {
            __parameters = this.mainAnalyser.transformSharedPackedParseTreeList<Parameter>(children[3]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __parameters = [];
            for (const child of children) {
                __parameters.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        __declaredType = this.mainAnalyser.freNodeRef<Type>(children[5], "Type"); // RHSLimitedRefEntry
        __body = this.mainAnalyser.transformSharedPackedParseTreeNode(children[7]); // RHSPartEntry

        return Function.create({
            name: __name,
            parameters: __parameters,
            declaredType: __declaredType,
            body: __body,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * NumberLiteralExpression = numberLiteral ;
     * @param branch
     * @private
     */
    public transformNumberLiteralExpression(branch: SPPTBranch): NumberLiteralExpression {
        // console.log('transformNumberLiteralExpression called: ' + branch.name);
        let __value: number;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry

        return NumberLiteralExpression.create({
            value: __value,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ParameterRef = __fre_reference ;
     * @param branch
     * @private
     */
    public transformParameterRef(branch: SPPTBranch): ParameterRef {
        // console.log('transformParameterRef called: ' + branch.name);
        let __parameter: FreNodeReference<Parameter>;
        const children = this.mainAnalyser.getChildren(branch);
        __parameter = this.mainAnalyser.freNodeRef<Parameter>(children[0], "Parameter"); // RHSRefEntry

        return ParameterRef.create({
            parameter: __parameter,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FunctionCallExpression = __fre_reference '(' Expression* ')' ;
     * @param branch
     * @private
     */
    public transformFunctionCallExpression(branch: SPPTBranch): FunctionCallExpression {
        // console.log('transformFunctionCallExpression called: ' + branch.name);
        let __calledFunction: FreNodeReference<Function>;
        let __arguments: Expression[];
        const children = this.mainAnalyser.getChildren(branch);
        __calledFunction = this.mainAnalyser.freNodeRef<Function>(children[0], "Function"); // RHSRefEntry
        // RHSPartListEntry
        if (children[2].name !== "Expression") {
            __arguments = this.mainAnalyser.transformSharedPackedParseTreeList<Expression>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __arguments = [];
            for (const child of children) {
                __arguments.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return FunctionCallExpression.create({
            calledFunction: __calledFunction,
            arguments: __arguments,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Parameter = 'var' identifier ':' Type ;
     * @param branch
     * @private
     */
    public transformParameter(branch: SPPTBranch): Parameter {
        // console.log('transformParameter called: ' + branch.name);
        let __name: string;
        let __declaredType: FreNodeReference<Type>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __declaredType = this.mainAnalyser.freNodeRef<Type>(children[3], "Type"); // RHSLimitedRefEntry

        return Parameter.create({
            name: __name,
            declaredType: __declaredType,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Expression = ParameterRef
     *    | FunctionCallExpression
     *    | NumberLiteralExpression
     *    | __fre_binary_Expression ;
     * @param branch
     * @private
     */
    public transformExpression(branch: SPPTBranch): Expression {
        // console.log('transformExpression called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Generic method to transform binary expressions, which are parsed
     * according to these rules:
     * __fre_binary_Expression = [Expression / __fre_binary_operator]2+ ;
     * leaf __fre_binary_operator = '*' | '+' | '-' | '/' ;
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     * @param branch
     * @private
     */
    public transform__fre_binary_Expression(branch: SPPTBranch): Expression {
        // console.log('transform__fre_binary_Expression called: ' + branch.name);
        const children = branch.nonSkipChildren.toArray();
        let index = 0;
        let first = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
        while (index < children.length) {
            let operator = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let second = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let combined: Expression = null;
            switch (operator) {
                case "*": {
                    combined = MultiplyExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "+": {
                    combined = PlusExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "-": {
                    combined = MinusExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "/": {
                    combined = DivideExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                default: {
                    combined = null;
                }
            }
            first = combined;
        }
        return first;
    }

    /**
     * Method to transform branches that match the following rule:
     * Type = 'String'
     *	| 'Integer'
     *	| 'Boolean'
     *	| 'ANY' ;
     * @param branch
     * @private
     */
    public transformType(branch: SPPTBranch): Type {
        const choice = branch.nonSkipMatchedText;
        if (choice === "String") {
            return Type.String;
        } else if (choice === "Integer") {
            return Type.Integer;
        } else if (choice === "Boolean") {
            return Type.Boolean;
        } else if (choice === "ANY") {
            return Type.ANY;
        } else {
            return null;
        }
    }
}
