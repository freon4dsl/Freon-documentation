// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreCompositeTyper, FreWriter, FreNamedNode, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    Type,
    Expression,
    NumberLiteralExpression,
    BinaryExpression,
    MultiplyExpression,
    PlusExpression,
    MinusExpression,
    DivideExpression,
    Function,
    Parameter,
    ParameterRef,
    FunctionCallExpression,
    ExpressionUnit,
} from "../../language/gen/index.js";
import { ExpressionsDefaultWorker } from "../../utils/gen/index.js";
import { ExpressionsCheckerInterface } from "./ExpressionsValidator.js";
import { reservedWordsInTypescript } from "./ReservedWords.js";

/**
 * Class ExpressionsValidationRulesChecker is the part of validator that is generated from, if present,
 * the validator definition. As the other checkers, it uses the visitor pattern.
 * Class ExpressionsDefaultWorker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class ExpressionsValidationRulesChecker extends ExpressionsDefaultWorker implements ExpressionsCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'typer' is used to implement the 'typecheck' rules in the validator definition
    typer: FreCompositeTyper = FreLanguageEnvironment.getInstance().typer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeFunction(modelelement: Function): boolean {
        let hasFatalError: boolean = false;
        // @typecheck conformsTo( body, declaredType )
        if (!this.typer.conformsType(modelelement.body, modelelement.$declaredType)) {
            this.errorList.push(
                new FreError(
                    "Type " +
                        this.typer.inferType(modelelement.body)?.toFreString(this.myWriter) +
                        " of [" +
                        this.myWriter.writeNameOnly(modelelement.body) +
                        "] does not conform to " +
                        this.myWriter.writeNameOnly(modelelement.$declaredType),
                    modelelement.body,
                    modelelement.name,
                    FreErrorSeverity.NONE,
                ),
            );
        } // isunique name in parameters
        let uniqueNameInParameters: string[] = [];
        modelelement.parameters.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'parameters' has no value`,
                        modelelement.parameters[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.NONE,
                    ),
                );
            } else {
                if (!uniqueNameInParameters.includes(elem.name)) {
                    uniqueNameInParameters.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'parameters'`,
                            modelelement.parameters[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.NONE,
                        ),
                    );
                }
            }
        }); // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeMultiplyExpression(modelelement: MultiplyExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, Type:Integer )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(Type.Integer);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(Type.Integer) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        } // @typecheck equalsType( right, Type:Integer )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(Type.Integer);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(Type.Integer) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        } // @typecheck conformsTo( left, right )
        if (!this.typer.conformsType(modelelement.left, modelelement.right)) {
            this.errorList.push(
                new FreError(
                    "Type " +
                        this.typer.inferType(modelelement.left)?.toFreString(this.myWriter) +
                        " of [" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "] does not conform to " +
                        this.myWriter.writeNameOnly(modelelement.right),
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforePlusExpression(modelelement: PlusExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, Type:Integer )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(Type.Integer);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(Type.Integer) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        } // @typecheck equalsType( right, Type:Integer )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(Type.Integer);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(Type.Integer) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        } // @typecheck conformsTo( left, right )
        if (!this.typer.conformsType(modelelement.left, modelelement.right)) {
            this.errorList.push(
                new FreError(
                    "Type " +
                        this.typer.inferType(modelelement.left)?.toFreString(this.myWriter) +
                        " of [" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "] does not conform to " +
                        this.myWriter.writeNameOnly(modelelement.right),
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeDivideExpression(modelelement: DivideExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, Type:Integer )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(Type.Integer);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(Type.Integer) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        } // @typecheck equalsType( right, Type:Integer )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(Type.Integer);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(Type.Integer) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Returns true if 'name' is a valid identifier
     * @param name
     */
    private isValidName(name: string): boolean {
        if (!!!name) return false;
        // cannot start with number
        if (/[0-9]/.test(name[0])) return false;
        // may contain letters, numbers, '$', and '_', but no other characters
        if (/[.|,|!|?|@|~|%|^|&|*|-|=|+|(|)|{|}|"|'|:|;|<|>|?]/.test(name)) return false;
        if (/\\/.test(name)) return false;
        if (/[/|[|]]/.test(name)) return false;
        // may not contain whitespaces
        if (/[\t|\n|\r| ]/.test(name)) return false;
        // may not be a Typescript keyword
        return !reservedWordsInTypescript.includes(name);
    }
}
