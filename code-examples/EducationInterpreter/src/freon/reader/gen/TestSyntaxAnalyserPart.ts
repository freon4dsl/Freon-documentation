// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    Test,
    Scenario,
    TestFlow,
    Step,
    LastStep,
    Answer,
    SiteGroup,
    Flow,
    Page,
    NumberConcept,
    Question,
} from "../../language/gen/index.js";
import { EducationSyntaxAnalyser } from "./EducationSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class TestSyntaxAnalyserPart {
    mainAnalyser: EducationSyntaxAnalyser;

    constructor(mainAnalyser: EducationSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Test = 'Test' identifier
     *	 'Regarding' 'MainTopic:' __fre_reference ',' 'and' 'flow:' __fre_reference
     *	 Scenario* ;
     * @param branch
     * @private
     */
    public transformTest(branch: SPPTBranch): Test {
        // console.log('transformTest called: ' + branch.name);
        let __name: string;
        let __main: FreNodeReference<SiteGroup>;
        let __flow: FreNodeReference<Flow>;
        let __scenarios: Scenario[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __main = this.mainAnalyser.freNodeRef<SiteGroup>(children[4], "SiteGroup"); // RHSRefEntry
        __flow = this.mainAnalyser.freNodeRef<Flow>(children[8], "Flow"); // RHSRefEntry
        // RHSPartListEntry
        if (children[9].name !== "Scenario") {
            __scenarios = this.mainAnalyser.transformSharedPackedParseTreeList<Scenario>(children[9]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __scenarios = [];
            for (const child of children) {
                __scenarios.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return Test.create({
            name: __name,
            main: __main,
            flow: __flow,
            scenarios: __scenarios,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Scenario = '------------------------------------'
     *	 stringLiteral
     *	 TestFlow* ;
     * @param branch
     * @private
     */
    public transformScenario(branch: SPPTBranch): Scenario {
        // console.log('transformScenario called: ' + branch.name);
        let __description: string;
        let __testFlow: TestFlow[];
        const children = this.mainAnalyser.getChildren(branch);
        __description = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[2].name !== "TestFlow") {
            __testFlow = this.mainAnalyser.transformSharedPackedParseTreeList<TestFlow>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __testFlow = [];
            for (const child of children) {
                __testFlow.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return Scenario.create({
            description: __description,
            testFlow: __testFlow,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * TestFlow = [ __fre_super_Step / '===>' ]* ;
     * @param branch
     * @private
     */
    public transformTestFlow(branch: SPPTBranch): TestFlow {
        // console.log('transformTestFlow called: ' + branch.name);
        let __steps: Step[];
        const children = this.mainAnalyser.getChildren(branch);
        __steps = this.mainAnalyser.transformSharedPackedParseTreeList<Step>(children[0], "===>"); // RHSPartListWithSeparator

        return TestFlow.create({
            steps: __steps,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Step = __fre_reference '=>' Answer* ;
     * @param branch
     * @private
     */
    public transformStep(branch: SPPTBranch): Step {
        // console.log('transformStep called: ' + branch.name);
        let __fromPage: FreNodeReference<Page>;
        let __answerSeries: Answer[];
        const children = this.mainAnalyser.getChildren(branch);
        __fromPage = this.mainAnalyser.freNodeRef<Page>(children[0], "Page"); // RHSRefEntry
        // RHSPartListEntry
        if (children[2].name !== "Answer") {
            __answerSeries = this.mainAnalyser.transformSharedPackedParseTreeList<Answer>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __answerSeries = [];
            for (const child of children) {
                __answerSeries.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return Step.create({
            fromPage: __fromPage,
            answerSeries: __answerSeries,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * LastStep = __fre_reference ;
     * @param branch
     * @private
     */
    public transformLastStep(branch: SPPTBranch): LastStep {
        // console.log('transformLastStep called: ' + branch.name);
        let __fromPage: FreNodeReference<Page>;
        const children = this.mainAnalyser.getChildren(branch);
        __fromPage = this.mainAnalyser.freNodeRef<Page>(children[0], "Page"); // RHSRefEntry

        return LastStep.create({
            fromPage: __fromPage,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Answer = 'Answer' '\{'
     *	 'value' NumberConcept
     *	 'question' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformAnswer(branch: SPPTBranch): Answer {
        // console.log('transformAnswer called: ' + branch.name);
        let __value: NumberConcept;
        let __question: FreNodeReference<Question>;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPartEntry
        __question = this.mainAnalyser.freNodeRef<Question>(children[5], "Question"); // RHSRefEntry

        return Answer.create({
            value: __value,
            question: __question,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * __fre_super_Step = Step
     *    | LastStep  ;
     * @param branch
     * @private
     */
    public transform__fre_super_Step(branch: SPPTBranch): Step {
        // console.log('transform__fre_super_Step called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }
}
