// Generated by the Freon Language Generator.
import { FreTyper, FreCompositeTyper, FreType, AstType, FreNode, FreLanguage, FreCommonSuperTypeUtil } from "@freon4dsl/core";
import { Type, PrimitiveType } from "../../language/gen/index.js";

/**
 * Class EducationTyperPart implements the typer generated from, if present, the typer definition,
 * otherwise this class implements the default typer.
 */
export class EducationTyperPart implements FreTyper {
    mainTyper: FreCompositeTyper; //  EducationTyper;

    /**
     * Returns true if 'modelelement' is marked as 'type' in the Typer definition.
     * @param modelelement
     */
    public isType(modelelement: FreNode): boolean | null {
        if (modelelement instanceof PrimitiveType) {
            return true;
        }
        return false;
    }

    /**
     * Returns the type of 'modelelement' according to the type rules in the Typer Definition.
     * @param modelelement
     */
    public inferType(modelelement: FreNode): FreType | null {
        if (!modelelement) {
            return null;
        }
        let result: FreType = null;
        if (FreLanguage.getInstance().metaConformsToType(modelelement, "ComparisonExpression")) {
            result = AstType.create({ astElement: PrimitiveType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "OrExpression")) {
            result = AstType.create({ astElement: PrimitiveType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "AndExpression")) {
            result = AstType.create({ astElement: PrimitiveType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "NumberLiteralExpression")) {
            result = AstType.create({ astElement: PrimitiveType.Integer }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "NrOfCorrectAnswers")) {
            result = AstType.create({ astElement: PrimitiveType.Integer }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "QuestionReference")) {
            result = AstType.create({ astElement: PrimitiveType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "Grade")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "PrimitiveType")) {
            result = AstType.create({ astElement: modelelement });
        } else if (this.mainTyper.isType(modelelement)) {
            result = AstType.create({ astElement: modelelement });
        }
        return result;
    }

    /**
     * Returns true if type1 equals type2.
     * This is a strict equal.
     * @param type1
     * @param type2
     */
    public equals(type1: FreType, type2: FreType): boolean | null {
        if (!type1 || !type2) return false;
        if (type1.$typename === "AstType") {
            return (type1 as AstType).astElement === (type2 as AstType).astElement;
        }
        return false;
    }

    /**
     * Returns true if type1 conforms to type2. The direction is type1 conforms to type2.
     * @param type1
     * @param type2
     */
    public conforms(type1: FreType, type2: FreType): boolean | null {
        if (!type1 || !type2) return null;
        let result: boolean = false;
        if (this.equals(type1, type2)) {
            result = true;
        } else {
            this.getSuperTypes(type1).forEach((super1) => {
                if (this.equals(super1, type2)) {
                    result = true;
                }
            });
        }
        return result;
    }

    /**
     * Returns true if all types in typelist1 conform to the types in typelist2, pairswise, in the given order.
     * @param typelist1
     * @param typelist2
     */
    public conformsList(typelist1: FreType[], typelist2: FreType[]): boolean | null {
        if (typelist1.length !== typelist2.length) return false;
        let result: boolean = true;
        for (let index in typelist1) {
            result = this.conforms(typelist1[index], typelist2[index]);
            if (result == false) return result;
        }
        return result;
    }

    /**
     * Returns the common super type of all types in typelist
     * @param typelist
     */
    public commonSuper(typelist: FreType[]): FreType | null {
        const result: FreType[] = FreCommonSuperTypeUtil.commonSuperType(typelist, this.mainTyper);
        if (!!result && result.length > 0) {
            return result[0];
        }
        return null;
    }

    /**
     * Returns all super types as defined in the typer definition.
     * @param type
     */
    public getSuperTypes(type: FreType): FreType[] {
        if (!type) {
            return [];
        }
        let result: FreType[] = [];
        if (type.$typename === "AstType") {
            const elem: FreNode = (type as AstType).astElement;

            return [];
        }
        return result;
    }

    private typeOf(myArg: FreNode | FreNode[]): FreType {
        let result: FreType;
        if (Array.isArray(myArg)) {
            result = this.mainTyper.commonSuperType(myArg);
        } else {
            result = this.mainTyper.inferType(myArg);
        }
        return result;
    }

    private getElemFromAstType(type: FreType, metatype: string): FreNode {
        if (type.$typename === "AstType") {
            const astElement: FreNode = (type as AstType).astElement;
            if (FreLanguage.getInstance().metaConformsToType(astElement, metatype)) {
                return astElement;
            }
        }
        return null;
    }
}
