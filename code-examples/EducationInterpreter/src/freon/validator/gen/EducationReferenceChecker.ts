// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreWriter, FreNodeReference, FreNamedNode, FreNode, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    Flow,
    SiteGroup,
    Test,
    Topic,
    FlowRule,
    PageTransition,
    GradeScore,
    QuestionReference,
    Step,
    LastStep,
    Answer,
} from "../../language/gen/index.js";
import { EducationDefaultWorker } from "../../utils/gen/index.js";
import { EducationCheckerInterface } from "./EducationValidator.js";

/**
 * Class EducationReferenceChecker is part of the implementation of the default validator.
 * It checks whether references can be found within the model.
 *
 * Class EducationWalker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class EducationReferenceChecker extends EducationDefaultWorker implements EducationCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];
    private refSeparator: string = "/";

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeFlow(modelelement: Flow): boolean {
        if (!!modelelement.main && modelelement.main.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.main, "main", `${modelelement.name}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeSiteGroup(modelelement: SiteGroup): boolean {
        for (const referredElem of modelelement.topics) {
            if (referredElem.referred === null) {
                this.makeErrorMessage(modelelement, referredElem, "topics", `${modelelement.name}`);
            }
        }
        for (const referredElem of modelelement.flows) {
            if (referredElem.referred === null) {
                this.makeErrorMessage(modelelement, referredElem, "flows", `${modelelement.name}`);
            }
        }
        for (const referredElem of modelelement.tests) {
            if (referredElem.referred === null) {
                this.makeErrorMessage(modelelement, referredElem, "tests", `${modelelement.name}`);
            }
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeTest(modelelement: Test): boolean {
        if (!!modelelement.main && modelelement.main.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.main, "main", `${modelelement.name}`);
        }
        if (!!modelelement.flow && modelelement.flow.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.flow, "flow", `${modelelement.name}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeTopic(modelelement: Topic): boolean {
        if (!!modelelement.main && modelelement.main.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.main, "main", `${modelelement.name}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeFlowRule(modelelement: FlowRule): boolean {
        if (!!modelelement.page && modelelement.page.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.page, "page", `${modelelement.name}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePageTransition(modelelement: PageTransition): boolean {
        if (!!modelelement.condition && modelelement.condition.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.condition, "condition", `${"unnamed"}`);
        }
        if (!!modelelement.toPage && modelelement.toPage.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.toPage, "toPage", `${"unnamed"}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGradeScore(modelelement: GradeScore): boolean {
        if (!!modelelement.grade && modelelement.grade.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.grade, "grade", `${"unnamed"}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeQuestionReference(modelelement: QuestionReference): boolean {
        if (!!modelelement.question && modelelement.question.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.question, "question", `${"unnamed"}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeStep(modelelement: Step): boolean {
        if (!!modelelement.fromPage && modelelement.fromPage.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.fromPage, "fromPage", `${"unnamed"}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeLastStep(modelelement: LastStep): boolean {
        if (!!modelelement.fromPage && modelelement.fromPage.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.fromPage, "fromPage", `${"unnamed"}`);
        }
        return false;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeAnswer(modelelement: Answer): boolean {
        if (!!modelelement.question && modelelement.question.referred === null) {
            this.makeErrorMessage(modelelement, modelelement.question, "question", `${"unnamed"}`);
        }
        return false;
    }

    private makeErrorMessage(
        modelelement: FreNode,
        referredElem: FreNodeReference<FreNamedNode>,
        propertyName: string,
        locationDescription: string,
    ) {
        const scoper = FreLanguageEnvironment.getInstance().scoper;
        const possibles = scoper.getVisibleElements(modelelement).filter((elem) => elem.name === referredElem.name);
        if (possibles.length > 0) {
            this.errorList.push(
                new FreError(
                    `Reference '${referredElem.pathnameToString(this.refSeparator)}' should have type '${referredElem.typeName}', but found type(s) [${possibles.map((elem) => `${elem.freLanguageConcept()}`).join(", ")}]`,
                    modelelement,
                    `${propertyName} of ${locationDescription}`,
                    `${propertyName}`,
                    FreErrorSeverity.Error,
                ),
            );
        } else {
            this.errorList.push(
                new FreError(
                    `Cannot find reference '${referredElem.pathnameToString(this.refSeparator)}'`,
                    modelelement,
                    `${propertyName} of ${locationDescription}`,
                    `${propertyName}`,
                    FreErrorSeverity.Error,
                ),
            );
        }
    }
}
