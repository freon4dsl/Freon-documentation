// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreCompositeTyper, FreWriter, FreNamedNode, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    FlowRule,
    PageTransition,
    Grade,
    PrimitiveType,
    GradeScore,
    ScoreExpression,
    QuestionReference,
    NrOfCorrectAnswers,
    NumberLiteralExpression,
    BinaryExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessOrEqualsExpression,
    GreaterOrEqualsExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
    Scenario,
    TestFlow,
    Step,
    LastStep,
    Answer,
    Page,
    Theory,
    Line,
    Video,
    WorkSheet,
    ExamplePage,
    InDepthMaterial,
    Question,
    NumberConcept,
    SimpleNumber,
    Fraction,
    Type,
    Flow,
    SiteGroup,
    Test,
    Topic,
} from "../../language/gen/index.js";
import { EducationDefaultWorker } from "../../utils/gen/index.js";
import { EducationCheckerInterface } from "./EducationValidator.js";
import { reservedWordsInTypescript } from "./ReservedWords.js";

/**
 * Class EducationValidationRulesChecker is the part of validator that is generated from, if present,
 * the validator definition. As the other checkers, it uses the visitor pattern.
 * Class EducationDefaultWorker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class EducationValidationRulesChecker extends EducationDefaultWorker implements EducationCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'typer' is used to implement the 'typecheck' rules in the validator definition
    typer: FreCompositeTyper = FreLanguageEnvironment.getInstance().typer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeAndExpression(modelelement: AndExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, PrimitiveType:Boolean )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(PrimitiveType.Boolean);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(PrimitiveType.Boolean) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        } // @typecheck equalsType( right, PrimitiveType:Boolean )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(PrimitiveType.Boolean);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(PrimitiveType.Boolean) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeOrExpression(modelelement: OrExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, PrimitiveType:Boolean )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(PrimitiveType.Boolean);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(PrimitiveType.Boolean) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        } // @typecheck equalsType( right, PrimitiveType:Boolean )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(PrimitiveType.Boolean);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(PrimitiveType.Boolean) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeLessOrEqualsExpression(modelelement: LessOrEqualsExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, right )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(modelelement.right);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeGreaterOrEqualsExpression(modelelement: GreaterOrEqualsExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, right )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(modelelement.right);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeLessThenExpression(modelelement: LessThenExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, right )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(modelelement.right);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeGreaterThenExpression(modelelement: GreaterThenExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, right )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(modelelement.right);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeEqualsExpression(modelelement: EqualsExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( left, right )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(modelelement.right);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.NONE,
                ),
            );
        }
        return hasFatalError;
    }

    /**
     * Returns true if 'name' is a valid identifier
     * @param name
     */
    private isValidName(name: string): boolean {
        if (!!!name) return false;
        // cannot start with number
        if (/[0-9]/.test(name[0])) return false;
        // may contain letters, numbers, '$', and '_', but no other characters
        if (/[.|,|!|?|@|~|%|^|&|*|-|=|+|(|)|{|}|"|'|:|;|<|>|?]/.test(name)) return false;
        if (/\\/.test(name)) return false;
        if (/[/|[|]]/.test(name)) return false;
        // may not contain whitespaces
        if (/[\t|\n|\r| ]/.test(name)) return false;
        // may not be a Typescript keyword
        return !reservedWordsInTypescript.includes(name);
    }
}
