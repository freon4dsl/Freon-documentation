// Generated by the Freon Language Generator.
// import { FreNode } from "../../language/gen/index.js";
import {
    EqualsExpression,
    GreaterThenExpression,
    LessThenExpression,
    GreaterOrEqualsExpression,
    LessOrEqualsExpression,
    ComparisonExpression,
    OrExpression,
    AndExpression,
    Fraction,
    SimpleNumber,
    InDepthMaterial,
    ExamplePage,
    WorkSheet,
    Video,
    Theory,
    LastStep,
    BinaryExpression,
    NumberLiteralExpression,
    NrOfCorrectAnswers,
    QuestionReference,
    NumberConcept,
    Question,
    Line,
    Page,
    Answer,
    Step,
    TestFlow,
    Scenario,
    ScoreExpression,
    GradeScore,
    PrimitiveType,
    Grade,
    PageTransition,
    FlowRule,
    Flow,
    SiteGroup,
    Test,
    Topic,
    Education,
} from "../../language/gen/index.js";
import { EducationWorker } from "./EducationWorker.js";
import { FreLogger, FreNode } from "@freon4dsl/core";

const LOGGER = new FreLogger("EducationWalker");

/**
 * Class EducationWalker implements the extended visitor pattern of instances of language Education.
 * This class implements the traversal of the model tree, classes that implement EducationWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class EducationWalker {
    myWorkers: EducationWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: FreNode, includeChildren?: (elem: FreNode) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof EqualsExpression) {
                return this.walkEqualsExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof GreaterThenExpression) {
                return this.walkGreaterThenExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof LessThenExpression) {
                return this.walkLessThenExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof GreaterOrEqualsExpression) {
                return this.walkGreaterOrEqualsExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof LessOrEqualsExpression) {
                return this.walkLessOrEqualsExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof ComparisonExpression) {
                return this.walkComparisonExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof OrExpression) {
                return this.walkOrExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof AndExpression) {
                return this.walkAndExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof Fraction) {
                return this.walkFraction(modelelement, includeChildren);
            }
            if (modelelement instanceof SimpleNumber) {
                return this.walkSimpleNumber(modelelement, includeChildren);
            }
            if (modelelement instanceof InDepthMaterial) {
                return this.walkInDepthMaterial(modelelement, includeChildren);
            }
            if (modelelement instanceof ExamplePage) {
                return this.walkExamplePage(modelelement, includeChildren);
            }
            if (modelelement instanceof WorkSheet) {
                return this.walkWorkSheet(modelelement, includeChildren);
            }
            if (modelelement instanceof Video) {
                return this.walkVideo(modelelement, includeChildren);
            }
            if (modelelement instanceof Theory) {
                return this.walkTheory(modelelement, includeChildren);
            }
            if (modelelement instanceof LastStep) {
                return this.walkLastStep(modelelement, includeChildren);
            }
            if (modelelement instanceof BinaryExpression) {
                return this.walkBinaryExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof NumberLiteralExpression) {
                return this.walkNumberLiteralExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof NrOfCorrectAnswers) {
                return this.walkNrOfCorrectAnswers(modelelement, includeChildren);
            }
            if (modelelement instanceof QuestionReference) {
                return this.walkQuestionReference(modelelement, includeChildren);
            }
            if (modelelement instanceof NumberConcept) {
                return this.walkNumberConcept(modelelement, includeChildren);
            }
            if (modelelement instanceof Question) {
                return this.walkQuestion(modelelement, includeChildren);
            }
            if (modelelement instanceof Line) {
                return this.walkLine(modelelement, includeChildren);
            }
            if (modelelement instanceof Page) {
                return this.walkPage(modelelement, includeChildren);
            }
            if (modelelement instanceof Answer) {
                return this.walkAnswer(modelelement, includeChildren);
            }
            if (modelelement instanceof Step) {
                return this.walkStep(modelelement, includeChildren);
            }
            if (modelelement instanceof TestFlow) {
                return this.walkTestFlow(modelelement, includeChildren);
            }
            if (modelelement instanceof Scenario) {
                return this.walkScenario(modelelement, includeChildren);
            }
            if (modelelement instanceof ScoreExpression) {
                return this.walkScoreExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof GradeScore) {
                return this.walkGradeScore(modelelement, includeChildren);
            }
            if (modelelement instanceof PrimitiveType) {
                return this.walkPrimitiveType(modelelement, includeChildren);
            }
            if (modelelement instanceof Grade) {
                return this.walkGrade(modelelement, includeChildren);
            }
            if (modelelement instanceof PageTransition) {
                return this.walkPageTransition(modelelement, includeChildren);
            }
            if (modelelement instanceof FlowRule) {
                return this.walkFlowRule(modelelement, includeChildren);
            }
            if (modelelement instanceof Flow) {
                return this.walkFlow(modelelement, includeChildren);
            }
            if (modelelement instanceof SiteGroup) {
                return this.walkSiteGroup(modelelement, includeChildren);
            }
            if (modelelement instanceof Test) {
                return this.walkTest(modelelement, includeChildren);
            }
            if (modelelement instanceof Topic) {
                return this.walkTopic(modelelement, includeChildren);
            }
            if (modelelement instanceof Education) {
                return this.walkEducation(modelelement, includeChildren);
            }
        } else {
            LOGGER.error("No worker found.");
        }
    }

    private walkEqualsExpression(modelelement: EqualsExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEqualsExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEqualsExpression(modelelement);
            }
        }
    }

    private walkGreaterThenExpression(modelelement: GreaterThenExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGreaterThenExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGreaterThenExpression(modelelement);
            }
        }
    }

    private walkLessThenExpression(modelelement: LessThenExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeLessThenExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterLessThenExpression(modelelement);
            }
        }
    }

    private walkGreaterOrEqualsExpression(modelelement: GreaterOrEqualsExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGreaterOrEqualsExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGreaterOrEqualsExpression(modelelement);
            }
        }
    }

    private walkLessOrEqualsExpression(modelelement: LessOrEqualsExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeLessOrEqualsExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterLessOrEqualsExpression(modelelement);
            }
        }
    }

    private walkComparisonExpression(modelelement: ComparisonExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeComparisonExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterComparisonExpression(modelelement);
            }
        }
    }

    private walkOrExpression(modelelement: OrExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeOrExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterOrExpression(modelelement);
            }
        }
    }

    private walkAndExpression(modelelement: AndExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAndExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAndExpression(modelelement);
            }
        }
    }

    private walkFraction(modelelement: Fraction, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeFraction(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterFraction(modelelement);
            }
        }
    }

    private walkSimpleNumber(modelelement: SimpleNumber, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeSimpleNumber(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterSimpleNumber(modelelement);
            }
        }
    }

    private walkInDepthMaterial(modelelement: InDepthMaterial, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeInDepthMaterial(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.content.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.questions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.grading.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterInDepthMaterial(modelelement);
            }
        }
    }

    private walkExamplePage(modelelement: ExamplePage, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeExamplePage(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.content.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.questions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.grading.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterExamplePage(modelelement);
            }
        }
    }

    private walkWorkSheet(modelelement: WorkSheet, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeWorkSheet(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.questions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.grading.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterWorkSheet(modelelement);
            }
        }
    }

    private walkVideo(modelelement: Video, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeVideo(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.questions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.grading.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterVideo(modelelement);
            }
        }
    }

    private walkTheory(modelelement: Theory, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTheory(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.content.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.questions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.grading.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTheory(modelelement);
            }
        }
    }

    private walkLastStep(modelelement: LastStep, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeLastStep(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.answerSeries.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterLastStep(modelelement);
            }
        }
    }

    private walkBinaryExpression(modelelement: BinaryExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBinaryExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBinaryExpression(modelelement);
            }
        }
    }

    private walkNumberLiteralExpression(modelelement: NumberLiteralExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNumberLiteralExpression(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNumberLiteralExpression(modelelement);
            }
        }
    }

    private walkNrOfCorrectAnswers(modelelement: NrOfCorrectAnswers, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNrOfCorrectAnswers(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNrOfCorrectAnswers(modelelement);
            }
        }
    }

    private walkQuestionReference(modelelement: QuestionReference, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeQuestionReference(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterQuestionReference(modelelement);
            }
        }
    }

    private walkNumberConcept(modelelement: NumberConcept, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNumberConcept(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNumberConcept(modelelement);
            }
        }
    }

    private walkQuestion(modelelement: Question, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeQuestion(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.correctAnswer)) {
            this.walk(modelelement.correctAnswer, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterQuestion(modelelement);
            }
        }
    }

    private walkLine(modelelement: Line, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeLine(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterLine(modelelement);
            }
        }
    }

    private walkPage(modelelement: Page, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePage(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.questions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.grading.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPage(modelelement);
            }
        }
    }

    private walkAnswer(modelelement: Answer, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAnswer(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.value)) {
            this.walk(modelelement.value, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAnswer(modelelement);
            }
        }
    }

    private walkStep(modelelement: Step, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeStep(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.answerSeries.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterStep(modelelement);
            }
        }
    }

    private walkTestFlow(modelelement: TestFlow, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTestFlow(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.steps.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTestFlow(modelelement);
            }
        }
    }

    private walkScenario(modelelement: Scenario, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeScenario(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.testFlow.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.steps.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterScenario(modelelement);
            }
        }
    }

    private walkScoreExpression(modelelement: ScoreExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeScoreExpression(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterScoreExpression(modelelement);
            }
        }
    }

    private walkGradeScore(modelelement: GradeScore, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGradeScore(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.expr)) {
            this.walk(modelelement.expr, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGradeScore(modelelement);
            }
        }
    }

    private walkPrimitiveType(modelelement: PrimitiveType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePrimitiveType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPrimitiveType(modelelement);
            }
        }
    }

    private walkGrade(modelelement: Grade, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGrade(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGrade(modelelement);
            }
        }
    }

    private walkPageTransition(modelelement: PageTransition, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePageTransition(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPageTransition(modelelement);
            }
        }
    }

    private walkFlowRule(modelelement: FlowRule, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeFlowRule(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.transitions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterFlowRule(modelelement);
            }
        }
    }

    private walkFlow(modelelement: Flow, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeFlow(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.rules.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterFlow(modelelement);
            }
        }
    }

    private walkSiteGroup(modelelement: SiteGroup, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeSiteGroup(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterSiteGroup(modelelement);
            }
        }
    }

    private walkTest(modelelement: Test, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTest(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.scenarios.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTest(modelelement);
            }
        }
    }

    private walkTopic(modelelement: Topic, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTopic(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.pages.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTopic(modelelement);
            }
        }
    }

    private walkEducation(modelelement: Education, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEducation(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.topic.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.flow.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.tests.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.overviews.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEducation(modelelement);
            }
        }
    }
}
