// Generated by the Freon Language Generator.
import {} from "../../language/gen/index.js";
import { EntityModelWalker } from "../../utils/gen/index.js";
import { EntityModelSemanticAnalysisWalker } from "./EntityModelSemanticAnalysisWalker.js";
import { FreLanguageConcept, FreLanguage, FreNode, FreNodeReference } from "@freon4dsl/core";

export class EntityModelSemanticAnalyser {
    public correct(modelunit: FreNode) {
        let changesToBeMade: Map<FreNode, FreNode> = new Map<FreNode, FreNode>();
        // create the walker over the model tree
        const myWalker = new EntityModelWalker();

        // create the object that will find what needs ot be changed
        let myCorrector = new EntityModelSemanticAnalysisWalker(changesToBeMade);

        // and add the corrector to the walker
        myWalker.myWorkers.push(myCorrector);

        // do the work
        myWalker.walk(modelunit, () => {
            return true;
        });

        // now change all ref errors
        for (const [toBeReplaced, newObject] of changesToBeMade) {
            const myType: FreLanguageConcept = FreLanguage.getInstance().concept(toBeReplaced.freLanguageConcept());
            myType.properties.forEach((prop) => {
                if (prop.type !== "boolean" && !!toBeReplaced[prop.name]) {
                    newObject[prop.name] = toBeReplaced[prop.name];
                }
            });
            let parent: FreNode = toBeReplaced.freOwnerDescriptor().owner;
            const propName: string = toBeReplaced.freOwnerDescriptor().propertyName;
            const propIndex: number = toBeReplaced.freOwnerDescriptor().propertyIndex;
            if (propIndex !== undefined) {
                parent[propName].splice(propIndex, 1, newObject);
            } else {
                parent[propName] = newObject;
            }
        }
    }
}
