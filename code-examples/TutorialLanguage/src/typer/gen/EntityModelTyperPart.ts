// Generated by the Freon Language Generator.
import { FreTyper, FreCompositeTyper, FreType, AstType, FreNode, FreLanguage, FreCommonSuperTypeUtil } from "@freon4dsl/core";
import {
    BaseType,
    Entity,
    AttributeType,
    DivideExpression,
    PlusExpression,
    MultiplyExpression,
    AttributeRef,
    IfExpression,
    FunctionCallExpression,
    VariableRef,
    AbsExpression,
    Variable,
    EntityFunction,
    AttributeWithLimitedType,
} from "../../language/gen/index.js";

/**
 * Class EntityModelTyperPart implements the typer generated from, if present, the typer definition,
 * otherwise this class implements the default typer.
 */
export class EntityModelTyperPart implements FreTyper {
    mainTyper: FreCompositeTyper; //  EntityModelTyper;

    /**
     * Returns true if 'modelelement' is marked as 'type' in the Typer definition.
     * @param modelelement
     */
    public isType(modelelement: FreNode): boolean | null {
        if (modelelement instanceof Entity) {
            return true;
        } else if (modelelement instanceof AttributeType) {
            return true;
        }
        return false;
    }

    /**
     * Returns the type of 'modelelement' according to the type rules in the Typer Definition.
     * @param modelelement
     */
    public inferType(modelelement: FreNode): FreType | null {
        if (!modelelement) {
            return null;
        }
        let result: FreType = null;
        if (FreLanguage.getInstance().metaConformsToType(modelelement, "ComparisonExpression")) {
            result = AstType.create({ astElement: AttributeType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "OrExpression")) {
            result = AstType.create({ astElement: AttributeType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "AndExpression")) {
            result = AstType.create({ astElement: AttributeType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "DivideExpression")) {
            result = this.mainTyper.inferType((modelelement as DivideExpression) /* FretSelfExp A */?.left) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "PlusExpression")) {
            result = this.mainTyper.inferType((modelelement as PlusExpression) /* FretSelfExp A */?.left) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "MultiplyExpression")) {
            result = this.mainTyper.inferType((modelelement as MultiplyExpression) /* FretSelfExp A */?.left) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "BooleanLiteralExpression")) {
            result = AstType.create({ astElement: AttributeType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "NumberLiteralExpression")) {
            result = AstType.create({ astElement: AttributeType.Integer }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "StringLiteralExpression")) {
            result = AstType.create({ astElement: AttributeType.String }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "AttributeRef")) {
            result = this.mainTyper.inferType(
                (modelelement as AttributeRef) /* FretSelfExp A */?.attribute?.referred?.declaredType?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "IfExpression")) {
            result = this.mainTyper.inferType((modelelement as IfExpression) /* FretSelfExp A */?.whenTrue) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "FunctionCallExpression")) {
            result = this.mainTyper.inferType(
                (modelelement as FunctionCallExpression) /* FretSelfExp A */?.functionDefinition?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "VariableRef")) {
            result = this.mainTyper.inferType(
                (modelelement as VariableRef) /* FretSelfExp A */?.variable?.referred?.declaredType?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "AbsExpression")) {
            result = this.mainTyper.inferType((modelelement as AbsExpression) /* FretSelfExp A */?.expr) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "Variable")) {
            result = this.mainTyper.inferType(
                (modelelement as Variable) /* FretSelfExp A */?.declaredType?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "EntityFunction")) {
            result = this.mainTyper.inferType(
                (modelelement as EntityFunction) /* FretSelfExp A */?.declaredType?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "AttributeWithLimitedType")) {
            result = this.mainTyper.inferType(
                (modelelement as AttributeWithLimitedType) /* FretSelfExp A */?.declaredType?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "AttributeType")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "MockEnumeration")) {
            result = AstType.create({ astElement: modelelement });
        } else if (this.mainTyper.isType(modelelement)) {
            result = AstType.create({ astElement: modelelement });
        }
        return result;
    }

    /**
     * Returns true if type1 equals type2.
     * This is a strict equal.
     * @param type1
     * @param type2
     */
    public equals(type1: FreType, type2: FreType): boolean | null {
        if (!type1 || !type2) return false;
        if (type1.$typename === "AstType") {
            return (type1 as AstType).astElement === (type2 as AstType).astElement;
        }
        return false;
    }

    /**
     * Returns true if type1 conforms to type2. The direction is type1 conforms to type2.
     * @param type1
     * @param type2
     */
    public conforms(type1: FreType, type2: FreType): boolean | null {
        if (!type1 || !type2) return null;
        let result: boolean = false;
        if (this.equals(type1, type2)) {
            result = true;
        } else {
            this.getSuperTypes(type1).forEach((super1) => {
                if (this.equals(super1, type2)) {
                    result = true;
                }
            });
        }
        return result;
    }

    /**
     * Returns true if all types in typelist1 conform to the types in typelist2, pairswise, in the given order.
     * @param typelist1
     * @param typelist2
     */
    public conformsList(typelist1: FreType[], typelist2: FreType[]): boolean | null {
        if (typelist1.length !== typelist2.length) return false;
        let result: boolean = true;
        for (let index in typelist1) {
            result = this.conforms(typelist1[index], typelist2[index]);
            if (result == false) return result;
        }
        return result;
    }

    /**
     * Returns the common super type of all types in typelist
     * @param typelist
     */
    public commonSuper(typelist: FreType[]): FreType | null {
        const result: FreType[] = FreCommonSuperTypeUtil.commonSuperType(typelist, this.mainTyper);
        if (!!result && result.length > 0) {
            return result[0];
        }
        return null;
    }

    /**
     * Returns all super types as defined in the typer definition.
     * @param type
     */
    public getSuperTypes(type: FreType): FreType[] {
        if (!type) {
            return [];
        }
        let result: FreType[] = [];
        if (type.$typename === "AstType") {
            const elem: FreNode = (type as AstType).astElement;
            if (FreLanguage.getInstance().metaConformsToType(elem, "Entity")) {
                // todo use the conforms rule for 'myType' (?)
            } else {
                return [];
            }
        }
        return result;
    }

    private typeOf(myArg: FreNode | FreNode[]): FreType {
        let result: FreType;
        if (Array.isArray(myArg)) {
            result = this.mainTyper.commonSuperType(myArg);
        } else {
            result = this.mainTyper.inferType(myArg);
        }
        return result;
    }

    private getElemFromAstType(type: FreType, metatype: string): FreNode {
        if (type.$typename === "AstType") {
            const astElement: FreNode = (type as AstType).astElement;
            if (FreLanguage.getInstance().metaConformsToType(astElement, metatype)) {
                return astElement;
            }
        }
        return null;
    }
}
