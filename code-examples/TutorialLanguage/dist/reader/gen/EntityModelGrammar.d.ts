export declare const EntityModelGrammarStr =
	"\nnamespace EntityModelLanguage\ngrammar EntityModelGrammar {\n\n// rules for \"SomeOtherModelUnit\"\nSomeOtherModelUnit = 'SomeOtherModelUnit' identifier '{'\n\t 'somePart' Entity\n\t '}' ;\n\n// rules for \"EntityModelUnit\"\nEntityModelUnit = 'EntityModelUnit' identifier '{'\n\t 'functions'\n\t EntityFunction*\n\t 'entities'\n\t Entity*\n\t '}' ;\n\n// common rules\nEntity = 'Entity' identifier '{'\n\t 'isCompany' booleanLiteral\n\t 'baseInterface_attr' numberLiteral\n\t 'simpleprop' stringLiteral\n\t 'attributes'\n\t AttributeWithLimitedType*\n\t 'entAttributes'\n\t AttributeWithEntityType*\n\t 'functions'\n\t EntityFunction*\n\t 'int_attrs'\n\t AttributeWithLimitedType*\n\t 'int_functions'\n\t EntityFunction*\n\t ( 'baseEntity' __fre_reference )?\n\t 'baseInterface' __fre_reference\n\t '}' ;\n\nAttributeWithLimitedType = 'AttributeWithLimitedType' identifier '{'\n\t 'declaredType' AttributeType\n\t '}' ;\n\nAttributeWithEntityType = 'AttributeWithEntityType' identifier '{'\n\t 'declaredType' __fre_reference\n\t '}' ;\n\nEntityFunction = 'EntityFunction' identifier '{'\n\t 'aliases'\n\t stringLiteral*\n\t 'expression' EntityExpression\n\t 'parameters'\n\t Variable*\n\t 'declaredType' __fre_reference\n\t '}' ;\n\nAbsExpression = 'AbsExpression' '{'\n\t 'expr' EntityExpression\n\t ( 'appliedfeature' AppliedFeature )?\n\t '}' ;\n\nAttributeRef = 'AttributeRef' '{'\n\t ( 'appliedfeature' AppliedFeature )?\n\t 'attribute' __fre_reference\n\t '}' ;\n\nVariableRef = 'VariableRef' '{'\n\t ( 'appliedfeature' AppliedFeature )?\n\t 'variable' __fre_reference\n\t '}' ;\n\nStringLiteralExpression = 'StringLiteralExpression' '{'\n\t 'value' stringLiteral\n\t ( 'appliedfeature' AppliedFeature )?\n\t '}' ;\n\nNumberLiteralExpression = 'NumberLiteralExpression' '{'\n\t 'value' stringLiteral\n\t ( 'appliedfeature' AppliedFeature )?\n\t '}' ;\n\nBooleanLiteralExpression = 'BooleanLiteralExpression' '{'\n\t 'value' stringLiteral\n\t ( 'appliedfeature' AppliedFeature )?\n\t '}' ;\n\nFunctionCallExpression = 'FunctionCallExpression' '{'\n\t ( 'appliedfeature' AppliedFeature )?\n\t 'functionDefinition' __fre_reference\n\t '}' ;\n\nIfExpression = 'IfExpression' '{'\n\t 'condition' EntityExpression\n\t 'whenTrue' EntityExpression\n\t 'whenFalse' EntityExpression\n\t ( 'appliedfeature' AppliedFeature )?\n\t '}' ;\n\nVariable = 'Variable' identifier '{'\n\t 'declaredType' __fre_reference\n\t '}' ;\n\nEntityExpression = AbsExpression \n    | VariableRef \n    | LiteralExpression \n    | FunctionCallExpression \n    | IfExpression \n    | __fre_binary_EntityExpression ;\n\nAppliedFeature = AttributeRef  ;\n\nLiteralExpression = StringLiteralExpression \n    | NumberLiteralExpression \n    | BooleanLiteralExpression  ;\n\n__fre_binary_EntityExpression = [EntityExpression / __fre_binary_operator]2+ ;\nleaf __fre_binary_operator = 'GreaterThenExpression' | 'EqualsExpression' | 'AndExpression' | 'or' | '*' | '+' | '/' | '<' ;\n\nAttributeType = 'String'\n\t| 'Integer'\n\t| 'Boolean'\n\t| 'ANY' ;\n\n__fre_reference = [ identifier / '.' ]+ ;\n\n// white space and comments\nskip WHITE_SPACE = \"\\s+\" ;\nskip SINGLE_LINE_COMMENT = \"//[^\\r\\n]*\" ;\nskip MULTI_LINE_COMMENT = \"/\\*[^*]*\\*+(?:[^*/][^*]*\\*+)*/\" ;\n\n// the predefined basic types\nleaf identifier          = \"[a-zA-Z_][a-zA-Z0-9_]*\" ;\n/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */\nleaf stringLiteral       = '\"' \"[^\\\"\\\\]*(\\\\.[^\\\"\\\\]*)*\" '\"' ;\nleaf numberLiteral       = \"[0-9]+\";\nleaf booleanLiteral      = 'false' | 'true';\n\n}";
//# sourceMappingURL=EntityModelGrammar.d.ts.map
