// Generated by the Freon Language Generator.
// import { FreNode } from "../../language/gen/index.js";
import {
    DivideExpression,
    MultiplyExpression,
    MinusExpression,
    PlusExpression,
    BooleanLiteral,
    PercentageLiteral,
    NumberLiteral,
    EuroLiteral,
    TypeRef,
    GenericLiteral,
    GenericTypeDecl,
    PayoutRef,
    RiskRef,
    ParameterRef,
    RiskAdjustmentRef,
    InsurancePartRef,
    FunctionCallExpression,
    BinaryExpression,
    Literal,
    PremiumDays,
    InsuranceTheme,
    EuroType,
    BooleanType,
    NumberType,
    PercentageType,
    InsurancePartType,
    DocuType,
    Parameter,
    Description,
    CalcFunction,
    InsuranceProduct,
    InsurancePart,
    BaseProduct,
    EntityAttribute,
    Entity,
    GenericKind,
    Text4,
    Text3,
    Text2,
    Text,
    AttributeRef,
    DocuExpression,
    Part,
    Product,
    InsuranceModel,
} from "../../language/gen/index.js";
import { InsuranceModelWorker } from "./InsuranceModelWorker.js";
import { FreLogger, FreNode } from "@freon4dsl/core";

const LOGGER = new FreLogger("InsuranceModelWalker");

/**
 * Class InsuranceModelWalker implements the extended visitor pattern of instances of language InsuranceModel.
 * This class implements the traversal of the model tree, classes that implement InsuranceModelWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class InsuranceModelWalker {
    myWorkers: InsuranceModelWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: FreNode, includeChildren?: (elem: FreNode) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof DivideExpression) {
                return this.walkDivideExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof MultiplyExpression) {
                return this.walkMultiplyExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof MinusExpression) {
                return this.walkMinusExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof PlusExpression) {
                return this.walkPlusExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof BooleanLiteral) {
                return this.walkBooleanLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof PercentageLiteral) {
                return this.walkPercentageLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof NumberLiteral) {
                return this.walkNumberLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof EuroLiteral) {
                return this.walkEuroLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof TypeRef) {
                return this.walkTypeRef(modelelement, includeChildren);
            }
            if (modelelement instanceof GenericLiteral) {
                return this.walkGenericLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof GenericTypeDecl) {
                return this.walkGenericTypeDecl(modelelement, includeChildren);
            }
            if (modelelement instanceof PayoutRef) {
                return this.walkPayoutRef(modelelement, includeChildren);
            }
            if (modelelement instanceof RiskRef) {
                return this.walkRiskRef(modelelement, includeChildren);
            }
            if (modelelement instanceof ParameterRef) {
                return this.walkParameterRef(modelelement, includeChildren);
            }
            if (modelelement instanceof RiskAdjustmentRef) {
                return this.walkRiskAdjustmentRef(modelelement, includeChildren);
            }
            if (modelelement instanceof InsurancePartRef) {
                return this.walkInsurancePartRef(modelelement, includeChildren);
            }
            if (modelelement instanceof FunctionCallExpression) {
                return this.walkFunctionCallExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof BinaryExpression) {
                return this.walkBinaryExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof Literal) {
                return this.walkLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof PremiumDays) {
                return this.walkPremiumDays(modelelement, includeChildren);
            }
            if (modelelement instanceof InsuranceTheme) {
                return this.walkInsuranceTheme(modelelement, includeChildren);
            }
            if (modelelement instanceof EuroType) {
                return this.walkEuroType(modelelement, includeChildren);
            }
            if (modelelement instanceof BooleanType) {
                return this.walkBooleanType(modelelement, includeChildren);
            }
            if (modelelement instanceof NumberType) {
                return this.walkNumberType(modelelement, includeChildren);
            }
            if (modelelement instanceof PercentageType) {
                return this.walkPercentageType(modelelement, includeChildren);
            }
            if (modelelement instanceof InsurancePartType) {
                return this.walkInsurancePartType(modelelement, includeChildren);
            }
            if (modelelement instanceof DocuType) {
                return this.walkDocuType(modelelement, includeChildren);
            }
            if (modelelement instanceof Parameter) {
                return this.walkParameter(modelelement, includeChildren);
            }
            if (modelelement instanceof Description) {
                return this.walkDescription(modelelement, includeChildren);
            }
            if (modelelement instanceof CalcFunction) {
                return this.walkCalcFunction(modelelement, includeChildren);
            }
            if (modelelement instanceof InsuranceProduct) {
                return this.walkInsuranceProduct(modelelement, includeChildren);
            }
            if (modelelement instanceof InsurancePart) {
                return this.walkInsurancePart(modelelement, includeChildren);
            }
            if (modelelement instanceof BaseProduct) {
                return this.walkBaseProduct(modelelement, includeChildren);
            }
            if (modelelement instanceof EntityAttribute) {
                return this.walkEntityAttribute(modelelement, includeChildren);
            }
            if (modelelement instanceof Entity) {
                return this.walkEntity(modelelement, includeChildren);
            }
            if (modelelement instanceof GenericKind) {
                return this.walkGenericKind(modelelement, includeChildren);
            }
            if (modelelement instanceof Text4) {
                return this.walkText4(modelelement, includeChildren);
            }
            if (modelelement instanceof Text3) {
                return this.walkText3(modelelement, includeChildren);
            }
            if (modelelement instanceof Text2) {
                return this.walkText2(modelelement, includeChildren);
            }
            if (modelelement instanceof Text) {
                return this.walkText(modelelement, includeChildren);
            }
            if (modelelement instanceof AttributeRef) {
                return this.walkAttributeRef(modelelement, includeChildren);
            }
            if (modelelement instanceof DocuExpression) {
                return this.walkDocuExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof Part) {
                return this.walkPart(modelelement, includeChildren);
            }
            if (modelelement instanceof Product) {
                return this.walkProduct(modelelement, includeChildren);
            }
            if (modelelement instanceof InsuranceModel) {
                return this.walkInsuranceModel(modelelement, includeChildren);
            }
        } else {
            LOGGER.error("No worker found.");
        }
    }

    private walkDivideExpression(modelelement: DivideExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDivideExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDivideExpression(modelelement);
            }
        }
    }

    private walkMultiplyExpression(modelelement: MultiplyExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMultiplyExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMultiplyExpression(modelelement);
            }
        }
    }

    private walkMinusExpression(modelelement: MinusExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMinusExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMinusExpression(modelelement);
            }
        }
    }

    private walkPlusExpression(modelelement: PlusExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePlusExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPlusExpression(modelelement);
            }
        }
    }

    private walkBooleanLiteral(modelelement: BooleanLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBooleanLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBooleanLiteral(modelelement);
            }
        }
    }

    private walkPercentageLiteral(modelelement: PercentageLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePercentageLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPercentageLiteral(modelelement);
            }
        }
    }

    private walkNumberLiteral(modelelement: NumberLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNumberLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNumberLiteral(modelelement);
            }
        }
    }

    private walkEuroLiteral(modelelement: EuroLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEuroLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEuroLiteral(modelelement);
            }
        }
    }

    private walkTypeRef(modelelement: TypeRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTypeRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTypeRef(modelelement);
            }
        }
    }

    private walkGenericLiteral(modelelement: GenericLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGenericLiteral(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.content.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGenericLiteral(modelelement);
            }
        }
    }

    private walkGenericTypeDecl(modelelement: GenericTypeDecl, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGenericTypeDecl(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.baseType)) {
            this.walk(modelelement.baseType, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGenericTypeDecl(modelelement);
            }
        }
    }

    private walkPayoutRef(modelelement: PayoutRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePayoutRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPayoutRef(modelelement);
            }
        }
    }

    private walkRiskRef(modelelement: RiskRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeRiskRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterRiskRef(modelelement);
            }
        }
    }

    private walkParameterRef(modelelement: ParameterRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeParameterRef(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.attribute)) {
            this.walk(modelelement.attribute, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterParameterRef(modelelement);
            }
        }
    }

    private walkRiskAdjustmentRef(modelelement: RiskAdjustmentRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeRiskAdjustmentRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterRiskAdjustmentRef(modelelement);
            }
        }
    }

    private walkInsurancePartRef(modelelement: InsurancePartRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeInsurancePartRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterInsurancePartRef(modelelement);
            }
        }
    }

    private walkFunctionCallExpression(modelelement: FunctionCallExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeFunctionCallExpression(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.args.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterFunctionCallExpression(modelelement);
            }
        }
    }

    private walkBinaryExpression(modelelement: BinaryExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBinaryExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBinaryExpression(modelelement);
            }
        }
    }

    private walkLiteral(modelelement: Literal, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterLiteral(modelelement);
            }
        }
    }

    private walkPremiumDays(modelelement: PremiumDays, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePremiumDays(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPremiumDays(modelelement);
            }
        }
    }

    private walkInsuranceTheme(modelelement: InsuranceTheme, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeInsuranceTheme(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterInsuranceTheme(modelelement);
            }
        }
    }

    private walkEuroType(modelelement: EuroType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEuroType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEuroType(modelelement);
            }
        }
    }

    private walkBooleanType(modelelement: BooleanType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBooleanType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBooleanType(modelelement);
            }
        }
    }

    private walkNumberType(modelelement: NumberType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNumberType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNumberType(modelelement);
            }
        }
    }

    private walkPercentageType(modelelement: PercentageType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePercentageType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPercentageType(modelelement);
            }
        }
    }

    private walkInsurancePartType(modelelement: InsurancePartType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeInsurancePartType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterInsurancePartType(modelelement);
            }
        }
    }

    private walkDocuType(modelelement: DocuType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDocuType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDocuType(modelelement);
            }
        }
    }

    private walkParameter(modelelement: Parameter, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeParameter(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.declaredType)) {
            this.walk(modelelement.declaredType, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterParameter(modelelement);
            }
        }
    }

    private walkDescription(modelelement: Description, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDescription(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDescription(modelelement);
            }
        }
    }

    private walkCalcFunction(modelelement: CalcFunction, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeCalcFunction(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.description)) {
            this.walk(modelelement.description, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.declaredType)) {
            this.walk(modelelement.declaredType, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.body)) {
            this.walk(modelelement.body, includeChildren);
        }
        modelelement.parameters.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterCalcFunction(modelelement);
            }
        }
    }

    private walkInsuranceProduct(modelelement: InsuranceProduct, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeInsuranceProduct(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.advertisedPremium)) {
            this.walk(modelelement.advertisedPremium, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.riskAdjustment)) {
            this.walk(modelelement.riskAdjustment, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.calculation)) {
            this.walk(modelelement.calculation, includeChildren);
        }
        modelelement.helpers.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterInsuranceProduct(modelelement);
            }
        }
    }

    private walkInsurancePart(modelelement: InsurancePart, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeInsurancePart(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.statisticalRisk)) {
            this.walk(modelelement.statisticalRisk, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.maximumPayOut)) {
            this.walk(modelelement.maximumPayOut, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterInsurancePart(modelelement);
            }
        }
    }

    private walkBaseProduct(modelelement: BaseProduct, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBaseProduct(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.parts.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBaseProduct(modelelement);
            }
        }
    }

    private walkEntityAttribute(modelelement: EntityAttribute, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntityAttribute(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntityAttribute(modelelement);
            }
        }
    }

    private walkEntity(modelelement: Entity, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntity(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntity(modelelement);
            }
        }
    }

    private walkGenericKind(modelelement: GenericKind, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGenericKind(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGenericKind(modelelement);
            }
        }
    }

    private walkText4(modelelement: Text4, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeText4(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterText4(modelelement);
            }
        }
    }

    private walkText3(modelelement: Text3, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeText3(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterText3(modelelement);
            }
        }
    }

    private walkText2(modelelement: Text2, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeText2(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterText2(modelelement);
            }
        }
    }

    private walkText(modelelement: Text, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeText(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterText(modelelement);
            }
        }
    }

    private walkAttributeRef(modelelement: AttributeRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAttributeRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAttributeRef(modelelement);
            }
        }
    }

    private walkDocuExpression(modelelement: DocuExpression, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDocuExpression(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDocuExpression(modelelement);
            }
        }
    }

    private walkPart(modelelement: Part, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePart(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.part)) {
            this.walk(modelelement.part, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPart(modelelement);
            }
        }
    }

    private walkProduct(modelelement: Product, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeProduct(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.product)) {
            this.walk(modelelement.product, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterProduct(modelelement);
            }
        }
    }

    private walkInsuranceModel(modelelement: InsuranceModel, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeInsuranceModel(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.parts.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.products.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterInsuranceModel(modelelement);
            }
        }
    }
}
