// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    Product,
    InsuranceProduct,
    NumberLiteral,
    BooleanLiteral,
    FunctionCallExpression,
    InsurancePartRef,
    RiskAdjustmentRef,
    ParameterRef,
    RiskRef,
    PayoutRef,
    GenericLiteral,
    CalcFunction,
    Description,
    GenericTypeDecl,
    TypeRef,
    Parameter,
    BaseProduct,
    InsuranceTheme,
    EuroLiteral,
    PremiumDays,
    InsurancePart,
    PercentageLiteral,
    DocuExpression,
    AttributeRef,
    GenericKind,
    DocuType,
    NamedType,
    Literal,
    PlusExpression,
    MinusExpression,
    MultiplyExpression,
    DivideExpression,
} from "../../language/gen/index.js";
import { InsuranceModelSyntaxAnalyser } from "./InsuranceModelSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class ProductSyntaxAnalyserPart {
    mainAnalyser: InsuranceModelSyntaxAnalyser;

    constructor(mainAnalyser: InsuranceModelSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Product = InsuranceProduct ;
     * @param branch
     * @private
     */
    public transformProduct(branch: SPPTBranch): Product {
        // console.log('transformProduct called: ' + branch.name);
        let __product: InsuranceProduct;
        const children = this.mainAnalyser.getChildren(branch);
        __product = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry

        return Product.create({
            product: __product,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * InsuranceProduct = 'Insurance' 'Product' identifier '(' 'public' 'name:' stringLiteral ')' 'USES' [ __fre_reference / ',' ]*
     *	 'Themes:' [ InsuranceTheme / ',' ]*
     *	 'Premium:' EuroLiteral 'per' PremiumDays
     *	 'Insured' 'risks:'
     *	 ( __fre_reference ';' )*
     *	 'Calculation'
     *	 ( 'Risk' 'adjusted' 'by' '=' PercentageLiteral )?
     *	 'calculated' 'premium:' DocuExpression
     *	 ( 'Helper' 'functions:' CalcFunction* )? ;
     * @param branch
     * @private
     */
    public transformInsuranceProduct(branch: SPPTBranch): InsuranceProduct {
        // console.log('transformInsuranceProduct called: ' + branch.name);
        let __name: string;
        let __productName: string;
        let __basedOn: FreNodeReference<BaseProduct>[];
        let __themes: FreNodeReference<InsuranceTheme>[];
        let __advertisedPremium: EuroLiteral;
        let __nrPremiumDays: FreNodeReference<PremiumDays>;
        let __parts: FreNodeReference<InsurancePart>[];
        let __riskAdjustment: PercentageLiteral;
        let __calculation: DocuExpression;
        let __helpers: CalcFunction[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPrimEntry
        __productName = this.mainAnalyser.transformSharedPackedParseTreeNode(children[6]); // RHSPrimEntry
        __basedOn = this.mainAnalyser.transformSharedPackedParseTreeRefList<BaseProduct>(children[9], "BaseProduct", ","); // RHSRefListWithSeparator
        __themes = this.mainAnalyser.transformSharedPackedParseTreeRefList<InsuranceTheme>(children[11], "InsuranceTheme", ","); // RHSLimitedRefListEntryWithSeparator
        __advertisedPremium = this.mainAnalyser.transformSharedPackedParseTreeNode(children[13]); // RHSPartEntry
        __nrPremiumDays = this.mainAnalyser.freNodeRef<PremiumDays>(children[15], "PremiumDays"); // RHSLimitedRefEntry
        // RHSRefListWithTerminator
        __parts = [];
        const _myList = this.mainAnalyser.getChildren(children[18]);
        _myList.forEach((subNode) => {
            const _transformed = this.mainAnalyser.freNodeRef<InsurancePart>(subNode.nonSkipChildren?.toArray()[0], "InsurancePart");
            if (!!_transformed) {
                __parts.push(_transformed);
            }
        });
        if (!children[20].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[20]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);

            __riskAdjustment = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[4]); // RHSPartEntry
        }
        __calculation = this.mainAnalyser.transformSharedPackedParseTreeNode(children[23]); // RHSPartEntry

        if (!children[24].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[24]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);

            // RHSPartListEntry
            if (children[2].name !== "CalcFunction") {
                __helpers = this.mainAnalyser.transformSharedPackedParseTreeList<CalcFunction>(_propItem[2]);
            } else {
                // special case: only when this entry is the single rhs entry of this rule
                __helpers = [];
                for (const child of children) {
                    __helpers.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
                }
            }
        }
        return InsuranceProduct.create({
            name: __name,
            productName: __productName,
            basedOn: __basedOn,
            themes: __themes,
            advertisedPremium: __advertisedPremium,
            nrPremiumDays: __nrPremiumDays,
            parts: __parts,
            riskAdjustment: __riskAdjustment,
            calculation: __calculation,
            helpers: __helpers,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * NumberLiteral = numberLiteral ;
     * @param branch
     * @private
     */
    public transformNumberLiteral(branch: SPPTBranch): NumberLiteral {
        // console.log('transformNumberLiteral called: ' + branch.name);
        let __value: number;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry

        return NumberLiteral.create({
            value: __value,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * BooleanLiteral = booleanLiteral ;
     * @param branch
     * @private
     */
    public transformBooleanLiteral(branch: SPPTBranch): BooleanLiteral {
        // console.log('transformBooleanLiteral called: ' + branch.name);
        let __value: boolean;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry

        return BooleanLiteral.create({
            value: __value,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FunctionCallExpression = __fre_reference '(' [ DocuExpression / ',' ]* ')' ;
     * @param branch
     * @private
     */
    public transformFunctionCallExpression(branch: SPPTBranch): FunctionCallExpression {
        // console.log('transformFunctionCallExpression called: ' + branch.name);
        let __funcDefinition: FreNodeReference<CalcFunction>;
        let __args: DocuExpression[];
        const children = this.mainAnalyser.getChildren(branch);
        __funcDefinition = this.mainAnalyser.freNodeRef<CalcFunction>(children[0], "CalcFunction"); // RHSRefEntry
        __args = this.mainAnalyser.transformSharedPackedParseTreeList<DocuExpression>(children[2], ","); // RHSPartListWithSeparator

        return FunctionCallExpression.create({
            funcDefinition: __funcDefinition,
            args: __args,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * InsurancePartRef = __fre_reference ;
     * @param branch
     * @private
     */
    public transformInsurancePartRef(branch: SPPTBranch): InsurancePartRef {
        // console.log('transformInsurancePartRef called: ' + branch.name);
        let __part: FreNodeReference<InsurancePart>;
        const children = this.mainAnalyser.getChildren(branch);
        __part = this.mainAnalyser.freNodeRef<InsurancePart>(children[0], "InsurancePart"); // RHSRefEntry

        return InsurancePartRef.create({
            part: __part,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * RiskAdjustmentRef = 'riskAdjustment' ;
     * @param branch
     * @private
     */
    public transformRiskAdjustmentRef(branch: SPPTBranch): RiskAdjustmentRef {
        // console.log('transformRiskAdjustmentRef called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return RiskAdjustmentRef.create({
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ParameterRef = __fre_reference ( '.' AttributeRef )? ;
     * @param branch
     * @private
     */
    public transformParameterRef(branch: SPPTBranch): ParameterRef {
        // console.log('transformParameterRef called: ' + branch.name);
        let __parameter: FreNodeReference<Parameter>;
        let __attribute: AttributeRef;
        const children = this.mainAnalyser.getChildren(branch);
        __parameter = this.mainAnalyser.freNodeRef<Parameter>(children[0], "Parameter"); // RHSRefEntry

        if (!children[1].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[1]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __attribute = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        return ParameterRef.create({
            parameter: __parameter,
            attribute: __attribute,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * RiskRef = 'statisticalRisk' ;
     * @param branch
     * @private
     */
    public transformRiskRef(branch: SPPTBranch): RiskRef {
        // console.log('transformRiskRef called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return RiskRef.create({
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * PayoutRef = 'maximumPayOut' ;
     * @param branch
     * @private
     */
    public transformPayoutRef(branch: SPPTBranch): PayoutRef {
        // console.log('transformPayoutRef called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return PayoutRef.create({
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * GenericLiteral = GenericKind '\{' [ DocuExpression / ',' ]* '}' ;
     * @param branch
     * @private
     */
    public transformGenericLiteral(branch: SPPTBranch): GenericLiteral {
        // console.log('transformGenericLiteral called: ' + branch.name);
        let __kind: FreNodeReference<GenericKind>;
        let __content: DocuExpression[];
        const children = this.mainAnalyser.getChildren(branch);
        __kind = this.mainAnalyser.freNodeRef<GenericKind>(children[0], "GenericKind"); // RHSLimitedRefEntry
        __content = this.mainAnalyser.transformSharedPackedParseTreeList<DocuExpression>(children[2], ","); // RHSPartListWithSeparator

        return GenericLiteral.create({
            kind: __kind,
            content: __content,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * CalcFunction = identifier '(' [ Parameter / ',' ]* '):' DocuType '\{'
     *	 DocuExpression
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformCalcFunction(branch: SPPTBranch): CalcFunction {
        // console.log('transformCalcFunction called: ' + branch.name);
        let __name: string;
        let __parameters: Parameter[];
        let __declaredType: DocuType;
        let __body: DocuExpression;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __parameters = this.mainAnalyser.transformSharedPackedParseTreeList<Parameter>(children[2], ","); // RHSPartListWithSeparator
        __declaredType = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPartEntry
        __body = this.mainAnalyser.transformSharedPackedParseTreeNode(children[6]); // RHSPartEntry

        return CalcFunction.create({
            name: __name,
            parameters: __parameters,
            declaredType: __declaredType,
            body: __body,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Description = stringLiteral ;
     * @param branch
     * @private
     */
    public transformDescription(branch: SPPTBranch): Description {
        // console.log('transformDescription called: ' + branch.name);
        let __content: string;
        const children = this.mainAnalyser.getChildren(branch);
        __content = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry

        return Description.create({
            content: __content,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * GenericTypeDecl = GenericKind '<' DocuType '>' ;
     * @param branch
     * @private
     */
    public transformGenericTypeDecl(branch: SPPTBranch): GenericTypeDecl {
        // console.log('transformGenericTypeDecl called: ' + branch.name);
        let __kind: FreNodeReference<GenericKind>;
        let __baseType: DocuType;
        const children = this.mainAnalyser.getChildren(branch);
        __kind = this.mainAnalyser.freNodeRef<GenericKind>(children[0], "GenericKind"); // RHSLimitedRefEntry
        __baseType = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPartEntry

        return GenericTypeDecl.create({
            kind: __kind,
            baseType: __baseType,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * TypeRef = __fre_reference ;
     * @param branch
     * @private
     */
    public transformTypeRef(branch: SPPTBranch): TypeRef {
        // console.log('transformTypeRef called: ' + branch.name);
        let __type: FreNodeReference<NamedType>;
        const children = this.mainAnalyser.getChildren(branch);
        __type = this.mainAnalyser.freNodeRef<NamedType>(children[0], "NamedType"); // RHSRefEntry

        return TypeRef.create({
            type: __type,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Parameter = identifier ':' DocuType ;
     * @param branch
     * @private
     */
    public transformParameter(branch: SPPTBranch): Parameter {
        // console.log('transformParameter called: ' + branch.name);
        let __name: string;
        let __declaredType: DocuType;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __declaredType = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPartEntry

        return Parameter.create({
            name: __name,
            declaredType: __declaredType,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * DocuExpression = Literal
     *    | FunctionCallExpression
     *    | InsurancePartRef
     *    | ParameterRef
     *    | GenericLiteral
     *    | RiskAdjustmentRef
     *    | __fre_binary_DocuExpression ;
     * @param branch
     * @private
     */
    public transformDocuExpression(branch: SPPTBranch): DocuExpression {
        // console.log('transformDocuExpression called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * Literal = EuroLiteral
     *    | NumberLiteral
     *    | PercentageLiteral
     *    | BooleanLiteral  ;
     * @param branch
     * @private
     */
    public transformLiteral(branch: SPPTBranch): Literal {
        // console.log('transformLiteral called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * AttributeRef = RiskRef
     *    | PayoutRef  ;
     * @param branch
     * @private
     */
    public transformAttributeRef(branch: SPPTBranch): AttributeRef {
        // console.log('transformAttributeRef called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * DocuType = GenericTypeDecl
     *    | TypeRef  ;
     * @param branch
     * @private
     */
    public transformDocuType(branch: SPPTBranch): DocuType {
        // console.log('transformDocuType called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Generic method to transform binary expressions, which are parsed
     * according to these rules:
     * __fre_binary_DocuExpression = [DocuExpression / __fre_binary_operator]2+ ;
     * leaf __fre_binary_operator = '+' | '-' | '*' | '/' ;
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     * @param branch
     * @private
     */
    public transform__fre_binary_DocuExpression(branch: SPPTBranch): DocuExpression {
        // console.log('transform__fre_binary_DocuExpression called: ' + branch.name);
        const children = branch.nonSkipChildren.toArray();
        let index = 0;
        let first = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
        while (index < children.length) {
            let operator = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let second = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let combined: DocuExpression = null;
            switch (operator) {
                case "+": {
                    combined = PlusExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "-": {
                    combined = MinusExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "*": {
                    combined = MultiplyExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "/": {
                    combined = DivideExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                default: {
                    combined = null;
                }
            }
            first = combined;
        }
        return first;
    }

    /**
     * Method to transform branches that match the following rule:
     * GenericKind = 'Set'
     *	| 'Sequence'
     *	| 'Bag'
     *	| 'Collection' ;
     * @param branch
     * @private
     */
    public transformGenericKind(branch: SPPTBranch): GenericKind {
        const choice = branch.nonSkipMatchedText;
        if (choice === "Set") {
            return GenericKind.Set;
        } else if (choice === "Sequence") {
            return GenericKind.Sequence;
        } else if (choice === "Bag") {
            return GenericKind.Bag;
        } else if (choice === "Collection") {
            return GenericKind.Collection;
        } else {
            return null;
        }
    }

    /**
     * Method to transform branches that match the following rule:
     * PremiumDays = 'Week'
     *	| 'Month'
     *	| 'Quarter'
     *	| 'Semester'
     *	| 'Year' ;
     * @param branch
     * @private
     */
    public transformPremiumDays(branch: SPPTBranch): PremiumDays {
        const choice = branch.nonSkipMatchedText;
        if (choice === "Week") {
            return PremiumDays.Week;
        } else if (choice === "Month") {
            return PremiumDays.Month;
        } else if (choice === "Quarter") {
            return PremiumDays.Quarter;
        } else if (choice === "Semester") {
            return PremiumDays.Semester;
        } else if (choice === "Year") {
            return PremiumDays.Year;
        } else {
            return null;
        }
    }
}
