// Generated by the Freon Language Generator.
import { FreTyper, FreCompositeTyper, FreType, AstType, FreNode, FreLanguage, FreCommonSuperTypeUtil } from "@freon4dsl/core";
import {
    NamedType,
    InsurancePartType,
    PercentageType,
    NumberType,
    BooleanType,
    EuroType,
    DivideExpression,
    MultiplyExpression,
    MinusExpression,
    PlusExpression,
    TypeRef,
    GenericTypeDecl,
    GenericLiteral,
    ParameterRef,
    FunctionCallExpression,
    Parameter,
    CalcFunction,
    GenericKind,
} from "../../language/gen/index.js";
import { GenericType } from "../../typer/gen/type-concepts/index.js";

/**
 * Class InsuranceModelTyperPart implements the typer generated from, if present, the typer definition,
 * otherwise this class implements the default typer.
 */
export class InsuranceModelTyperPart implements FreTyper {
    mainTyper: FreCompositeTyper; //  InsuranceModelTyper;

    /**
     * Returns true if 'modelelement' is marked as 'type' in the Typer definition.
     * @param modelelement
     */
    public isType(modelelement: FreNode): boolean | null {
        if (modelelement instanceof InsurancePartType) {
            return true;
        } else if (modelelement instanceof PercentageType) {
            return true;
        } else if (modelelement instanceof NumberType) {
            return true;
        } else if (modelelement instanceof BooleanType) {
            return true;
        } else if (modelelement instanceof EuroType) {
            return true;
        }
        return false;
    }

    /**
     * Returns the type of 'modelelement' according to the type rules in the Typer Definition.
     * @param modelelement
     */
    public inferType(modelelement: FreNode): FreType | null {
        if (!modelelement) {
            return null;
        }
        let result: FreType = null;
        if (FreLanguage.getInstance().metaConformsToType(modelelement, "DivideExpression")) {
            result = this.mainTyper.commonSuperType([
                (modelelement as DivideExpression) /* FretSelfExp A */?.left,
                (modelelement as DivideExpression) /* FretSelfExp A */?.right,
            ]);
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "MultiplyExpression")) {
            result = this.mainTyper.commonSuperType([
                (modelelement as MultiplyExpression) /* FretSelfExp A */?.left,
                (modelelement as MultiplyExpression) /* FretSelfExp A */?.right,
            ]);
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "MinusExpression")) {
            result = this.mainTyper.commonSuperType([
                (modelelement as MinusExpression) /* FretSelfExp A */?.left,
                (modelelement as MinusExpression) /* FretSelfExp A */?.right,
            ]);
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "PlusExpression")) {
            result = this.mainTyper.commonSuperType([
                (modelelement as PlusExpression) /* FretSelfExp A */?.left,
                (modelelement as PlusExpression) /* FretSelfExp A */?.right,
            ]);
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "BooleanLiteral")) {
            result = AstType.create({ astElement: BooleanType.Boolean }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "PercentageLiteral")) {
            result = AstType.create({ astElement: PercentageType.Percentage }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "NumberLiteral")) {
            result = AstType.create({ astElement: NumberType.Number }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "EuroLiteral")) {
            result = AstType.create({ astElement: EuroType.EUR }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "TypeRef")) {
            result = this.mainTyper.inferType((modelelement as TypeRef) /* FretSelfExp A */?.type?.referred) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "GenericTypeDecl")) {
            result = GenericType.create({
                base: this.mainTyper.inferType((modelelement as GenericTypeDecl) /* FretSelfExp A */?.baseType) /* FretFunctionCallExp B */,
                kind: (modelelement as GenericTypeDecl) /* FretSelfExp A */?.kind?.referred,
            }) /* FretCreateExp A */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "GenericLiteral")) {
            result = GenericType.create({
                base: this.mainTyper.commonSuperType(
                    (modelelement as GenericLiteral) /* FretSelfExp A */?.content,
                ) /* FretFunctionCallExp A */,
                kind: (modelelement as GenericLiteral) /* FretSelfExp A */?.kind?.referred,
            }) /* FretCreateExp A */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "ParameterRef")) {
            result = this.mainTyper.inferType(
                (modelelement as ParameterRef) /* FretSelfExp A */?.parameter?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "RiskAdjustmentRef")) {
            result = AstType.create({ astElement: PercentageType.Percentage }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "InsurancePartRef")) {
            result = AstType.create({ astElement: InsurancePartType.InsurancePart }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "FunctionCallExpression")) {
            result = this.mainTyper.inferType(
                (modelelement as FunctionCallExpression) /* FretSelfExp A */?.funcDefinition?.referred,
            ) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "PayoutRef")) {
            result = AstType.create({ astElement: EuroType.EUR }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "RiskRef")) {
            result = AstType.create({ astElement: PercentageType.Percentage }) /* FretLimitedInstanceExp */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "Parameter")) {
            result = this.mainTyper.inferType((modelelement as Parameter) /* FretSelfExp A */?.declaredType) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "CalcFunction")) {
            result = this.mainTyper.inferType((modelelement as CalcFunction) /* FretSelfExp A */?.declaredType) /* FretPropertyCallExp C */;
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "GenericKind")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "InsurancePartType")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "PercentageType")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "NumberType")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "BooleanType")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "EuroType")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "InsuranceTheme")) {
            result = AstType.create({ astElement: modelelement });
        } else if (FreLanguage.getInstance().metaConformsToType(modelelement, "PremiumDays")) {
            result = AstType.create({ astElement: modelelement });
        } else if (this.mainTyper.isType(modelelement)) {
            result = AstType.create({ astElement: modelelement });
        }
        return result;
    }

    /**
     * Returns true if type1 equals type2.
     * This is a strict equal.
     * @param type1
     * @param type2
     */
    public equals(type1: FreType, type2: FreType): boolean | null {
        if (!type1 || !type2) return false;
        if (type1.$typename === "AstType") {
            if (FreLanguage.getInstance().metaConformsToType((type1 as AstType).astElement, "NamedType")) {
                const elem1: NamedType = (type1 as AstType).astElement as NamedType;
                const elem2: NamedType = (type2 as AstType).astElement as NamedType;
                if (!!elem1 && !!elem2) {
                    const condition1: boolean =
                        (elem1 as NamedType) /* FretVarCallExp A2 */?.name === (elem2 as NamedType) /* FretSelfExp A */?.name;
                    return condition1;
                }
            } else {
                return (type1 as AstType).astElement === (type2 as AstType).astElement;
            }
        } else if (type1.$typename === "GenericType") {
            const condition1: boolean = this.mainTyper.equals(
                (type1 as GenericType) /* FretVarCallExp A1 */?.base,
                (type2 as GenericType) /* FretSelfExp A */?.base,
            );
            const condition2: boolean =
                (type1 as GenericType) /* FretVarCallExp A1 */?.kind === (type2 as GenericType) /* FretSelfExp A */?.kind;
            return condition1 && condition2;
        }
        return false;
    }

    /**
     * Returns true if type1 conforms to type2. The direction is type1 conforms to type2.
     * @param type1
     * @param type2
     */
    public conforms(type1: FreType, type2: FreType): boolean | null {
        if (!type1 || !type2) return null;
        let result: boolean = false;
        if (this.equals(type1, type2)) {
            result = true;
        } else {
            this.getSuperTypes(type1).forEach((super1) => {
                if (this.equals(super1, type2)) {
                    result = true;
                }
            });
        }
        return result;
    }

    /**
     * Returns true if all types in typelist1 conform to the types in typelist2, pairswise, in the given order.
     * @param typelist1
     * @param typelist2
     */
    public conformsList(typelist1: FreType[], typelist2: FreType[]): boolean | null {
        if (typelist1.length !== typelist2.length) return false;
        let result: boolean = true;
        for (let index in typelist1) {
            result = this.conforms(typelist1[index], typelist2[index]);
            if (result == false) return result;
        }
        return result;
    }

    /**
     * Returns the common super type of all types in typelist
     * @param typelist
     */
    public commonSuper(typelist: FreType[]): FreType | null {
        const result: FreType[] = FreCommonSuperTypeUtil.commonSuperType(typelist, this.mainTyper);
        if (!!result && result.length > 0) {
            return result[0];
        }
        return null;
    }

    /**
     * Returns all super types as defined in the typer definition.
     * @param type
     */
    public getSuperTypes(type: FreType): FreType[] {
        if (!type) {
            return [];
        }
        let result: FreType[] = [];
        if (type.$typename === "AstType") {
            const elem: FreNode = (type as AstType).astElement;
            if (FreLanguage.getInstance().metaConformsToType(elem, "NamedType")) {
                // todo use the conforms rule for 'myType' (?)
            } else if (FreLanguage.getInstance().metaConformsToType(elem, "GenericKind")) {
                if (elem === GenericKind.Set) {
                    return [AstType.create({ astElement: GenericKind.Collection }) /* FretLimitedInstanceExp */];
                }
                if (elem === GenericKind.Sequence) {
                    return [AstType.create({ astElement: GenericKind.Collection }) /* FretLimitedInstanceExp */];
                }
                if (elem === GenericKind.Bag) {
                    return [AstType.create({ astElement: GenericKind.Collection }) /* FretLimitedInstanceExp */];
                }
            } else {
                return [];
            }
        } else if (type.$typename === "GenericType") {
            /* FretWhereExp */
            const rhs0: FreType[] = this.getSuperTypes((type as GenericType) /* FretSelfExp A */?.base /* FretPropertyCallExp B */);
            const rhs1: FreType[] = this.getSuperTypes(
                this.mainTyper.inferType((type as GenericType) /* FretSelfExp A */?.kind) /* FretPropertyCallExp C */,
            );
            /* make cartesian product of all conditions */
            /* do rhs0 times rhs1 */
            for (const partA of rhs0) {
                result.push(
                    GenericType.create({
                        base: partA as FreType,
                        kind: (type as GenericType).kind,
                    }),
                );
                for (const partB of rhs1) {
                    const elemB = this.getElemFromAstType(partB, "GenericKind");

                    result.push(
                        GenericType.create({
                            base: partA as FreType,
                            kind: elemB as GenericKind,
                        }),
                    );
                }
            }
            for (const partB of rhs1) {
                const elemB = this.getElemFromAstType(partB, "GenericKind");
                result.push(
                    GenericType.create({
                        kind: elemB as GenericKind,
                        base: (type as GenericType).base,
                    }),
                );
            }
        }
        return result;
    }

    private typeOf(myArg: FreNode | FreNode[]): FreType {
        let result: FreType;
        if (Array.isArray(myArg)) {
            result = this.mainTyper.commonSuperType(myArg);
        } else {
            result = this.mainTyper.inferType(myArg);
        }
        return result;
    }

    private getElemFromAstType(type: FreType, metatype: string): FreNode {
        if (type.$typename === "AstType") {
            const astElement: FreNode = (type as AstType).astElement;
            if (FreLanguage.getInstance().metaConformsToType(astElement, metatype)) {
                return astElement;
            }
        }
        return null;
    }
}
