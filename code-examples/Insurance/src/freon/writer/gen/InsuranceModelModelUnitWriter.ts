// Generated by the Freon Language Generator.
import { FreNamedNode, FreNodeReference, FreWriter, FreNode } from "@freon4dsl/core";
import {
    NamedType,
    Part,
    Product,
    DocuExpression,
    Literal,
    EuroLiteral,
    NumberLiteral,
    PercentageLiteral,
    BooleanLiteral,
    BinaryExpression,
    PlusExpression,
    MinusExpression,
    MultiplyExpression,
    DivideExpression,
    FunctionCallExpression,
    InsurancePartRef,
    RiskAdjustmentRef,
    ParameterRef,
    AttributeRef,
    RiskRef,
    PayoutRef,
    Text,
    Text2,
    Text3,
    Text4,
    GenericKind,
    GenericTypeDecl,
    GenericLiteral,
    Entity,
    EntityAttribute,
    BaseProduct,
    InsurancePart,
    InsuranceProduct,
    CalcFunction,
    Description,
    Parameter,
    DocuType,
    InsurancePartType,
    PercentageType,
    NumberType,
    BooleanType,
    EuroType,
    TypeRef,
    InsuranceTheme,
    PremiumDays,
} from "../../language/gen/index.js";

/**
 * SeparatorType is used to unparse lists.
 * NONE means only space(s) between the elements.
 * Terminator means that every element is terminated with a certain string.
 * Separator means that in between elements a certain string is placed.
 */
enum SeparatorType {
    NONE = "NONE",
    Terminator = "Terminator",
    Separator = "Separator",
    Initiator = "Initiator",
}

/**
 * Class InsuranceModelModelUnitWriter provides methods to return a string representation of an instance of
 * elements of language InsuranceModel.
 * It is, amongst others, used to create error messages in the validator.
 */
export class InsuranceModelModelUnitWriter implements FreWriter {
    output: string[] = []; // stores the result, one line per array element
    currentLine: number = 0; // keeps track of the element in 'output' that we are working on

    /**
     * Returns a string representation of 'modelelement'.
     * If 'short' is present and true, then a single-line result will be given.
     * Otherwise, the result is always a multi-line string.
     * Note that the single-line-string cannot be parsed into a correct model.
     *
     * @param modelelement
     * @param startIndent
     * @param short
     */
    public writeToString(modelelement: FreNode, startIndent?: number, short?: boolean): string {
        this.writeToLines(modelelement, startIndent, short);
        return `${this.output
            .map((line) => `${line.trimEnd()}`)
            .join("\n")
            .trimEnd()}`;
    }

    /**
     * Returns a string representation of 'modelelement', divided into an array of strings,
     * each of which contain a single line (without newline).
     * If 'short' is present and true, then a single-line result will be given.
     * Otherwise, the result is always a multi-line string.
     *
     * @param modelelement
     * @param startIndent
     * @param short
     */
    public writeToLines(modelelement: FreNode, startIndent?: number, short?: boolean): string[] {
        // set default for optional parameters
        if (startIndent === undefined) {
            startIndent = 0;
        }
        if (short === undefined) {
            short = false;
        }

        // make sure the global variables are reset
        this.output = [];
        this.currentLine = 0;

        // begin the unparsing with an indent if asked for
        let indentString: string = "";
        for (let _i = 0; _i < startIndent; _i++) {
            indentString += " ";
        }
        this.output[this.currentLine] = indentString;

        // do the actual work
        this.unparse(modelelement, short);
        return this.output;
    }

    /**
     * Returns the name of 'modelelement' if it has one, else returns
     * a short unparsing of 'modelelement'.
     * Used by the validator to produce readable error messages.
     *
     * @param modelelement
     */
    public writeNameOnly(modelelement: FreNode): string {
        if (!modelelement) {
            return "";
        }

        if (modelelement instanceof Part) {
            return modelelement.name;
        } else if (modelelement instanceof Product) {
            return modelelement.name;
        } else if (modelelement instanceof RiskAdjustmentRef) {
            return modelelement.name;
        } else if (modelelement instanceof AttributeRef) {
            return modelelement.name;
        } else if (modelelement instanceof RiskRef) {
            return modelelement.name;
        } else if (modelelement instanceof PayoutRef) {
            return modelelement.name;
        } else if (modelelement instanceof GenericKind) {
            return modelelement.name;
        } else if (modelelement instanceof Entity) {
            return modelelement.name;
        } else if (modelelement instanceof BaseProduct) {
            return modelelement.name;
        } else if (modelelement instanceof InsurancePart) {
            return modelelement.name;
        } else if (modelelement instanceof InsuranceProduct) {
            return modelelement.name;
        } else if (modelelement instanceof CalcFunction) {
            return modelelement.name;
        } else if (modelelement instanceof Parameter) {
            return modelelement.name;
        } else if (modelelement instanceof InsurancePartType) {
            return modelelement.name;
        } else if (modelelement instanceof PercentageType) {
            return modelelement.name;
        } else if (modelelement instanceof NumberType) {
            return modelelement.name;
        } else if (modelelement instanceof BooleanType) {
            return modelelement.name;
        } else if (modelelement instanceof EuroType) {
            return modelelement.name;
        } else if (modelelement instanceof InsuranceTheme) {
            return modelelement.name;
        } else if (modelelement instanceof PremiumDays) {
            return modelelement.name;
        } else {
            // make sure the global variables are reset
            this.output = [];
            this.currentLine = 0;
            // do not care about indent, we just need a single line
            this.output[this.currentLine] = "";
            // do the actual work
            this.unparse(modelelement, true);
            return this.output[0].trimEnd();
        }
    }

    private unparse(modelelement: FreNode, short: boolean) {
        if (!modelelement) {
            return;
        }
        switch (modelelement.freLanguageConcept()) {
            case "DocuExpression":
                this.unparseDocuExpression(modelelement as DocuExpression, short);
                break;
            case "Literal":
                this.unparseLiteral(modelelement as Literal, short);
                break;
            case "EuroLiteral":
                this.unparseEuroLiteral(modelelement as EuroLiteral, short);
                break;
            case "NumberLiteral":
                this.unparseNumberLiteral(modelelement as NumberLiteral, short);
                break;
            case "PercentageLiteral":
                this.unparsePercentageLiteral(modelelement as PercentageLiteral, short);
                break;
            case "BooleanLiteral":
                this.unparseBooleanLiteral(modelelement as BooleanLiteral, short);
                break;
            case "BinaryExpression":
                this.unparseBinaryExpression(modelelement as BinaryExpression, short);
                break;
            case "PlusExpression":
                this.unparsePlusExpression(modelelement as PlusExpression, short);
                break;
            case "MinusExpression":
                this.unparseMinusExpression(modelelement as MinusExpression, short);
                break;
            case "MultiplyExpression":
                this.unparseMultiplyExpression(modelelement as MultiplyExpression, short);
                break;
            case "DivideExpression":
                this.unparseDivideExpression(modelelement as DivideExpression, short);
                break;
            case "FunctionCallExpression":
                this.unparseFunctionCallExpression(modelelement as FunctionCallExpression, short);
                break;
            case "InsurancePartRef":
                this.unparseInsurancePartRef(modelelement as InsurancePartRef, short);
                break;
            case "RiskAdjustmentRef":
                this.unparseRiskAdjustmentRef(modelelement as RiskAdjustmentRef, short);
                break;
            case "ParameterRef":
                this.unparseParameterRef(modelelement as ParameterRef, short);
                break;
            case "AttributeRef":
                this.unparseAttributeRef(modelelement as AttributeRef, short);
                break;
            case "RiskRef":
                this.unparseRiskRef(modelelement as RiskRef, short);
                break;
            case "PayoutRef":
                this.unparsePayoutRef(modelelement as PayoutRef, short);
                break;
            case "Text":
                this.unparseText(modelelement as Text, short);
                break;
            case "Text2":
                this.unparseText2(modelelement as Text2, short);
                break;
            case "Text3":
                this.unparseText3(modelelement as Text3, short);
                break;
            case "Text4":
                this.unparseText4(modelelement as Text4, short);
                break;
            case "GenericKind":
                this.unparseGenericKind(modelelement as GenericKind, short);
                break;
            case "GenericTypeDecl":
                this.unparseGenericTypeDecl(modelelement as GenericTypeDecl, short);
                break;
            case "GenericLiteral":
                this.unparseGenericLiteral(modelelement as GenericLiteral, short);
                break;
            case "Entity":
                this.unparseEntity(modelelement as Entity, short);
                break;
            case "EntityAttribute":
                this.unparseEntityAttribute(modelelement as EntityAttribute, short);
                break;
            case "BaseProduct":
                this.unparseBaseProduct(modelelement as BaseProduct, short);
                break;
            case "InsurancePart":
                this.unparseInsurancePart(modelelement as InsurancePart, short);
                break;
            case "InsuranceProduct":
                this.unparseInsuranceProduct(modelelement as InsuranceProduct, short);
                break;
            case "CalcFunction":
                this.unparseCalcFunction(modelelement as CalcFunction, short);
                break;
            case "Description":
                this.unparseDescription(modelelement as Description, short);
                break;
            case "Parameter":
                this.unparseParameter(modelelement as Parameter, short);
                break;
            case "DocuType":
                this.unparseDocuType(modelelement as DocuType, short);
                break;
            case "InsurancePartType":
                this.unparseInsurancePartType(modelelement as InsurancePartType, short);
                break;
            case "PercentageType":
                this.unparsePercentageType(modelelement as PercentageType, short);
                break;
            case "NumberType":
                this.unparseNumberType(modelelement as NumberType, short);
                break;
            case "BooleanType":
                this.unparseBooleanType(modelelement as BooleanType, short);
                break;
            case "EuroType":
                this.unparseEuroType(modelelement as EuroType, short);
                break;
            case "TypeRef":
                this.unparseTypeRef(modelelement as TypeRef, short);
                break;
            case "InsuranceTheme":
                this.unparseInsuranceTheme(modelelement as InsuranceTheme, short);
                break;
            case "PremiumDays":
                this.unparsePremiumDays(modelelement as PremiumDays, short);
                break;
            case "Part":
                this.unparsePart(modelelement as Part, short);
                break;
            case "Product":
                this.unparseProduct(modelelement as Product, short);
                break;
            case "NamedType":
                this.unparseNamedType(modelelement as NamedType, short);
                break;
        }
    }

    /**
     * Unparsing of 'EuroLiteral' according to projection 'default'.
     */
    private unparseEuroLiteral(modelelement: EuroLiteral, short: boolean) {
        this.output[this.currentLine] += `EUR `;
        this.output[this.currentLine] += `${modelelement.euros} `;
        this.output[this.currentLine] += `, `;
        this.output[this.currentLine] += `${modelelement.cents} `;
    }

    /**
     * Unparsing of 'NumberLiteral' according to projection 'default'.
     */
    private unparseNumberLiteral(modelelement: NumberLiteral, short: boolean) {
        this.output[this.currentLine] += `${modelelement.value} `;
    }

    /**
     * Unparsing of 'PercentageLiteral' according to projection 'default'.
     */
    private unparsePercentageLiteral(modelelement: PercentageLiteral, short: boolean) {
        this.output[this.currentLine] += `${modelelement.value} `;
        this.output[this.currentLine] += `% `;
    }

    /**
     * Unparsing of 'BooleanLiteral' according to projection 'default'.
     */
    private unparseBooleanLiteral(modelelement: BooleanLiteral, short: boolean) {
        if (modelelement.value) {
            this.output[this.currentLine] += `YES `;
        } else {
            this.output[this.currentLine] += `NO `;
        }
    }

    /**
     * Unparsing of 'FunctionCallExpression' according to projection 'default'.
     */
    private unparseFunctionCallExpression(modelelement: FunctionCallExpression, short: boolean) {
        this._unparseReference(modelelement.funcDefinition, short);
        this.output[this.currentLine] += `( `;
        this._unparseList(
            modelelement.args,
            ", ",
            SeparatorType.Separator,
            false,
            this.output[this.currentLine].length,
            short,
            (modelelement, short) => this.unparse(modelelement, short),
        );
        this.output[this.currentLine] += `) `;
    }

    /**
     * Unparsing of 'InsurancePartRef' according to projection 'default'.
     */
    private unparseInsurancePartRef(modelelement: InsurancePartRef, short: boolean) {
        this._unparseReference(modelelement.part, short);
    }

    /**
     * Unparsing of 'RiskAdjustmentRef' according to projection 'default'.
     */
    private unparseRiskAdjustmentRef(modelelement: RiskAdjustmentRef, short: boolean) {
        this.output[this.currentLine] += `riskAdjustment `;
    }

    /**
     * Unparsing of 'ParameterRef' according to projection 'default'.
     */
    private unparseParameterRef(modelelement: ParameterRef, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        this._unparseReference(modelelement.parameter, short);
        if (!!modelelement.attribute) {
            this.output[this.currentLine] += `. `;
            this.unparse(modelelement.attribute, short);
        }
    }

    /**
     * Unparsing of 'RiskRef' according to projection 'default'.
     */
    private unparseRiskRef(modelelement: RiskRef, short: boolean) {
        this.output[this.currentLine] += `statisticalRisk `;
    }

    /**
     * Unparsing of 'PayoutRef' according to projection 'default'.
     */
    private unparsePayoutRef(modelelement: PayoutRef, short: boolean) {
        this.output[this.currentLine] += `maximumPayOut `;
    }

    /**
     * Unparsing of 'GenericLiteral' according to projection 'default'.
     */
    private unparseGenericLiteral(modelelement: GenericLiteral, short: boolean) {
        this._unparseReference(modelelement.kind, short);
        this.output[this.currentLine] += `\{ `;
        this._unparseList(
            modelelement.content,
            ", ",
            SeparatorType.Separator,
            false,
            this.output[this.currentLine].length,
            short,
            (modelelement, short) => this.unparse(modelelement, short),
        );
        this.output[this.currentLine] += `} `;
    }

    /**
     * Unparsing of 'TypeRef' according to projection 'default'.
     */
    private unparseTypeRef(modelelement: TypeRef, short: boolean) {
        this._unparseReference(modelelement.type, short);
    }

    /**
     * Unparsing of 'GenericTypeDecl' according to projection 'default'.
     */
    private unparseGenericTypeDecl(modelelement: GenericTypeDecl, short: boolean) {
        this._unparseReference(modelelement.kind, short);
        this.output[this.currentLine] += `< `;
        this.unparse(modelelement.baseType, short);
        this.output[this.currentLine] += `> `;
    }

    /**
     * Unparsing of 'Text' according to projection 'default'.
     */
    private unparseText(modelelement: Text, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `This is `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 8);
            this.output[this.currentLine] += `literal text `;
            this.newlineAndIndentation(blockIndent + 6);
            this.output[this.currentLine] += `that is projected in the `;
            this.newlineAndIndentation(blockIndent + 16);
            this.output[this.currentLine] += `editor `;
            this.newlineAndIndentation(blockIndent + 2);
            this.output[this.currentLine] += `for every concept of type Text. `;
        }
    }

    /**
     * Unparsing of 'Text2' according to projection 'default'.
     */
    private unparseText2(modelelement: Text2, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `This is `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 8);
            this.output[this.currentLine] += `literal text `;
            this.newlineAndIndentation(blockIndent + 6);
            this.output[this.currentLine] += `that is projected in the `;
            this.newlineAndIndentation(blockIndent + 16);
            this.output[this.currentLine] += `editor `;
            this.newlineAndIndentation(blockIndent + 2);
            this.output[this.currentLine] += `for every concept of type Text. `;
        }
    }

    /**
     * Unparsing of 'Text3' according to projection 'default'.
     */
    private unparseText3(modelelement: Text3, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `This is `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 8);
            this.output[this.currentLine] += `literal text `;
            this.newlineAndIndentation(blockIndent + 3);
            this.output[this.currentLine] += `that is projected in the `;
            this.newlineAndIndentation(blockIndent + 11);
            this.output[this.currentLine] += `editor `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `for every concept of type Text. `;
        }
    }

    /**
     * Unparsing of 'Text4' according to projection 'default'.
     */
    private unparseText4(modelelement: Text4, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `This is `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 8);
            this.output[this.currentLine] += `literal text `;
            this.newlineAndIndentation(blockIndent + 3);
            this.output[this.currentLine] += `that is projected in the `;
            this.newlineAndIndentation(blockIndent + 11);
            this.output[this.currentLine] += `editor `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `for every concept of type Text. `;
        }
    }

    /**
     * Unparsing of 'Part' according to projection 'default'.
     */
    private unparsePart(modelelement: Part, short: boolean) {
        this.unparse(modelelement.part, short);
    }

    /**
     * Unparsing of 'Product' according to projection 'default'.
     */
    private unparseProduct(modelelement: Product, short: boolean) {
        this.unparse(modelelement.product, short);
    }

    /**
     * Unparsing of 'BaseProduct' according to projection 'default'.
     */
    private unparseBaseProduct(modelelement: BaseProduct, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Base Products `;
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `for `;
        this._unparseReference(modelelement.theme, short);

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this._unparseList(
                modelelement.parts,
                "",
                SeparatorType.Separator,
                true,
                this.output[this.currentLine].length,
                short,
                (modelelement, short) => this.unparse(modelelement, short),
            );
        }
    }

    /**
     * Unparsing of 'InsurancePart' according to projection 'default'.
     */
    private unparseInsurancePart(modelelement: InsurancePart, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Insurance Part `;
        this.output[this.currentLine] += `${modelelement.name} `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `risk assessment: `;
            this.unparse(modelelement.statisticalRisk, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `maximum payout: `;
            this.unparse(modelelement.maximumPayOut, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `is approved: `;
            if (modelelement.isApproved) {
                this.output[this.currentLine] += `JA `;
            } else {
                this.output[this.currentLine] += `NEE `;
            }
        }
    }

    /**
     * Unparsing of 'InsuranceProduct' according to projection 'default'.
     */
    private unparseInsuranceProduct(modelelement: InsuranceProduct, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Insurance Product `;
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `( public name: `;
        this.output[this.currentLine] += `"${modelelement.productName}" `;
        this.output[this.currentLine] += `) USES `;
        this._unparseReferenceList(modelelement.basedOn, ", ", SeparatorType.Separator, false, this.output[this.currentLine].length, short);

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Themes: `;
            this._unparseReferenceList(
                modelelement.themes,
                ", ",
                SeparatorType.Separator,
                false,
                this.output[this.currentLine].length,
                short,
            );
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Premium: `;
            this.unparse(modelelement.advertisedPremium, short);
            this.output[this.currentLine] += `per `;
            this._unparseReference(modelelement.nrPremiumDays, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Insured risks: `;
            this.newlineAndIndentation(blockIndent + 8);
            this._unparseReferenceList(
                modelelement.parts,
                "; ",
                SeparatorType.Terminator,
                true,
                this.output[this.currentLine].length,
                short,
            );
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `Calculation `;
            if (!!modelelement.riskAdjustment) {
                this.newlineAndIndentation(blockIndent + 8 + -4);
                this.output[this.currentLine] += `Risk adjusted by = `;
                this.unparse(modelelement.riskAdjustment, short);
            }
            this.newlineAndIndentation(blockIndent + 8);
            this.output[this.currentLine] += `calculated premium: `;
            this.unparse(modelelement.calculation, short);
            if (!!modelelement.helpers && modelelement.helpers.length > 0) {
                this.newlineAndIndentation(blockIndent + 4 + 0);
                this.output[this.currentLine] += `Helper functions: `;
                this._unparseList(
                    modelelement.helpers,
                    "",
                    SeparatorType.Separator,
                    true,
                    this.output[this.currentLine].length,
                    short,
                    (modelelement, short) => this.unparse(modelelement, short),
                );
            }
        }
    }

    /**
     * Unparsing of 'CalcFunction' according to projection 'default'.
     */
    private unparseCalcFunction(modelelement: CalcFunction, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `( `;
        this._unparseList(
            modelelement.parameters,
            ", ",
            SeparatorType.Separator,
            false,
            this.output[this.currentLine].length,
            short,
            (modelelement, short) => this.unparse(modelelement, short),
        );
        this.output[this.currentLine] += `): `;
        this.unparse(modelelement.declaredType, short);
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.unparse(modelelement.body, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * Unparsing of 'Description' according to projection 'default'.
     */
    private unparseDescription(modelelement: Description, short: boolean) {
        this.output[this.currentLine] += `"${modelelement.content}" `;
    }

    /**
     * Unparsing of 'Parameter' according to projection 'default'.
     */
    private unparseParameter(modelelement: Parameter, short: boolean) {
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `: `;
        this.unparse(modelelement.declaredType, short);
    }

    /**
     * Unparsing of 'Entity' according to projection 'default'.
     */
    private unparseEntity(modelelement: Entity, short: boolean) {
        if (modelelement.isCompany) {
            this.output[this.currentLine] += `COMPANY `;
        } else {
            this.output[this.currentLine] += ` `;
        }
        this.output[this.currentLine] += `${modelelement.name} `;
    }

    /**
     * Unparsing of 'EntityAttribute' according to projection 'default'.
     */
    private unparseEntityAttribute(modelelement: EntityAttribute, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `EntityAttribute `;
        this.output[this.currentLine] += `\{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `numVal `;
            this.output[this.currentLine] += `${modelelement.numVal} `;
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }
    /**
     * See the public unparse method.
     */
    private unparseMinusExpression(modelelement: MinusExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "- ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparsePlusExpression(modelelement: PlusExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "+ ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseMultiplyExpression(modelelement: MultiplyExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "* ";
        this.unparse(modelelement.right, short);
    }
    /**
     * See the public unparse method.
     */
    private unparseDivideExpression(modelelement: DivideExpression, short: boolean) {
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "/ ";
        this.unparse(modelelement.right, short);
    }
    /**
     * The limited concept 'GenericKind' is unparsed as its name.
     */
    private unparseGenericKind(modelelement: GenericKind, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The limited concept 'InsurancePartType' is unparsed as its name.
     */
    private unparseInsurancePartType(modelelement: InsurancePartType, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The limited concept 'PercentageType' is unparsed as its name.
     */
    private unparsePercentageType(modelelement: PercentageType, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The limited concept 'NumberType' is unparsed as its name.
     */
    private unparseNumberType(modelelement: NumberType, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The limited concept 'BooleanType' is unparsed as its name.
     */
    private unparseBooleanType(modelelement: BooleanType, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The limited concept 'EuroType' is unparsed as its name.
     */
    private unparseEuroType(modelelement: EuroType, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The limited concept 'InsuranceTheme' is unparsed as its name.
     */
    private unparseInsuranceTheme(modelelement: InsuranceTheme, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The limited concept 'PremiumDays' is unparsed as its name.
     */
    private unparsePremiumDays(modelelement: PremiumDays, short: boolean) {
        if (!!modelelement) {
            this.output[this.currentLine] += modelelement.name + " ";
        }
    }
    /**
     * The abstract concept 'DocuExpression' is not unparsed.
     */
    private unparseDocuExpression(modelelement: DocuExpression, short: boolean) {
        throw new Error("Method unparseDocuExpression should be implemented by its (concrete) subclasses.");
    }
    /**
     * The abstract concept 'Literal' is not unparsed.
     */
    private unparseLiteral(modelelement: Literal, short: boolean) {
        throw new Error("Method unparseLiteral should be implemented by its (concrete) subclasses.");
    }
    /**
     * The abstract concept 'BinaryExpression' is not unparsed.
     */
    private unparseBinaryExpression(modelelement: BinaryExpression, short: boolean) {
        throw new Error("Method unparseBinaryExpression should be implemented by its (concrete) subclasses.");
    }
    /**
     * The abstract concept 'AttributeRef' is not unparsed.
     */
    private unparseAttributeRef(modelelement: AttributeRef, short: boolean) {
        throw new Error("Method unparseAttributeRef should be implemented by its (concrete) subclasses.");
    }
    /**
     * The abstract concept 'DocuType' is not unparsed.
     */
    private unparseDocuType(modelelement: DocuType, short: boolean) {
        throw new Error("Method unparseDocuType should be implemented by its (concrete) subclasses.");
    }
    /**
     * The interface 'NamedType' is not unparsed.
     */
    private unparseNamedType(modelelement: FreNode, short: boolean) {
        throw new Error("Method unparseNamedType should be implemented by the classes that implement it.");
    }

    /**
     *
     */
    private _unparseReference(modelelement: FreNodeReference<FreNamedNode>, short: boolean) {
        if (!!modelelement) {
            const type: FreNamedNode = modelelement?.referred;
            if (!!type) {
                if (type instanceof GenericKind) {
                    this.unparseGenericKind(type, short);
                } else if (type instanceof InsurancePartType) {
                    this.unparseInsurancePartType(type, short);
                } else if (type instanceof PercentageType) {
                    this.unparsePercentageType(type, short);
                } else if (type instanceof NumberType) {
                    this.unparseNumberType(type, short);
                } else if (type instanceof BooleanType) {
                    this.unparseBooleanType(type, short);
                } else if (type instanceof EuroType) {
                    this.unparseEuroType(type, short);
                } else if (type instanceof InsuranceTheme) {
                    this.unparseInsuranceTheme(type, short);
                } else if (type instanceof PremiumDays) {
                    this.unparsePremiumDays(type, short);
                } else {
                    this.output[this.currentLine] += modelelement.pathnameToString(":") + " ";
                }
            } else {
                this.output[this.currentLine] += modelelement.pathnameToString(":") + " ";
            }
        }
    }

    /**
     * Adds a string representation of 'list' to the 'output', using 'sepText' , and 'sepType' to include either a separator string
     * or a terminator string. Param 'vertical' indicates whether the list should be represented vertically or horizontally.
     * If 'short' is false, then a multi-line result will be given. Otherwise, only one single-line string is added.
     * @param list
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     * @param method
     * @private
     */
    private _unparseList(
        list: FreNode[],
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean,
        method: (modelelement: FreNode, short: boolean) => void,
    ) {
        list.forEach((listElem, index) => {
            const isLastInList: boolean = index === list.length - 1;
            this.doInitiator(sepText, sepType);
            method(listElem, short);
            this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
        });
    }

    /**
     * Adds a string representation of a list of references, where every reference
     * is replaced by the name of its referred element. The use of params
     * 'sepText' and 'SepType' are equals to those in the private method _unparseList.
     * @param list
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     */
    private _unparseReferenceList(
        list: FreNodeReference<FreNamedNode>[],
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean,
    ) {
        list.forEach((listElem, index) => {
            const isLastInList: boolean = index === list.length - 1;
            this.doInitiator(sepText, sepType);
            this._unparseReference(listElem, short);
            this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
        });
    }

    /**
     * Adds a string representation of 'list' to the 'output', using 'sepText' , and 'sepType' to include either a separator string
     * or a terminator string. Param 'vertical' indicates whether the list should be represented vertically or horizontally.
     * If 'short' is false, then a multi-line result will be given. Otherwise, only one single-line string is added.
     * @param list
     * @param isIdentifier indicates whether the value should be surrounded with double quotes
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     */
    private _unparseListOfPrimitiveValues(
        list: (string | number | boolean)[],
        isIdentifier: boolean,
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean,
    ) {
        if (!!list) {
            list.forEach((listElem, index) => {
                const isLastInList: boolean = index === list.length - 1;
                if (typeof listElem === "string" && !isIdentifier) {
                    this.output[this.currentLine] += `"${listElem}"`;
                } else {
                    this.output[this.currentLine] += `${listElem}`;
                }
                this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
            });
        }
    }

    /**
     * Adds a separator, terminator, or initiator text (followed or preceded by a newline and the right amount of indentation)
     * to the output, depending on the parameters.
     * @param sepType
     * @param isLastInList
     * @param sepText
     * @param vertical
     * @param short
     * @param indent
     */
    // tslint:disable-next-line:max-line-length
    private doSeparatorOrTerminatorAndNewline(
        sepType: SeparatorType,
        isLastInList: boolean,
        sepText: string,
        vertical: boolean,
        short: boolean,
        indent: number,
    ) {
        // first eliminate any whitespace at the end of the line
        this.output[this.currentLine] = this.output[this.currentLine].trimEnd();

        if (!vertical && (!sepText || sepText.length == 0)) {
            // at least separate the items by a space to avoid things
            // like "IntegerFunction", which should be "Integer Function"
            sepText = " ";
        }

        // then add the right separator or terminator
        switch (sepType) {
            case SeparatorType.Separator: {
                if (!isLastInList) {
                    this.output[this.currentLine] += sepText;
                }
                break;
            }
            case SeparatorType.Terminator: {
                this.output[this.currentLine] += sepText;
                break;
            }
            case SeparatorType.Initiator: {
                break;
            }
            case SeparatorType.NONE: {
                if (!vertical) {
                    // at least separate the items by a space to avoid things
                    // like "IntegerFunction", which should be "Integer Function"
                    this.output[this.currentLine] += " ";
                }
                break;
            }
        }

        // then add newline and indentation
        if (vertical && !isLastInList) {
            if (!short) {
                this.newlineAndIndentation(indent);
            } else {
                // stop after 1 line
                // note that the following cannot be parsed
                this.output[this.currentLine] += ` ...`;
            }
        } else if (isLastInList) {
            // end with a space to avoid things
            // like "666after", which should be "666 after"
            if (this.output[this.currentLine][this.output[this.currentLine].length - 1] !== " ") {
                this.output[this.currentLine] += ` `;
            }
        }
    }

    /**
     * Makes a new entry in the 'output' array
     * and adds the indentation of 'number' spaces
     * to the new entry/line.
     * @param indent
     */
    private newlineAndIndentation(indent: number) {
        this.currentLine += 1;
        let indentation: string = "";
        for (let _i = 0; _i < indent; _i++) {
            indentation += " ";
        }
        this.output[this.currentLine] = indentation;
    }

    /**
     * Adds the 'initiator' text
     * @param sepText
     * @param sepType
     * @private
     */
    private doInitiator(sepText: string, sepType: SeparatorType) {
        if (sepType === SeparatorType.Initiator) {
            this.output[this.currentLine] += sepText;
        }
    }
}
