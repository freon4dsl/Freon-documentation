// Generated by the Freon Language Generator.
// import { FreNode } from "../../language/gen/index.js";
import {
    UnitOfMeasurement,
    GenericType,
    PlusExp,
    NamedExp,
    GenericLiteral,
    UnitLiteral,
    BooleanLiteral,
    StringLiteral,
    NumberLiteral,
    PredefinedType,
    TypeDecl,
    TypeRef,
    Exp,
    UnitKind,
    GenericKind,
    NamedType,
    TypeUsage,
    ExpWithType,
    XXunit,
    XX,
} from "../../language/gen/index.js";
import { XXWorker } from "./XXWorker.js";
import { FreLogger, FreNode } from "@freon4dsl/core";

const LOGGER = new FreLogger("XXWalker");

/**
 * Class XXWalker implements the extended visitor pattern of instances of language XX.
 * This class implements the traversal of the model tree, classes that implement XXWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class XXWalker {
    myWorkers: XXWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: FreNode, includeChildren?: (elem: FreNode) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof UnitOfMeasurement) {
                return this.walkUnitOfMeasurement(modelelement, includeChildren);
            }
            if (modelelement instanceof GenericType) {
                return this.walkGenericType(modelelement, includeChildren);
            }
            if (modelelement instanceof PlusExp) {
                return this.walkPlusExp(modelelement, includeChildren);
            }
            if (modelelement instanceof NamedExp) {
                return this.walkNamedExp(modelelement, includeChildren);
            }
            if (modelelement instanceof GenericLiteral) {
                return this.walkGenericLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof UnitLiteral) {
                return this.walkUnitLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof BooleanLiteral) {
                return this.walkBooleanLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof StringLiteral) {
                return this.walkStringLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof NumberLiteral) {
                return this.walkNumberLiteral(modelelement, includeChildren);
            }
            if (modelelement instanceof PredefinedType) {
                return this.walkPredefinedType(modelelement, includeChildren);
            }
            if (modelelement instanceof TypeDecl) {
                return this.walkTypeDecl(modelelement, includeChildren);
            }
            if (modelelement instanceof TypeRef) {
                return this.walkTypeRef(modelelement, includeChildren);
            }
            if (modelelement instanceof Exp) {
                return this.walkExp(modelelement, includeChildren);
            }
            if (modelelement instanceof UnitKind) {
                return this.walkUnitKind(modelelement, includeChildren);
            }
            if (modelelement instanceof GenericKind) {
                return this.walkGenericKind(modelelement, includeChildren);
            }
            if (modelelement instanceof NamedType) {
                return this.walkNamedType(modelelement, includeChildren);
            }
            if (modelelement instanceof TypeUsage) {
                return this.walkTypeUsage(modelelement, includeChildren);
            }
            if (modelelement instanceof ExpWithType) {
                return this.walkExpWithType(modelelement, includeChildren);
            }
            if (modelelement instanceof XXunit) {
                return this.walkXXunit(modelelement, includeChildren);
            }
            if (modelelement instanceof XX) {
                return this.walkXX(modelelement, includeChildren);
            }
        } else {
            LOGGER.error("No worker found.");
        }
    }

    private walkUnitOfMeasurement(modelelement: UnitOfMeasurement, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeUnitOfMeasurement(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterUnitOfMeasurement(modelelement);
            }
        }
    }

    private walkGenericType(modelelement: GenericType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGenericType(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.baseType)) {
            this.walk(modelelement.baseType, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGenericType(modelelement);
            }
        }
    }

    private walkPlusExp(modelelement: PlusExp, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePlusExp(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPlusExp(modelelement);
            }
        }
    }

    private walkNamedExp(modelelement: NamedExp, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNamedExp(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.inner)) {
            this.walk(modelelement.inner, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.myType)) {
            this.walk(modelelement.myType, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNamedExp(modelelement);
            }
        }
    }

    private walkGenericLiteral(modelelement: GenericLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGenericLiteral(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.content.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGenericLiteral(modelelement);
            }
        }
    }

    private walkUnitLiteral(modelelement: UnitLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeUnitLiteral(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.inner)) {
            this.walk(modelelement.inner, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterUnitLiteral(modelelement);
            }
        }
    }

    private walkBooleanLiteral(modelelement: BooleanLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBooleanLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBooleanLiteral(modelelement);
            }
        }
    }

    private walkStringLiteral(modelelement: StringLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeStringLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterStringLiteral(modelelement);
            }
        }
    }

    private walkNumberLiteral(modelelement: NumberLiteral, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNumberLiteral(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNumberLiteral(modelelement);
            }
        }
    }

    private walkPredefinedType(modelelement: PredefinedType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePredefinedType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPredefinedType(modelelement);
            }
        }
    }

    private walkTypeDecl(modelelement: TypeDecl, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTypeDecl(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTypeDecl(modelelement);
            }
        }
    }

    private walkTypeRef(modelelement: TypeRef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTypeRef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTypeRef(modelelement);
            }
        }
    }

    private walkExp(modelelement: Exp, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeExp(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterExp(modelelement);
            }
        }
    }

    private walkUnitKind(modelelement: UnitKind, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeUnitKind(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterUnitKind(modelelement);
            }
        }
    }

    private walkGenericKind(modelelement: GenericKind, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGenericKind(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGenericKind(modelelement);
            }
        }
    }

    private walkNamedType(modelelement: NamedType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNamedType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNamedType(modelelement);
            }
        }
    }

    private walkTypeUsage(modelelement: TypeUsage, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTypeUsage(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTypeUsage(modelelement);
            }
        }
    }

    private walkExpWithType(modelelement: ExpWithType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeExpWithType(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.expr)) {
            this.walk(modelelement.expr, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.type)) {
            this.walk(modelelement.type, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterExpWithType(modelelement);
            }
        }
    }

    private walkXXunit(modelelement: XXunit, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeXXunit(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.lines.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterXXunit(modelelement);
            }
        }
    }

    private walkXX(modelelement: XX, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeXX(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.units.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterXX(modelelement);
            }
        }
    }
}
