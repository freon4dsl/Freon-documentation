// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreWriter, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    XX,
    XXunit,
    ExpWithType,
    TypeRef,
    NamedType,
    PredefinedType,
    GenericType,
    GenericKind,
    UnitOfMeasurement,
    UnitKind,
    NumberLiteral,
    StringLiteral,
    BooleanLiteral,
    UnitLiteral,
    GenericLiteral,
    NamedExp,
    PlusExp,
} from "../../language/gen/index.js";
import { XXDefaultWorker } from "../../utils/gen/index.js";
import { XXCheckerInterface } from "./XXValidator.js";

/**
 * Class XXNonOptionalsChecker is part of the implementation of the default validator.
 * It checks whether non-optional properties, as such defined in the .ast definition, indeed
 * have a value.
 * Class XXWalker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class XXNonOptionalsChecker extends XXDefaultWorker implements XXCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeXX(modelelement: XX): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeXXunit(modelelement: XXunit): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeExpWithType(modelelement: ExpWithType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.expr === null || modelelement.expr === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'expr' must have a value", modelelement, "unnamed", "expr", FreErrorSeverity.Error));
        }
        if (modelelement.type === null || modelelement.type === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'type' must have a value", modelelement, "unnamed", "type", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeTypeRef(modelelement: TypeRef): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.type === null || modelelement.type === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'type' must have a value", modelelement, "unnamed", "type", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeNamedType(modelelement: NamedType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePredefinedType(modelelement: PredefinedType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGenericType(modelelement: GenericType): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.baseType === null || modelelement.baseType === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'baseType' must have a value", modelelement, "unnamed", "baseType", FreErrorSeverity.Error)
            );
        }
        if (modelelement.kind === null || modelelement.kind === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'kind' must have a value", modelelement, "unnamed", "kind", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGenericKind(modelelement: GenericKind): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeUnitOfMeasurement(modelelement: UnitOfMeasurement): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.baseType === null || modelelement.baseType === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'baseType' must have a value", modelelement, "unnamed", "baseType", FreErrorSeverity.Error)
            );
        }
        if (modelelement.unit === null || modelelement.unit === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'unit' must have a value", modelelement, "unnamed", "unit", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeUnitKind(modelelement: UnitKind): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.name === null || modelelement.name === undefined || modelelement.name?.length === 0) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'name' must have a value", modelelement, modelelement.name, "name", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeNumberLiteral(modelelement: NumberLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.xx === null || modelelement.xx === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'xx' must have a value", modelelement, "unnamed", "xx", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeStringLiteral(modelelement: StringLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.xx === null || modelelement.xx === undefined || modelelement.xx?.length === 0) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'xx' must have a value", modelelement, "unnamed", "xx", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeBooleanLiteral(modelelement: BooleanLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.xx === null || modelelement.xx === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'xx' must have a value", modelelement, "unnamed", "xx", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeUnitLiteral(modelelement: UnitLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.inner === null || modelelement.inner === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'inner' must have a value", modelelement, "unnamed", "inner", FreErrorSeverity.Error)
            );
        }
        if (modelelement.unit === null || modelelement.unit === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'unit' must have a value", modelelement, "unnamed", "unit", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeGenericLiteral(modelelement: GenericLiteral): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.kind === null || modelelement.kind === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'kind' must have a value", modelelement, "unnamed", "kind", FreErrorSeverity.Error));
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforeNamedExp(modelelement: NamedExp): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.inner === null || modelelement.inner === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'inner' must have a value", modelelement, "unnamed", "inner", FreErrorSeverity.Error)
            );
        }
        if (modelelement.myType === null || modelelement.myType === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'myType' must have a value", modelelement, "unnamed", "myType", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * If an error is found, it is considered 'fatal', which means that no other checks on
     * 'modelelement' are performed.
     *
     * @param modelelement
     */
    public execBeforePlusExp(modelelement: PlusExp): boolean {
        let hasFatalError: boolean = false;
        if (modelelement.left === null || modelelement.left === undefined) {
            hasFatalError = true;
            this.errorList.push(new FreError("Property 'left' must have a value", modelelement, "unnamed", "left", FreErrorSeverity.Error));
        }
        if (modelelement.right === null || modelelement.right === undefined) {
            hasFatalError = true;
            this.errorList.push(
                new FreError("Property 'right' must have a value", modelelement, "unnamed", "right", FreErrorSeverity.Error)
            );
        }

        return hasFatalError;
    }
}
