// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    Entity,
    AttributeWithLimitedType,
    AttributeWithEntityType,
    EntityFunction,
    AbsExpression,
    AttributeRef,
    VariableRef,
    StringLiteralExpression,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    FunctionCallExpression,
    IfExpression,
    Variable,
    AttributeType,
    EntityExpression,
    Type,
    AppliedFeature,
    LiteralExpression,
    MultiplyExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
} from "../../language/gen/index.js";
import { EntityModelSyntaxAnalyser } from "./EntityModelSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class EntityModelCommonSyntaxAnalyserPart {
    mainAnalyser: EntityModelSyntaxAnalyser;

    constructor(mainAnalyser: EntityModelSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Entity = 'Entity' identifier '\{'
     *	 'isCompany' booleanLiteral
     *	 'baseInterface_attr' numberLiteral
     *	 'simpleprop' stringLiteral
     *	 'attributes'
     *	 AttributeWithLimitedType*
     *	 'entAttributes'
     *	 AttributeWithEntityType*
     *	 'functions'
     *	 EntityFunction*
     *	 'int_attrs'
     *	 AttributeWithLimitedType*
     *	 'int_functions'
     *	 EntityFunction*
     *	 ( 'baseEntity' __fre_reference )?
     *	 'baseInterface' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformEntity(branch: SPPTBranch): Entity {
        // console.log('transformEntity called: ' + branch.name);
        let __name: string;
        let __isCompany: boolean;
        let __baseInterface_attr: number;
        let __simpleprop: string;
        let __attributes: AttributeWithLimitedType[];
        let __entAttributes: AttributeWithEntityType[];
        let __functions: EntityFunction[];
        let __int_attrs: AttributeWithLimitedType[];
        let __int_functions: EntityFunction[];
        let __baseEntity: FreNodeReference<Entity>;
        let __baseInterface: FreNodeReference<Entity>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __isCompany = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        __baseInterface_attr = this.mainAnalyser.transformSharedPackedParseTreeNode(children[6]); // RHSPrimEntry
        __simpleprop = this.mainAnalyser.transformSharedPackedParseTreeNode(children[8]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[10].name !== "AttributeWithLimitedType") {
            __attributes = this.mainAnalyser.transformSharedPackedParseTreeList<AttributeWithLimitedType>(children[10]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __attributes = [];
            for (const child of children) {
                __attributes.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[12].name !== "AttributeWithEntityType") {
            __entAttributes = this.mainAnalyser.transformSharedPackedParseTreeList<AttributeWithEntityType>(children[12]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __entAttributes = [];
            for (const child of children) {
                __entAttributes.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[14].name !== "EntityFunction") {
            __functions = this.mainAnalyser.transformSharedPackedParseTreeList<EntityFunction>(children[14]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __functions = [];
            for (const child of children) {
                __functions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[16].name !== "AttributeWithLimitedType") {
            __int_attrs = this.mainAnalyser.transformSharedPackedParseTreeList<AttributeWithLimitedType>(children[16]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __int_attrs = [];
            for (const child of children) {
                __int_attrs.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[18].name !== "EntityFunction") {
            __int_functions = this.mainAnalyser.transformSharedPackedParseTreeList<EntityFunction>(children[18]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __int_functions = [];
            for (const child of children) {
                __int_functions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        if (!children[19].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[19]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __baseEntity = this.mainAnalyser.freNodeRef<Entity>(_propItem[1], "Entity"); // RHSRefEntry
        }
        __baseInterface = this.mainAnalyser.freNodeRef<Entity>(children[21], "Entity"); // RHSRefEntry

        return Entity.create({
            name: __name,
            isCompany: __isCompany,
            baseInterface_attr: __baseInterface_attr,
            simpleprop: __simpleprop,
            attributes: __attributes,
            entAttributes: __entAttributes,
            functions: __functions,
            int_attrs: __int_attrs,
            int_functions: __int_functions,
            baseEntity: __baseEntity,
            baseInterface: __baseInterface,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * AttributeWithLimitedType = 'AttributeWithLimitedType' identifier '\{'
     *	 'declaredType' AttributeType
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformAttributeWithLimitedType(branch: SPPTBranch): AttributeWithLimitedType {
        // console.log('transformAttributeWithLimitedType called: ' + branch.name);
        let __name: string;
        let __declaredType: FreNodeReference<AttributeType>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __declaredType = this.mainAnalyser.freNodeRef<AttributeType>(children[4], "AttributeType"); // RHSLimitedRefEntry

        return AttributeWithLimitedType.create({
            name: __name,
            declaredType: __declaredType,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * AttributeWithEntityType = 'AttributeWithEntityType' identifier '\{'
     *	 'declaredType' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformAttributeWithEntityType(branch: SPPTBranch): AttributeWithEntityType {
        // console.log('transformAttributeWithEntityType called: ' + branch.name);
        let __name: string;
        let __declaredType: FreNodeReference<Entity>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __declaredType = this.mainAnalyser.freNodeRef<Entity>(children[4], "Entity"); // RHSRefEntry

        return AttributeWithEntityType.create({
            name: __name,
            declaredType: __declaredType,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * EntityFunction = 'EntityFunction' identifier '\{'
     *	 'aliases'
     *	 stringLiteral*
     *	 'expression' EntityExpression
     *	 'parameters'
     *	 Variable*
     *	 'declaredType' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformEntityFunction(branch: SPPTBranch): EntityFunction {
        // console.log('transformEntityFunction called: ' + branch.name);
        let __name: string;
        let __aliases: string[];
        let __expression: EntityExpression;
        let __parameters: Variable[];
        let __declaredType: FreNodeReference<Type>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __aliases = this.mainAnalyser.transformSharedPackedParseTreeList<string>(children[4]); // RHSPrimListEntry
        __expression = this.mainAnalyser.transformSharedPackedParseTreeNode(children[6]); // RHSPartEntry
        // RHSPartListEntry
        if (children[8].name !== "Variable") {
            __parameters = this.mainAnalyser.transformSharedPackedParseTreeList<Variable>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __parameters = [];
            for (const child of children) {
                __parameters.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        __declaredType = this.mainAnalyser.freNodeRef<Type>(children[10], "Type"); // RHSRefEntry

        return EntityFunction.create({
            name: __name,
            aliases: __aliases,
            expression: __expression,
            parameters: __parameters,
            declaredType: __declaredType,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * AbsExpression = 'AbsExpression' '\{'
     *	 'expr' EntityExpression
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformAbsExpression(branch: SPPTBranch): AbsExpression {
        // console.log('transformAbsExpression called: ' + branch.name);
        let __expr: EntityExpression;
        let __appliedfeature: AppliedFeature;
        const children = this.mainAnalyser.getChildren(branch);
        __expr = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPartEntry

        if (!children[4].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[4]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        return AbsExpression.create({
            expr: __expr,
            appliedfeature: __appliedfeature,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * AttributeRef = 'AttributeRef' '\{'
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 'attribute' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformAttributeRef(branch: SPPTBranch): AttributeRef {
        // console.log('transformAttributeRef called: ' + branch.name);
        let __appliedfeature: AppliedFeature;
        let __attribute: FreNodeReference<AttributeWithEntityType>;
        const children = this.mainAnalyser.getChildren(branch);
        if (!children[2].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[2]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        __attribute = this.mainAnalyser.freNodeRef<AttributeWithEntityType>(children[4], "AttributeWithEntityType"); // RHSRefEntry

        return AttributeRef.create({
            appliedfeature: __appliedfeature,
            attribute: __attribute,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * VariableRef = 'VariableRef' '\{'
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 'variable' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformVariableRef(branch: SPPTBranch): VariableRef {
        // console.log('transformVariableRef called: ' + branch.name);
        let __appliedfeature: AppliedFeature;
        let __variable: FreNodeReference<Variable>;
        const children = this.mainAnalyser.getChildren(branch);
        if (!children[2].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[2]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        __variable = this.mainAnalyser.freNodeRef<Variable>(children[4], "Variable"); // RHSRefEntry

        return VariableRef.create({
            appliedfeature: __appliedfeature,
            variable: __variable,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * StringLiteralExpression = 'StringLiteralExpression' '\{'
     *	 'value' stringLiteral
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformStringLiteralExpression(branch: SPPTBranch): StringLiteralExpression {
        // console.log('transformStringLiteralExpression called: ' + branch.name);
        let __value: string;
        let __appliedfeature: AppliedFeature;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry

        if (!children[4].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[4]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        return StringLiteralExpression.create({
            value: __value,
            appliedfeature: __appliedfeature,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * NumberLiteralExpression = 'NumberLiteralExpression' '\{'
     *	 'value' stringLiteral
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformNumberLiteralExpression(branch: SPPTBranch): NumberLiteralExpression {
        // console.log('transformNumberLiteralExpression called: ' + branch.name);
        let __value: string;
        let __appliedfeature: AppliedFeature;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry

        if (!children[4].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[4]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        return NumberLiteralExpression.create({
            value: __value,
            appliedfeature: __appliedfeature,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * BooleanLiteralExpression = 'BooleanLiteralExpression' '\{'
     *	 'value' stringLiteral
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformBooleanLiteralExpression(branch: SPPTBranch): BooleanLiteralExpression {
        // console.log('transformBooleanLiteralExpression called: ' + branch.name);
        let __value: string;
        let __appliedfeature: AppliedFeature;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry

        if (!children[4].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[4]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        return BooleanLiteralExpression.create({
            value: __value,
            appliedfeature: __appliedfeature,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FunctionCallExpression = 'FunctionCallExpression' '\{'
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 'functionDefinition' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFunctionCallExpression(branch: SPPTBranch): FunctionCallExpression {
        // console.log('transformFunctionCallExpression called: ' + branch.name);
        let __appliedfeature: AppliedFeature;
        let __functionDefinition: FreNodeReference<EntityFunction>;
        const children = this.mainAnalyser.getChildren(branch);
        if (!children[2].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[2]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        __functionDefinition = this.mainAnalyser.freNodeRef<EntityFunction>(children[4], "EntityFunction"); // RHSRefEntry

        return FunctionCallExpression.create({
            appliedfeature: __appliedfeature,
            functionDefinition: __functionDefinition,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * IfExpression = 'IfExpression' '\{'
     *	 'condition' EntityExpression
     *	 'whenTrue' EntityExpression
     *	 'whenFalse' EntityExpression
     *	 ( 'appliedfeature' AppliedFeature )?
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformIfExpression(branch: SPPTBranch): IfExpression {
        // console.log('transformIfExpression called: ' + branch.name);
        let __condition: EntityExpression;
        let __whenTrue: EntityExpression;
        let __whenFalse: EntityExpression;
        let __appliedfeature: AppliedFeature;
        const children = this.mainAnalyser.getChildren(branch);
        __condition = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPartEntry
        __whenTrue = this.mainAnalyser.transformSharedPackedParseTreeNode(children[5]); // RHSPartEntry
        __whenFalse = this.mainAnalyser.transformSharedPackedParseTreeNode(children[7]); // RHSPartEntry

        if (!children[8].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[8]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __appliedfeature = this.mainAnalyser.transformSharedPackedParseTreeNode(_propItem[1]); // RHSPartEntry
        }
        return IfExpression.create({
            condition: __condition,
            whenTrue: __whenTrue,
            whenFalse: __whenFalse,
            appliedfeature: __appliedfeature,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Variable = 'Variable' identifier '\{'
     *	 'declaredType' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformVariable(branch: SPPTBranch): Variable {
        // console.log('transformVariable called: ' + branch.name);
        let __name: string;
        let __declaredType: FreNodeReference<Entity>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __declaredType = this.mainAnalyser.freNodeRef<Entity>(children[4], "Entity"); // RHSRefEntry

        return Variable.create({
            name: __name,
            declaredType: __declaredType,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * EntityExpression = AbsExpression
     *    | VariableRef
     *    | LiteralExpression
     *    | FunctionCallExpression
     *    | IfExpression
     *    | __fre_binary_EntityExpression ;
     * @param branch
     * @private
     */
    public transformEntityExpression(branch: SPPTBranch): EntityExpression {
        // console.log('transformEntityExpression called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * AppliedFeature = AttributeRef  ;
     * @param branch
     * @private
     */
    public transformAppliedFeature(branch: SPPTBranch): AppliedFeature {
        // console.log('transformAppliedFeature called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * LiteralExpression = StringLiteralExpression
     *    | NumberLiteralExpression
     *    | BooleanLiteralExpression  ;
     * @param branch
     * @private
     */
    public transformLiteralExpression(branch: SPPTBranch): LiteralExpression {
        // console.log('transformLiteralExpression called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Generic method to transform binary expressions, which are parsed
     * according to these rules:
     * __fre_binary_EntityExpression = [EntityExpression / __fre_binary_operator]2+ ;
     * leaf __fre_binary_operator = 'GreaterThenExpression' | 'EqualsExpression' | 'AndExpression' | 'or' | '*' | '+' | '/' | '<' ;
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     * @param branch
     * @private
     */
    public transform__fre_binary_EntityExpression(branch: SPPTBranch): EntityExpression {
        // console.log('transform__fre_binary_EntityExpression called: ' + branch.name);
        const children = branch.nonSkipChildren.toArray();
        let index = 0;
        let first = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
        while (index < children.length) {
            let operator = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let second = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let combined: EntityExpression = null;
            switch (operator) {
                case "*": {
                    combined = MultiplyExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "+": {
                    combined = PlusExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "/": {
                    combined = DivideExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "AndExpression": {
                    combined = AndExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "or": {
                    combined = OrExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "<": {
                    combined = LessThenExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                case "GreaterThenExpression": {
                    combined = GreaterThenExpression.create({
                        left: first,
                        right: second,
                        parseLocation: this.mainAnalyser.location(branch),
                    });
                    break;
                }
                case "EqualsExpression": {
                    combined = EqualsExpression.create({ left: first, right: second, parseLocation: this.mainAnalyser.location(branch) });
                    break;
                }
                default: {
                    combined = null;
                }
            }
            first = combined;
        }
        return first;
    }

    /**
     * Method to transform branches that match the following rule:
     * AttributeType = 'String'
     *	| 'Integer'
     *	| 'Boolean'
     *	| 'ANY' ;
     * @param branch
     * @private
     */
    public transformAttributeType(branch: SPPTBranch): AttributeType {
        const choice = branch.nonSkipMatchedText;
        if (choice === "String") {
            return AttributeType.String;
        } else if (choice === "Integer") {
            return AttributeType.Integer;
        } else if (choice === "Boolean") {
            return AttributeType.Boolean;
        } else if (choice === "ANY") {
            return AttributeType.ANY;
        } else {
            return null;
        }
    }
}
