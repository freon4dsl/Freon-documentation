// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import { EntityModelUnit, EntityFunction, Entity } from "../../language/gen/index.js";
import { EntityModelSyntaxAnalyser } from "./EntityModelSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class EntityModelUnitSyntaxAnalyserPart {
    mainAnalyser: EntityModelSyntaxAnalyser;

    constructor(mainAnalyser: EntityModelSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * EntityModelUnit = 'EntityModelUnit' identifier '\{'
     *	 'functions'
     *	 EntityFunction*
     *	 'entities'
     *	 Entity*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformEntityModelUnit(branch: SPPTBranch): EntityModelUnit {
        // console.log('transformEntityModelUnit called: ' + branch.name);
        let __name: string;
        let __functions: EntityFunction[];
        let __entities: Entity[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[4].name !== "EntityFunction") {
            __functions = this.mainAnalyser.transformSharedPackedParseTreeList<EntityFunction>(children[4]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __functions = [];
            for (const child of children) {
                __functions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[6].name !== "Entity") {
            __entities = this.mainAnalyser.transformSharedPackedParseTreeList<Entity>(children[6]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __entities = [];
            for (const child of children) {
                __entities.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return EntityModelUnit.create({
            name: __name,
            functions: __functions,
            entities: __entities,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }
}
