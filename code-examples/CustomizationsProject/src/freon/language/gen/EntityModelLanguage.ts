// Generated by the Freon Language Generator.
// Generated by Freon LanguageTemplate
import {
    FreLanguage,
    FreLanguageModel,
    FreLanguageModelUnit,
    FreLanguageProperty,
    FreLanguageConcept,
    FreLanguageInterface,
    FreNodeReference,
} from "@freon4dsl/core";

// Import as MyLanguage to avoid naming conflicts in generated constructors
import * as MyLanguage from "./internal.js";
import { EntityModelStdlib } from "../../stdlib/gen/EntityModelStdlib.js";

/**
 * Creates an in-memory representation of structure of the language metamodel, used in e.g. the (de)serializer.
 */
export function initializeLanguage() {
    FreLanguage.getInstance().name = "EntityModel";
    FreLanguage.getInstance().id = "";
    FreLanguage.getInstance().addModel(describeEntityModel());
    FreLanguage.getInstance().addUnit(describeSomeOtherModelUnit());
    FreLanguage.getInstance().addUnit(describeEntityModelUnit());
    FreLanguage.getInstance().addConcept(describeEntity());
    FreLanguage.getInstance().addConcept(describeAttributeType());
    FreLanguage.getInstance().addConcept(describeMockEnumeration());
    FreLanguage.getInstance().addConcept(describeAbsExpression());
    FreLanguage.getInstance().addConcept(describeMultiplyExpression());
    FreLanguage.getInstance().addConcept(describeEntityFunction());
    FreLanguage.getInstance().addConcept(describeAttributeWithLimitedType());
    FreLanguage.getInstance().addConcept(describeText());
    FreLanguage.getInstance().addConcept(describeText2());
    FreLanguage.getInstance().addConcept(describeText3());
    FreLanguage.getInstance().addConcept(describeText4());
    FreLanguage.getInstance().addConcept(describeAttributeWithEntityType());
    FreLanguage.getInstance().addConcept(describeVariable());
    FreLanguage.getInstance().addConcept(describeEntityExpression());
    FreLanguage.getInstance().addConcept(describeAppliedFeature());
    FreLanguage.getInstance().addConcept(describeAttributeRef());
    FreLanguage.getInstance().addConcept(describeVariableRef());
    FreLanguage.getInstance().addConcept(describeLiteralExpression());
    FreLanguage.getInstance().addConcept(describeStringLiteralExpression());
    FreLanguage.getInstance().addConcept(describeNumberLiteralExpression());
    FreLanguage.getInstance().addConcept(describeBooleanLiteralExpression());
    FreLanguage.getInstance().addConcept(describeBinaryExpression());
    FreLanguage.getInstance().addConcept(describePlusExpression());
    FreLanguage.getInstance().addConcept(describeDivideExpression());
    FreLanguage.getInstance().addConcept(describeAndExpression());
    FreLanguage.getInstance().addConcept(describeOrExpression());
    FreLanguage.getInstance().addConcept(describeComparisonExpression());
    FreLanguage.getInstance().addConcept(describeLessThenExpression());
    FreLanguage.getInstance().addConcept(describeGreaterThenExpression());
    FreLanguage.getInstance().addConcept(describeEqualsExpression());
    FreLanguage.getInstance().addConcept(describeFunctionCallExpression());
    FreLanguage.getInstance().addConcept(describeIfExpression());
    FreLanguage.getInstance().addInterface(describeBaseType());
    FreLanguage.getInstance().addInterface(describeType());
    FreLanguage.getInstance().addReferenceCreator((name: string, type: string) => {
        return !!name ? FreNodeReference.create(name, type) : null;
    });
    FreLanguage.getInstance().stdLib = EntityModelStdlib.getInstance();
}

function describeEntityModel(): FreLanguageModel {
    const model: FreLanguageModel = {
        typeName: "EntityModel",
        id: "-id-EntityModel",
        key: "-key-EntityModel",
        isNamespace: true,
        language: "-key-Entity",
        constructor: (id?: string) => {
            return new MyLanguage.EntityModel(id);
        },
        creator: (data: Partial<MyLanguage.EntityModel>) => {
            return MyLanguage.EntityModel.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
    };
    model.properties.set("name", {
        name: "name",
        id: "-id-EntityModel-name",
        key: "-key-EntityModel-name",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    model.properties.set("units", {
        name: "units",
        id: "-id-EntityModel-units",
        key: "-key-EntityModel-units",
        type: "EntityModelUnit",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    model.properties.set("extraUnit", {
        name: "extraUnit",
        id: "-id-EntityModel-extraUnit",
        key: "-key-EntityModel-extraUnit",
        type: "SomeOtherModelUnit",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return model;
}

function describeSomeOtherModelUnit(): FreLanguageModelUnit {
    const modelunit: FreLanguageModelUnit = {
        typeName: "SomeOtherModelUnit",
        id: "-id-SomeOtherModelUnit",
        key: "-key-SomeOtherModelUnit",
        isNamedElement: true,
        language: "-key-Entity",
        fileExtension: "som",
        subConceptNames: [], // Nothing yet, but may change in the future
        constructor: (id?: string) => {
            return new MyLanguage.SomeOtherModelUnit(id);
        },
        creator: (data: Partial<MyLanguage.SomeOtherModelUnit>) => {
            return MyLanguage.SomeOtherModelUnit.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        trigger: "SomeOtherModelUnit",
    };
    modelunit.properties.set("name", {
        name: "name",
        id: "-id-SomeOtherModelUnit-name",
        key: "-key-SomeOtherModelUnit-name",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    modelunit.properties.set("somePart", {
        name: "somePart",
        id: "-id-SomeOtherModelUnit-somePart",
        key: "-key-SomeOtherModelUnit-somePart",
        type: "Entity",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return modelunit;
}

function describeEntityModelUnit(): FreLanguageModelUnit {
    const modelunit: FreLanguageModelUnit = {
        typeName: "EntityModelUnit",
        id: "-id-EntityModelUnit",
        key: "-key-EntityModelUnit",
        isNamedElement: true,
        language: "-key-Entity",
        fileExtension: "ent",
        subConceptNames: [], // Nothing yet, but may change in the future
        constructor: (id?: string) => {
            return new MyLanguage.EntityModelUnit(id);
        },
        creator: (data: Partial<MyLanguage.EntityModelUnit>) => {
            return MyLanguage.EntityModelUnit.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        trigger: "EntityModelUnit",
    };
    modelunit.properties.set("name", {
        name: "name",
        id: "-id-EntityModelUnit-name",
        key: "-key-EntityModelUnit-name",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    modelunit.properties.set("functions", {
        name: "functions",
        id: "-id-EntityModelUnit-functions",
        key: "-key-EntityModelUnit-functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    modelunit.properties.set("entities", {
        name: "entities",
        id: "-id-EntityModelUnit-entities",
        key: "-key-EntityModelUnit-entities",
        type: "Entity",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return modelunit;
}

function describeEntity(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Entity",
        id: "-id-Entity",
        key: "-key-Entity",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: true,
        trigger: "Entity",
        constructor: (id?: string) => {
            return new MyLanguage.Entity(id);
        },
        creator: (data: Partial<MyLanguage.Entity>) => {
            return MyLanguage.Entity.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("isCompany", {
        name: "isCompany",
        id: "-id-Entity-isCompany",
        key: "-key-Entity-isCompany",
        type: "boolean",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("name", {
        name: "name",
        id: "-id-BaseType-name",
        key: "-key-BaseType-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        id: "-id-BaseType-baseInterface_attr",
        key: "-key-BaseType-baseInterface_attr",
        type: "number",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("simpleprop", {
        name: "simpleprop",
        id: "-id-Type-simpleprop",
        key: "-key-Type-simpleprop",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("attributes", {
        name: "attributes",
        id: "-id-Entity-attributes",
        key: "-key-Entity-attributes",
        type: "AttributeWithLimitedType",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("entAttributes", {
        name: "entAttributes",
        id: "-id-Entity-entAttributes",
        key: "-key-Entity-entAttributes",
        type: "AttributeWithEntityType",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("functions", {
        name: "functions",
        id: "-id-Entity-functions",
        key: "-key-Entity-functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("int_attrs", {
        name: "int_attrs",
        id: "-id-Type-int_attrs",
        key: "-key-Type-int_attrs",
        type: "AttributeWithLimitedType",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("int_functions", {
        name: "int_functions",
        id: "-id-Type-int_functions",
        key: "-key-Type-int_functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("baseEntity", {
        name: "baseEntity",
        id: "-id-Entity-baseEntity",
        key: "-key-Entity-baseEntity",
        type: "Entity",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    concept.properties.set("baseInterface", {
        name: "baseInterface",
        id: "-id-Type-baseInterface",
        key: "-key-Type-baseInterface",
        type: "Entity",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeAttributeType(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "AttributeType",
        id: "-id-AttributeType",
        key: "-key-AttributeType",
        isAbstract: false,
        isPublic: true,
        isLimited: true,
        instanceNames: ["String", "Integer", "Boolean", "ANY"],
        language: "-key-Entity",
        isNamedElement: true,
        trigger: "AttributeType",
        constructor: (id?: string) => {
            return new MyLanguage.AttributeType(id);
        },
        creator: (data: Partial<MyLanguage.AttributeType>) => {
            return MyLanguage.AttributeType.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-AttributeType-name",
        key: "-key-AttributeType-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("extra", {
        name: "extra",
        id: "-id-AttributeType-extra",
        key: "-key-AttributeType-extra",
        type: "number",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        id: "-id-BaseType-baseInterface_attr",
        key: "-key-BaseType-baseInterface_attr",
        type: "number",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });

    return concept;
}

function describeMockEnumeration(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "MockEnumeration",
        id: "-id-MockEnumeration",
        key: "-key-MockEnumeration",
        isAbstract: false,
        isPublic: true,
        isLimited: true,
        instanceNames: ["EnumValue1", "EnumValue2", "EnumValue3"],
        language: "-key-Entity",
        isNamedElement: true,
        trigger: "MockEnumeration",
        constructor: (id?: string) => {
            return new MyLanguage.MockEnumeration(id);
        },
        creator: (data: Partial<MyLanguage.MockEnumeration>) => {
            return MyLanguage.MockEnumeration.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-MockEnumeration-name",
        key: "-key-MockEnumeration-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });

    return concept;
}

function describeAbsExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "AbsExpression",
        id: "-id-AbsExpression",
        key: "-key-AbsExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "AbsExpression",
        constructor: (id?: string) => {
            return new MyLanguage.AbsExpression(id);
        },
        creator: (data: Partial<MyLanguage.AbsExpression>) => {
            return MyLanguage.AbsExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "EntityExpression",
        subConceptNames: [],
    };

    concept.properties.set("expr", {
        name: "expr",
        id: "-id-AbsExpression-expr",
        key: "-key-AbsExpression-expr",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeMultiplyExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "MultiplyExpression",
        id: "-id-MultiplyExpression",
        key: "-key-MultiplyExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "MultiplyExpression",
        constructor: (id?: string) => {
            return new MyLanguage.MultiplyExpression(id);
        },
        creator: (data: Partial<MyLanguage.MultiplyExpression>) => {
            return MyLanguage.MultiplyExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeEntityFunction(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "EntityFunction",
        id: "-id-EntityFunction",
        key: "-key-EntityFunction",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: true,
        trigger: "EntityFunction",
        constructor: (id?: string) => {
            return new MyLanguage.EntityFunction(id);
        },
        creator: (data: Partial<MyLanguage.EntityFunction>) => {
            return MyLanguage.EntityFunction.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-EntityFunction-name",
        key: "-key-EntityFunction-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("aliases", {
        name: "aliases",
        id: "-id-EntityFunction-aliases",
        key: "-key-EntityFunction-aliases",
        type: "string",
        isList: true,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("expression", {
        name: "expression",
        id: "-id-EntityFunction-expression",
        key: "-key-EntityFunction-expression",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("parameters", {
        name: "parameters",
        id: "-id-EntityFunction-parameters",
        key: "-key-EntityFunction-parameters",
        type: "Variable",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("declaredType", {
        name: "declaredType",
        id: "-id-EntityFunction-declaredType",
        key: "-key-EntityFunction-declaredType",
        type: "Type",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeAttributeWithLimitedType(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "AttributeWithLimitedType",
        id: "-id-AttributeWithLimitedType",
        key: "-key-AttributeWithLimitedType",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: true,
        trigger: "AttributeWithLimitedType",
        constructor: (id?: string) => {
            return new MyLanguage.AttributeWithLimitedType(id);
        },
        creator: (data: Partial<MyLanguage.AttributeWithLimitedType>) => {
            return MyLanguage.AttributeWithLimitedType.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-AttributeWithLimitedType-name",
        key: "-key-AttributeWithLimitedType-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });

    concept.properties.set("declaredType", {
        name: "declaredType",
        id: "-id-AttributeWithLimitedType-declaredType",
        key: "-key-AttributeWithLimitedType-declaredType",
        type: "AttributeType",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeText(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Text",
        id: "-id-Text",
        key: "-key-Text",
        isAbstract: false,
        isPublic: false,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "Text",
        constructor: (id?: string) => {
            return new MyLanguage.Text(id);
        },
        creator: (data: Partial<MyLanguage.Text>) => {
            return MyLanguage.Text.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };

    return concept;
}

function describeText2(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Text2",
        id: "-id-Text2",
        key: "-key-Text2",
        isAbstract: false,
        isPublic: false,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "Text2",
        constructor: (id?: string) => {
            return new MyLanguage.Text2(id);
        },
        creator: (data: Partial<MyLanguage.Text2>) => {
            return MyLanguage.Text2.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };

    return concept;
}

function describeText3(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Text3",
        id: "-id-Text3",
        key: "-key-Text3",
        isAbstract: false,
        isPublic: false,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "Text3",
        constructor: (id?: string) => {
            return new MyLanguage.Text3(id);
        },
        creator: (data: Partial<MyLanguage.Text3>) => {
            return MyLanguage.Text3.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };

    return concept;
}

function describeText4(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Text4",
        id: "-id-Text4",
        key: "-key-Text4",
        isAbstract: false,
        isPublic: false,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "Text4",
        constructor: (id?: string) => {
            return new MyLanguage.Text4(id);
        },
        creator: (data: Partial<MyLanguage.Text4>) => {
            return MyLanguage.Text4.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };

    return concept;
}

function describeAttributeWithEntityType(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "AttributeWithEntityType",
        id: "-id-AttributeWithEntityType",
        key: "-key-AttributeWithEntityType",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: true,
        trigger: "AttributeWithEntityType",
        constructor: (id?: string) => {
            return new MyLanguage.AttributeWithEntityType(id);
        },
        creator: (data: Partial<MyLanguage.AttributeWithEntityType>) => {
            return MyLanguage.AttributeWithEntityType.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-AttributeWithEntityType-name",
        key: "-key-AttributeWithEntityType-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });

    concept.properties.set("declaredType", {
        name: "declaredType",
        id: "-id-AttributeWithEntityType-declaredType",
        key: "-key-AttributeWithEntityType-declaredType",
        type: "Entity",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeVariable(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "Variable",
        id: "-id-Variable",
        key: "-key-Variable",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: true,
        trigger: "Variable",
        constructor: (id?: string) => {
            return new MyLanguage.Variable(id);
        },
        creator: (data: Partial<MyLanguage.Variable>) => {
            return MyLanguage.Variable.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [],
    };
    concept.properties.set("name", {
        name: "name",
        id: "-id-Variable-name",
        key: "-key-Variable-name",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });

    concept.properties.set("declaredType", {
        name: "declaredType",
        id: "-id-Variable-declaredType",
        key: "-key-Variable-declaredType",
        type: "Entity",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeEntityExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "EntityExpression",
        id: "-id-EntityExpression",
        key: "-key-EntityExpression",
        isAbstract: true,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "EntityExpression",
        constructor: (id?: string) => {
            return null;
        },
        creator: (data: Partial<MyLanguage.EntityExpression>) => {
            return null;
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: [
            "AbsExpression",
            "MultiplyExpression",
            "VariableRef",
            "LiteralExpression",
            "StringLiteralExpression",
            "NumberLiteralExpression",
            "BooleanLiteralExpression",
            "BinaryExpression",
            "PlusExpression",
            "DivideExpression",
            "AndExpression",
            "OrExpression",
            "ComparisonExpression",
            "LessThenExpression",
            "GreaterThenExpression",
            "EqualsExpression",
            "FunctionCallExpression",
            "IfExpression",
        ],
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeAppliedFeature(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "AppliedFeature",
        id: "-id-AppliedFeature",
        key: "-key-AppliedFeature",
        isAbstract: true,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "AppliedFeature",
        constructor: (id?: string) => {
            return null;
        },
        creator: (data: Partial<MyLanguage.AppliedFeature>) => {
            return null;
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: null,
        subConceptNames: ["AttributeRef"],
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-AppliedFeature-appliedfeature",
        key: "-key-AppliedFeature-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeAttributeRef(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "AttributeRef",
        id: "-id-AttributeRef",
        key: "-key-AttributeRef",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "AttributeRef",
        constructor: (id?: string) => {
            return new MyLanguage.AttributeRef(id);
        },
        creator: (data: Partial<MyLanguage.AttributeRef>) => {
            return MyLanguage.AttributeRef.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "AppliedFeature",
        subConceptNames: [],
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-AppliedFeature-appliedfeature",
        key: "-key-AppliedFeature-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("attribute", {
        name: "attribute",
        id: "-id-AttributeRef-attribute",
        key: "-key-AttributeRef-attribute",
        type: "AttributeWithEntityType",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeVariableRef(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "VariableRef",
        id: "-id-VariableRef",
        key: "-key-VariableRef",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "VariableRef",
        constructor: (id?: string) => {
            return new MyLanguage.VariableRef(id);
        },
        creator: (data: Partial<MyLanguage.VariableRef>) => {
            return MyLanguage.VariableRef.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "EntityExpression",
        subConceptNames: [],
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("variable", {
        name: "variable",
        id: "-id-VariableRef-variable",
        key: "-key-VariableRef-variable",
        type: "Variable",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeLiteralExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "LiteralExpression",
        id: "-id-LiteralExpression",
        key: "-key-LiteralExpression",
        isAbstract: true,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "LiteralExpression",
        constructor: (id?: string) => {
            return null;
        },
        creator: (data: Partial<MyLanguage.LiteralExpression>) => {
            return null;
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "EntityExpression",
        subConceptNames: ["StringLiteralExpression", "NumberLiteralExpression", "BooleanLiteralExpression"],
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeStringLiteralExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "StringLiteralExpression",
        id: "-id-StringLiteralExpression",
        key: "-key-StringLiteralExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "StringLiteralExpression",
        constructor: (id?: string) => {
            return new MyLanguage.StringLiteralExpression(id);
        },
        creator: (data: Partial<MyLanguage.StringLiteralExpression>) => {
            return MyLanguage.StringLiteralExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "LiteralExpression",
        subConceptNames: [],
    };
    concept.properties.set("value", {
        name: "value",
        id: "-id-StringLiteralExpression-value",
        key: "-key-StringLiteralExpression-value",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeNumberLiteralExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "NumberLiteralExpression",
        id: "-id-NumberLiteralExpression",
        key: "-key-NumberLiteralExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "NumberLiteralExpression",
        constructor: (id?: string) => {
            return new MyLanguage.NumberLiteralExpression(id);
        },
        creator: (data: Partial<MyLanguage.NumberLiteralExpression>) => {
            return MyLanguage.NumberLiteralExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "LiteralExpression",
        subConceptNames: [],
    };
    concept.properties.set("value", {
        name: "value",
        id: "-id-NumberLiteralExpression-value",
        key: "-key-NumberLiteralExpression-value",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeBooleanLiteralExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "BooleanLiteralExpression",
        id: "-id-BooleanLiteralExpression",
        key: "-key-BooleanLiteralExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "BooleanLiteralExpression",
        constructor: (id?: string) => {
            return new MyLanguage.BooleanLiteralExpression(id);
        },
        creator: (data: Partial<MyLanguage.BooleanLiteralExpression>) => {
            return MyLanguage.BooleanLiteralExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "LiteralExpression",
        subConceptNames: [],
    };
    concept.properties.set("value", {
        name: "value",
        id: "-id-BooleanLiteralExpression-value",
        key: "-key-BooleanLiteralExpression-value",
        type: "string",
        isList: false,
        isOptional: false, // false,
        isPublic: true,
        language: "-key-Entity",
        propertyKind: "primitive",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeBinaryExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "BinaryExpression",
        id: "-id-BinaryExpression",
        key: "-key-BinaryExpression",
        isAbstract: true,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "BinaryExpression",
        constructor: (id?: string) => {
            return null;
        },
        creator: (data: Partial<MyLanguage.BinaryExpression>) => {
            return null;
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "EntityExpression",
        subConceptNames: [
            "MultiplyExpression",
            "PlusExpression",
            "DivideExpression",
            "AndExpression",
            "OrExpression",
            "ComparisonExpression",
            "LessThenExpression",
            "GreaterThenExpression",
            "EqualsExpression",
        ],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describePlusExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "PlusExpression",
        id: "-id-PlusExpression",
        key: "-key-PlusExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "PlusExpression",
        constructor: (id?: string) => {
            return new MyLanguage.PlusExpression(id);
        },
        creator: (data: Partial<MyLanguage.PlusExpression>) => {
            return MyLanguage.PlusExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeDivideExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "DivideExpression",
        id: "-id-DivideExpression",
        key: "-key-DivideExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "DivideExpression",
        constructor: (id?: string) => {
            return new MyLanguage.DivideExpression(id);
        },
        creator: (data: Partial<MyLanguage.DivideExpression>) => {
            return MyLanguage.DivideExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeAndExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "AndExpression",
        id: "-id-AndExpression",
        key: "-key-AndExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "AndExpression",
        constructor: (id?: string) => {
            return new MyLanguage.AndExpression(id);
        },
        creator: (data: Partial<MyLanguage.AndExpression>) => {
            return MyLanguage.AndExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeOrExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "OrExpression",
        id: "-id-OrExpression",
        key: "-key-OrExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "OrExpression",
        constructor: (id?: string) => {
            return new MyLanguage.OrExpression(id);
        },
        creator: (data: Partial<MyLanguage.OrExpression>) => {
            return MyLanguage.OrExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeComparisonExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "ComparisonExpression",
        id: "-id-ComparisonExpression",
        key: "-key-ComparisonExpression",
        isAbstract: true,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "ComparisonExpression",
        constructor: (id?: string) => {
            return null;
        },
        creator: (data: Partial<MyLanguage.ComparisonExpression>) => {
            return null;
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "BinaryExpression",
        subConceptNames: ["LessThenExpression", "GreaterThenExpression", "EqualsExpression"],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeLessThenExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "LessThenExpression",
        id: "-id-LessThenExpression",
        key: "-key-LessThenExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "LessThenExpression",
        constructor: (id?: string) => {
            return new MyLanguage.LessThenExpression(id);
        },
        creator: (data: Partial<MyLanguage.LessThenExpression>) => {
            return MyLanguage.LessThenExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "ComparisonExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeGreaterThenExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "GreaterThenExpression",
        id: "-id-GreaterThenExpression",
        key: "-key-GreaterThenExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "GreaterThenExpression",
        constructor: (id?: string) => {
            return new MyLanguage.GreaterThenExpression(id);
        },
        creator: (data: Partial<MyLanguage.GreaterThenExpression>) => {
            return MyLanguage.GreaterThenExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "ComparisonExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeEqualsExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "EqualsExpression",
        id: "-id-EqualsExpression",
        key: "-key-EqualsExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "EqualsExpression",
        constructor: (id?: string) => {
            return new MyLanguage.EqualsExpression(id);
        },
        creator: (data: Partial<MyLanguage.EqualsExpression>) => {
            return MyLanguage.EqualsExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "ComparisonExpression",
        subConceptNames: [],
    };

    concept.properties.set("left", {
        name: "left",
        id: "-id-BinaryExpression-left",
        key: "-key-BinaryExpression-left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("right", {
        name: "right",
        id: "-id-BinaryExpression-right",
        key: "-key-BinaryExpression-right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeFunctionCallExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "FunctionCallExpression",
        id: "-id-FunctionCallExpression",
        key: "-key-FunctionCallExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "FunctionCallExpression",
        constructor: (id?: string) => {
            return new MyLanguage.FunctionCallExpression(id);
        },
        creator: (data: Partial<MyLanguage.FunctionCallExpression>) => {
            return MyLanguage.FunctionCallExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "EntityExpression",
        subConceptNames: [],
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("functionDefinition", {
        name: "functionDefinition",
        id: "-id-FunctionCallExpression-functionDefinition",
        key: "-key-FunctionCallExpression-functionDefinition",
        type: "EntityFunction",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "reference",
    });
    return concept;
}

function describeIfExpression(): FreLanguageConcept {
    const concept: FreLanguageConcept = {
        typeName: "IfExpression",
        id: "-id-IfExpression",
        key: "-key-IfExpression",
        isAbstract: false,
        isPublic: true,
        isLimited: false,
        instanceNames: [],
        language: "-key-Entity",
        isNamedElement: false,
        trigger: "IfExpression",
        constructor: (id?: string) => {
            return new MyLanguage.IfExpression(id);
        },
        creator: (data: Partial<MyLanguage.IfExpression>) => {
            return MyLanguage.IfExpression.create(data);
        },
        properties: new Map<string, FreLanguageProperty>(),
        baseName: "EntityExpression",
        subConceptNames: [],
    };

    concept.properties.set("condition", {
        name: "condition",
        id: "-id-IfExpression-condition",
        key: "-key-IfExpression-condition",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("whenTrue", {
        name: "whenTrue",
        id: "-id-IfExpression-whenTrue",
        key: "-key-IfExpression-whenTrue",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("whenFalse", {
        name: "whenFalse",
        id: "-id-IfExpression-whenFalse",
        key: "-key-IfExpression-whenFalse",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "-key-Entity",
        propertyKind: "part",
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        id: "-id-EntityExpression-appliedfeature",
        key: "-key-EntityExpression-appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        isOptional: true,
        language: "-key-Entity",
        propertyKind: "part",
    });

    return concept;
}

function describeBaseType(): FreLanguageInterface {
    const intface: FreLanguageInterface = {
        typeName: "BaseType",
        id: "-id-BaseType",
        key: "-key-BaseType",
        isPublic: true,
        isNamedElement: true,
        properties: new Map<string, FreLanguageProperty>(),
        constructor: undefined,
        creator: undefined,
        language: "Entity",
        subConceptNames: ["Entity", "AttributeType"],
    };
    intface.properties.set("name", {
        name: "name",
        id: "-id-BaseType-name",
        key: "-key-BaseType-name",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "primitive",
    });
    intface.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        id: "-id-BaseType-baseInterface_attr",
        key: "-key-BaseType-baseInterface_attr",
        type: "number",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "primitive",
    });

    return intface;
}

function describeType(): FreLanguageInterface {
    const intface: FreLanguageInterface = {
        typeName: "Type",
        id: "-id-Type",
        key: "-key-Type",
        isPublic: true,
        isNamedElement: true,
        properties: new Map<string, FreLanguageProperty>(),
        constructor: undefined,
        creator: undefined,
        language: "Entity",
        subConceptNames: ["Entity"],
    };
    intface.properties.set("simpleprop", {
        name: "simpleprop",
        id: "-id-Type-simpleprop",
        key: "-key-Type-simpleprop",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "primitive",
    });
    intface.properties.set("name", {
        name: "name",
        id: "-id-BaseType-name",
        key: "-key-BaseType-name",
        type: "string",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "primitive",
    });
    intface.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        id: "-id-BaseType-baseInterface_attr",
        key: "-key-BaseType-baseInterface_attr",
        type: "number",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "primitive",
    });
    intface.properties.set("int_attrs", {
        name: "int_attrs",
        id: "-id-Type-int_attrs",
        key: "-key-Type-int_attrs",
        type: "AttributeWithLimitedType",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "part",
    });
    intface.properties.set("int_functions", {
        name: "int_functions",
        id: "-id-Type-int_functions",
        key: "-key-Type-int_functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "part",
    });
    intface.properties.set("baseInterface", {
        name: "baseInterface",
        id: "-id-Type-baseInterface",
        key: "-key-Type-baseInterface",
        type: "Entity",
        isList: false,
        isPublic: true,
        isOptional: false,
        language: "Entity",
        propertyKind: "reference",
    });
    return intface;
}
