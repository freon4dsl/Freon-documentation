// Generated by the Freon Language Generator.
import { FreError, FreErrorSeverity, FreCompositeTyper, FreWriter, FreNamedNode, FreLanguageEnvironment } from "@freon4dsl/core";
import {
    Entity,
    AttributeType,
    MockEnumeration,
    AbsExpression,
    MultiplyExpression,
    EntityFunction,
    AttributeWithLimitedType,
    Text,
    Text2,
    Text3,
    Text4,
    AttributeWithEntityType,
    Variable,
    EntityExpression,
    AppliedFeature,
    AttributeRef,
    VariableRef,
    LiteralExpression,
    StringLiteralExpression,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    BinaryExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
    FunctionCallExpression,
    IfExpression,
    BaseType,
    Type,
    SomeOtherModelUnit,
    EntityModelUnit
} from "../../language/gen";
import { EntityDefaultWorker } from "../../utils/gen";
import { EntityCheckerInterface } from "./EntityValidator";
import { reservedWordsInTypescript } from "./ReservedWords";

/**
 * Class EntityValidationRulesChecker is the part of validator that is generated from, if present,
 * the validator definition. As the other checkers, it uses the visitor pattern.
 * Class EntityDefaultWorker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class EntityValidationRulesChecker extends EntityDefaultWorker implements EntityCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'typer' is used to implement the 'typecheck' rules in the validator definition
    typer: FreCompositeTyper = FreLanguageEnvironment.getInstance().typer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeAttributeType(modelelement: AttributeType): boolean {
        let hasFatalError: boolean = false;
        // self.extra >= 12
        if (!(modelelement.extra >= 12)) {
            this.errorList.push(new FreError("'self.extra >= 12' is false", modelelement, modelelement.name, FreErrorSeverity.ToDo));
        } // self.extra <= 30
        if (!(modelelement.extra <= 30)) {
            this.errorList.push(new FreError("'self.extra <= 30' is false", modelelement, modelelement.name, FreErrorSeverity.ToDo));
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeEntityModelUnit(modelelement: EntityModelUnit): boolean {
        let hasFatalError: boolean = false;
        // @notEmpty self.entities
        if (modelelement.entities.length == 0) {
            this.errorList.push(
                new FreError(
                    "List 'self.entities' may not be empty",
                    modelelement,
                    modelelement.name,
                    "self.entities",
                    FreErrorSeverity.ToDo
                )
            );
        } // isunique name in self.entities
        let uniqueNameInEntities: string[] = [];
        modelelement.entities.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'entities' has no value`,
                        modelelement.entities[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.ToDo
                    )
                );
            } else {
                if (!uniqueNameInEntities.includes(elem.name)) {
                    uniqueNameInEntities.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'entities'`,
                            modelelement.entities[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.ToDo
                        )
                    );
                }
            }
        }); // @notEmpty self.functions
        if (modelelement.functions.length == 0) {
            this.errorList.push(
                new FreError(
                    "List 'self.functions' may not be empty",
                    modelelement,
                    modelelement.name,
                    "self.functions",
                    FreErrorSeverity.ToDo
                )
            );
        } // isunique name in self.functions
        let uniqueNameInFunctions: string[] = [];
        modelelement.functions.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'functions' has no value`,
                        modelelement.functions[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.ToDo
                    )
                );
            } else {
                if (!uniqueNameInFunctions.includes(elem.name)) {
                    uniqueNameInFunctions.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'functions'`,
                            modelelement.functions[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.ToDo
                        )
                    );
                }
            }
        }); // @validName self.name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeEntity(modelelement: Entity): boolean {
        let hasFatalError: boolean = false;
        // @notEmpty self.attributes
        if (modelelement.attributes.length == 0) {
            this.errorList.push(
                new FreError(
                    "List 'self.attributes' may not be empty",
                    modelelement,
                    modelelement.name,
                    "self.attributes",
                    FreErrorSeverity.ToDo
                )
            );
        } // isunique name in self.attributes
        let uniqueNameInAttributes: string[] = [];
        modelelement.attributes.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'attributes' has no value`,
                        modelelement.attributes[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.ToDo
                    )
                );
            } else {
                if (!uniqueNameInAttributes.includes(elem.name)) {
                    uniqueNameInAttributes.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'attributes'`,
                            modelelement.attributes[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.ToDo
                        )
                    );
                }
            }
        }); // @notEmpty self.functions
        if (modelelement.functions.length == 0) {
            this.errorList.push(
                new FreError(
                    "List 'self.functions' may not be empty",
                    modelelement,
                    modelelement.name,
                    "self.functions",
                    FreErrorSeverity.ToDo
                )
            );
        } // isunique name in self.functions
        let uniqueNameInFunctions: string[] = [];
        modelelement.functions.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'functions' has no value`,
                        modelelement.functions[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.ToDo
                    )
                );
            } else {
                if (!uniqueNameInFunctions.includes(elem.name)) {
                    uniqueNameInFunctions.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'functions'`,
                            modelelement.functions[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.ToDo
                        )
                    );
                }
            }
        }); // @validName self.name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeAttributeWithLimitedType(modelelement: AttributeWithLimitedType): boolean {
        let hasFatalError: boolean = false;
        // @validName self.name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeVariable(modelelement: Variable): boolean {
        let hasFatalError: boolean = false;
        // @validName self.name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeEntityFunction(modelelement: EntityFunction): boolean {
        let hasFatalError: boolean = false;
        // @typecheck conformsTo( self.expression, self.declaredType )
        if (!this.typer.conformsType(modelelement.expression, modelelement.$declaredType)) {
            this.errorList.push(
                new FreError(
                    "Type " +
                        this.typer.inferType(modelelement.expression)?.toFreString(this.myWriter) +
                        " of [" +
                        this.myWriter.writeNameOnly(modelelement.expression) +
                        "] does not conform to " +
                        this.myWriter.writeNameOnly(modelelement.$declaredType),
                    modelelement.expression,
                    modelelement.name,
                    FreErrorSeverity.ToDo
                )
            );
        } // isunique name in self.parameters
        let uniqueNameInParameters: string[] = [];
        modelelement.parameters.forEach((elem, index) => {
            if (elem === undefined || elem === null) {
                this.errorList.push(
                    new FreError(
                        `Element[${index}] of property 'parameters' has no value`,
                        modelelement.parameters[index],
                        modelelement.name,
                        "name",
                        FreErrorSeverity.ToDo
                    )
                );
            } else {
                if (!uniqueNameInParameters.includes(elem.name)) {
                    uniqueNameInParameters.push(elem.name);
                } else {
                    this.errorList.push(
                        new FreError(
                            `The value of property 'name' ("${this.myWriter.writeNameOnly(elem)}") is not unique in list 'parameters'`,
                            modelelement.parameters[index],
                            modelelement.name,
                            "name",
                            FreErrorSeverity.ToDo
                        )
                    );
                }
            }
        }); // @validName self.name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(
                new FreError(
                    "'" + modelelement.name + "' is not a valid identifier",
                    modelelement,
                    modelelement.name,
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeAbsExpression(modelelement: AbsExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.expr, AttributeType:Integer )
        const leftType0 = this.typer.inferType(modelelement.expr);
        const rightType0 = this.typer.inferType(AttributeType.Integer);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.expr) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Integer) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.expr,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeMultiplyExpression(modelelement: MultiplyExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.left, AttributeType:Integer )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(AttributeType.Integer);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Integer) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck equalsType( self.right, AttributeType:Integer )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(AttributeType.Integer);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Integer) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck conformsTo( self.left, self.right )
        if (!this.typer.conformsType(modelelement.left, modelelement.right)) {
            this.errorList.push(
                new FreError(
                    "Type " +
                        this.typer.inferType(modelelement.left)?.toFreString(this.myWriter) +
                        " of [" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "] does not conform to " +
                        this.myWriter.writeNameOnly(modelelement.right),
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforePlusExpression(modelelement: PlusExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.left, AttributeType:Integer )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(AttributeType.Integer);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Integer) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck equalsType( self.right, AttributeType:Integer )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(AttributeType.Integer);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Integer) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck conformsTo( self.left, self.right )
        if (!this.typer.conformsType(modelelement.left, modelelement.right)) {
            this.errorList.push(
                new FreError(
                    "Type " +
                        this.typer.inferType(modelelement.left)?.toFreString(this.myWriter) +
                        " of [" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "] does not conform to " +
                        this.myWriter.writeNameOnly(modelelement.right),
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeDivideExpression(modelelement: DivideExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.left, AttributeType:Integer )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(AttributeType.Integer);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Integer) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck equalsType( self.right, AttributeType:Integer )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(AttributeType.Integer);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Integer) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeAndExpression(modelelement: AndExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.left, AttributeType:Boolean )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(AttributeType.Boolean);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Boolean) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck equalsType( self.right, AttributeType:Boolean )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(AttributeType.Boolean);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Boolean) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeOrExpression(modelelement: OrExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.left, AttributeType:Boolean )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(AttributeType.Boolean);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Boolean) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck equalsType( self.right, AttributeType:Boolean )
        const leftType1 = this.typer.inferType(modelelement.right);
        const rightType1 = this.typer.inferType(AttributeType.Boolean);
        if (!this.typer.equals(leftType1, rightType1)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        leftType1?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Boolean) +
                        "' (" +
                        rightType1?.toFreString(this.myWriter) +
                        ")",
                    modelelement.right,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeComparisonExpression(modelelement: ComparisonExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.left, self.right )
        const leftType0 = this.typer.inferType(modelelement.left);
        const rightType0 = this.typer.inferType(modelelement.right);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.left) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(modelelement.right) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.left,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Checks 'modelelement' before checking its children.
     * Found errors are pushed onto 'errorlist'.
     * @param modelelement
     */
    public execBeforeIfExpression(modelelement: IfExpression): boolean {
        let hasFatalError: boolean = false;
        // @typecheck equalsType( self.condition, AttributeType:Boolean )
        const leftType0 = this.typer.inferType(modelelement.condition);
        const rightType0 = this.typer.inferType(AttributeType.Boolean);
        if (!this.typer.equals(leftType0, rightType0)) {
            this.errorList.push(
                new FreError(
                    "Type of '" +
                        this.myWriter.writeNameOnly(modelelement.condition) +
                        "' (" +
                        leftType0?.toFreString(this.myWriter) +
                        ") should equal the type of '" +
                        this.myWriter.writeNameOnly(AttributeType.Boolean) +
                        "' (" +
                        rightType0?.toFreString(this.myWriter) +
                        ")",
                    modelelement.condition,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        } // @typecheck conformsTo( self.whenTrue, self.whenFalse )
        if (!this.typer.conformsType(modelelement.whenTrue, modelelement.whenFalse)) {
            this.errorList.push(
                new FreError(
                    "Type " +
                        this.typer.inferType(modelelement.whenTrue)?.toFreString(this.myWriter) +
                        " of [" +
                        this.myWriter.writeNameOnly(modelelement.whenTrue) +
                        "] does not conform to " +
                        this.myWriter.writeNameOnly(modelelement.whenFalse),
                    modelelement.whenTrue,
                    "unnamed",
                    FreErrorSeverity.ToDo
                )
            );
        }
        return hasFatalError;
    }

    /**
     * Returns true if 'name' is a valid identifier
     * @param name
     */
    private isValidName(name: string): boolean {
        if (!!!name) return false;
        // cannot start with number
        if (/[0-9]/.test(name[0])) return false;
        // may contain letters, numbers, '$', and '_', but no other characters
        if (/[.|,|!|?|@|~|%|^|&|*|-|=|+|(|)|{|}|"|'|:|;|<|>|?]/.test(name)) return false;
        if (/\\/.test(name)) return false;
        if (/[/|[|]]/.test(name)) return false;
        // may not contain whitespaces
        if (/[\t|\n|\r| ]/.test(name)) return false;
        // may not be a Typescript keyword
        if (reservedWordsInTypescript.includes(name)) return false;
        return true;
    }
}
