// Generated by the Freon Language Generator.
import { FreLanguage, Model, ModelUnit, Property, Concept, Interface, FreNodeReference } from "@freon4dsl/core";

import {
    EntityModel,
    SomeOtherModelUnit,
    EntityModelUnit,
    Entity,
    AttributeType,
    MockEnumeration,
    AbsExpression,
    MultiplyExpression,
    EntityFunction,
    AttributeWithLimitedType,
    Text,
    Text2,
    Text3,
    Text4,
    AttributeWithEntityType,
    Variable,
    EntityExpression,
    AppliedFeature,
    AttributeRef,
    VariableRef,
    LiteralExpression,
    StringLiteralExpression,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    BinaryExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
    FunctionCallExpression,
    IfExpression
} from "./internal";

/**
 * Creates an in-memory representation of structure of the language metamodel, used in e.g. the (de)serializer.
 */
export function initializeLanguage() {
    FreLanguage.getInstance().name = "Entity";
    FreLanguage.getInstance().addModel(describeEntityModel());
    FreLanguage.getInstance().addUnit(describeSomeOtherModelUnit());
    FreLanguage.getInstance().addUnit(describeEntityModelUnit());
    FreLanguage.getInstance().addConcept(describeEntity());
    FreLanguage.getInstance().addConcept(describeAttributeType());
    FreLanguage.getInstance().addConcept(describeMockEnumeration());
    FreLanguage.getInstance().addConcept(describeAbsExpression());
    FreLanguage.getInstance().addConcept(describeMultiplyExpression());
    FreLanguage.getInstance().addConcept(describeEntityFunction());
    FreLanguage.getInstance().addConcept(describeAttributeWithLimitedType());
    FreLanguage.getInstance().addConcept(describeText());
    FreLanguage.getInstance().addConcept(describeText2());
    FreLanguage.getInstance().addConcept(describeText3());
    FreLanguage.getInstance().addConcept(describeText4());
    FreLanguage.getInstance().addConcept(describeAttributeWithEntityType());
    FreLanguage.getInstance().addConcept(describeVariable());
    FreLanguage.getInstance().addConcept(describeEntityExpression());
    FreLanguage.getInstance().addConcept(describeAppliedFeature());
    FreLanguage.getInstance().addConcept(describeAttributeRef());
    FreLanguage.getInstance().addConcept(describeVariableRef());
    FreLanguage.getInstance().addConcept(describeLiteralExpression());
    FreLanguage.getInstance().addConcept(describeStringLiteralExpression());
    FreLanguage.getInstance().addConcept(describeNumberLiteralExpression());
    FreLanguage.getInstance().addConcept(describeBooleanLiteralExpression());
    FreLanguage.getInstance().addConcept(describeBinaryExpression());
    FreLanguage.getInstance().addConcept(describePlusExpression());
    FreLanguage.getInstance().addConcept(describeDivideExpression());
    FreLanguage.getInstance().addConcept(describeAndExpression());
    FreLanguage.getInstance().addConcept(describeOrExpression());
    FreLanguage.getInstance().addConcept(describeComparisonExpression());
    FreLanguage.getInstance().addConcept(describeLessThenExpression());
    FreLanguage.getInstance().addConcept(describeGreaterThenExpression());
    FreLanguage.getInstance().addConcept(describeEqualsExpression());
    FreLanguage.getInstance().addConcept(describeFunctionCallExpression());
    FreLanguage.getInstance().addConcept(describeIfExpression());
    FreLanguage.getInstance().addInterface(describeBaseType());
    FreLanguage.getInstance().addInterface(describeType());
    FreLanguage.getInstance().addReferenceCreator((name: string, type: string) => {
        return !!name ? FreNodeReference.create(name, type) : null;
    });
}

function describeEntityModel(): Model {
    const model = {
        typeName: "EntityModel",
        isNamespace: true,
        constructor: () => {
            return new EntityModel();
        },
        properties: new Map<string, Property>()
    };
    model.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    model.properties.set("units", {
        name: "units",
        type: "EntityModelUnit",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    model.properties.set("extraUnit", {
        name: "extraUnit",
        type: "SomeOtherModelUnit",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return model;
}

function describeSomeOtherModelUnit(): ModelUnit {
    const modelunit = {
        typeName: "SomeOtherModelUnit",
        isNamedElement: true,
        fileExtension: "som",
        constructor: () => {
            return new SomeOtherModelUnit();
        },
        properties: new Map<string, Property>()
    };
    modelunit.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    modelunit.properties.set("somePart", {
        name: "somePart",
        type: "Entity",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return modelunit;
}

function describeEntityModelUnit(): ModelUnit {
    const modelunit = {
        typeName: "EntityModelUnit",
        isNamedElement: true,
        fileExtension: "ent",
        constructor: () => {
            return new EntityModelUnit();
        },
        properties: new Map<string, Property>()
    };
    modelunit.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    modelunit.properties.set("functions", {
        name: "functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    modelunit.properties.set("entities", {
        name: "entities",
        type: "Entity",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });

    return modelunit;
}

function describeEntity(): Concept {
    const concept = {
        typeName: "Entity",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "Entity",
        constructor: () => {
            return new Entity();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("isCompany", {
        name: "isCompany",
        type: "boolean",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        type: "number",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("simpleprop", {
        name: "simpleprop",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("attributes", {
        name: "attributes",
        type: "AttributeWithLimitedType",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("entAttributes", {
        name: "entAttributes",
        type: "AttributeWithEntityType",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("functions", {
        name: "functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("int_attrs", {
        name: "int_attrs",
        type: "AttributeWithLimitedType",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("int_functions", {
        name: "int_functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("baseEntity", {
        name: "baseEntity",
        type: "Entity",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    concept.properties.set("baseInterface", {
        name: "baseInterface",
        type: "Entity",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeAttributeType(): Concept {
    const concept = {
        typeName: "AttributeType",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "AttributeType",
        constructor: () => {
            return new AttributeType();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("extra", {
        name: "extra",
        type: "number",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        type: "number",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });

    return concept;
}

function describeMockEnumeration(): Concept {
    const concept = {
        typeName: "MockEnumeration",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "MockEnumeration",
        constructor: () => {
            return new MockEnumeration();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });

    return concept;
}

function describeAbsExpression(): Concept {
    const concept = {
        typeName: "AbsExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "AbsExpression",
        constructor: () => {
            return new AbsExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "EntityExpression",
        subConceptNames: []
    };

    concept.properties.set("expr", {
        name: "expr",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeMultiplyExpression(): Concept {
    const concept = {
        typeName: "MultiplyExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "MultiplyExpression",
        constructor: () => {
            return new MultiplyExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "BinaryExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeEntityFunction(): Concept {
    const concept = {
        typeName: "EntityFunction",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "EntityFunction",
        constructor: () => {
            return new EntityFunction();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("aliases", {
        name: "aliases",
        type: "string",
        isList: true,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("expression", {
        name: "expression",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("parameters", {
        name: "parameters",
        type: "Variable",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("declaredType", {
        name: "declaredType",
        type: "Type",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeAttributeWithLimitedType(): Concept {
    const concept = {
        typeName: "AttributeWithLimitedType",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "AttributeWithLimitedType",
        constructor: () => {
            return new AttributeWithLimitedType();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });

    concept.properties.set("declaredType", {
        name: "declaredType",
        type: "AttributeType",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeText(): Concept {
    const concept = {
        typeName: "Text",
        isAbstract: false,
        isPublic: undefined,
        isNamedElement: false,
        trigger: "Text",
        constructor: () => {
            return new Text();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };

    return concept;
}

function describeText2(): Concept {
    const concept = {
        typeName: "Text2",
        isAbstract: false,
        isPublic: undefined,
        isNamedElement: false,
        trigger: "Text2",
        constructor: () => {
            return new Text2();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };

    return concept;
}

function describeText3(): Concept {
    const concept = {
        typeName: "Text3",
        isAbstract: false,
        isPublic: undefined,
        isNamedElement: false,
        trigger: "Text3",
        constructor: () => {
            return new Text3();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };

    return concept;
}

function describeText4(): Concept {
    const concept = {
        typeName: "Text4",
        isAbstract: false,
        isPublic: undefined,
        isNamedElement: false,
        trigger: "Text4",
        constructor: () => {
            return new Text4();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };

    return concept;
}

function describeAttributeWithEntityType(): Concept {
    const concept = {
        typeName: "AttributeWithEntityType",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "AttributeWithEntityType",
        constructor: () => {
            return new AttributeWithEntityType();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });

    concept.properties.set("declaredType", {
        name: "declaredType",
        type: "Entity",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeVariable(): Concept {
    const concept = {
        typeName: "Variable",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "Variable",
        constructor: () => {
            return new Variable();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });

    concept.properties.set("declaredType", {
        name: "declaredType",
        type: "Entity",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeEntityExpression(): Concept {
    const concept = {
        typeName: "EntityExpression",
        isAbstract: true,
        isPublic: true,
        isNamedElement: false,
        trigger: "EntityExpression",
        constructor: () => {
            return null;
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: [
            "AbsExpression",
            "MultiplyExpression",
            "VariableRef",
            "LiteralExpression",
            "StringLiteralExpression",
            "NumberLiteralExpression",
            "BooleanLiteralExpression",
            "BinaryExpression",
            "PlusExpression",
            "DivideExpression",
            "AndExpression",
            "OrExpression",
            "ComparisonExpression",
            "LessThenExpression",
            "GreaterThenExpression",
            "EqualsExpression",
            "FunctionCallExpression",
            "IfExpression"
        ]
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeAppliedFeature(): Concept {
    const concept = {
        typeName: "AppliedFeature",
        isAbstract: true,
        isPublic: true,
        isNamedElement: false,
        trigger: "AppliedFeature",
        constructor: () => {
            return null;
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: ["AttributeRef"]
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeAttributeRef(): Concept {
    const concept = {
        typeName: "AttributeRef",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "AttributeRef",
        constructor: () => {
            return new AttributeRef();
        },
        properties: new Map<string, Property>(),
        baseName: "AppliedFeature",
        subConceptNames: []
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("attribute", {
        name: "attribute",
        type: "AttributeWithEntityType",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeVariableRef(): Concept {
    const concept = {
        typeName: "VariableRef",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "VariableRef",
        constructor: () => {
            return new VariableRef();
        },
        properties: new Map<string, Property>(),
        baseName: "EntityExpression",
        subConceptNames: []
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("variable", {
        name: "variable",
        type: "Variable",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeLiteralExpression(): Concept {
    const concept = {
        typeName: "LiteralExpression",
        isAbstract: true,
        isPublic: true,
        isNamedElement: false,
        trigger: "LiteralExpression",
        constructor: () => {
            return null;
        },
        properties: new Map<string, Property>(),
        baseName: "EntityExpression",
        subConceptNames: ["StringLiteralExpression", "NumberLiteralExpression", "BooleanLiteralExpression"]
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeStringLiteralExpression(): Concept {
    const concept = {
        typeName: "StringLiteralExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "StringLiteralExpression",
        constructor: () => {
            return new StringLiteralExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "LiteralExpression",
        subConceptNames: []
    };
    concept.properties.set("value", {
        name: "value",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeNumberLiteralExpression(): Concept {
    const concept = {
        typeName: "NumberLiteralExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "NumberLiteralExpression",
        constructor: () => {
            return new NumberLiteralExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "LiteralExpression",
        subConceptNames: []
    };
    concept.properties.set("value", {
        name: "value",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeBooleanLiteralExpression(): Concept {
    const concept = {
        typeName: "BooleanLiteralExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "BooleanLiteralExpression",
        constructor: () => {
            return new BooleanLiteralExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "LiteralExpression",
        subConceptNames: []
    };
    concept.properties.set("value", {
        name: "value",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeBinaryExpression(): Concept {
    const concept = {
        typeName: "BinaryExpression",
        isAbstract: true,
        isPublic: true,
        isNamedElement: false,
        trigger: "BinaryExpression",
        constructor: () => {
            return null;
        },
        properties: new Map<string, Property>(),
        baseName: "EntityExpression",
        subConceptNames: [
            "MultiplyExpression",
            "PlusExpression",
            "DivideExpression",
            "AndExpression",
            "OrExpression",
            "ComparisonExpression",
            "LessThenExpression",
            "GreaterThenExpression",
            "EqualsExpression"
        ]
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describePlusExpression(): Concept {
    const concept = {
        typeName: "PlusExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "PlusExpression",
        constructor: () => {
            return new PlusExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "BinaryExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeDivideExpression(): Concept {
    const concept = {
        typeName: "DivideExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "DivideExpression",
        constructor: () => {
            return new DivideExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "BinaryExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeAndExpression(): Concept {
    const concept = {
        typeName: "AndExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "AndExpression",
        constructor: () => {
            return new AndExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "BinaryExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeOrExpression(): Concept {
    const concept = {
        typeName: "OrExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "OrExpression",
        constructor: () => {
            return new OrExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "BinaryExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeComparisonExpression(): Concept {
    const concept = {
        typeName: "ComparisonExpression",
        isAbstract: true,
        isPublic: true,
        isNamedElement: false,
        trigger: "ComparisonExpression",
        constructor: () => {
            return null;
        },
        properties: new Map<string, Property>(),
        baseName: "BinaryExpression",
        subConceptNames: ["LessThenExpression", "GreaterThenExpression", "EqualsExpression"]
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeLessThenExpression(): Concept {
    const concept = {
        typeName: "LessThenExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "LessThenExpression",
        constructor: () => {
            return new LessThenExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "ComparisonExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeGreaterThenExpression(): Concept {
    const concept = {
        typeName: "GreaterThenExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "GreaterThenExpression",
        constructor: () => {
            return new GreaterThenExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "ComparisonExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeEqualsExpression(): Concept {
    const concept = {
        typeName: "EqualsExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "EqualsExpression",
        constructor: () => {
            return new EqualsExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "ComparisonExpression",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeFunctionCallExpression(): Concept {
    const concept = {
        typeName: "FunctionCallExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "FunctionCallExpression",
        constructor: () => {
            return new FunctionCallExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "EntityExpression",
        subConceptNames: []
    };

    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("functionDefinition", {
        name: "functionDefinition",
        type: "EntityFunction",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return concept;
}

function describeIfExpression(): Concept {
    const concept = {
        typeName: "IfExpression",
        isAbstract: false,
        isPublic: true,
        isNamedElement: false,
        trigger: "IfExpression",
        constructor: () => {
            return new IfExpression();
        },
        properties: new Map<string, Property>(),
        baseName: "EntityExpression",
        subConceptNames: []
    };

    concept.properties.set("condition", {
        name: "condition",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("whenTrue", {
        name: "whenTrue",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("whenFalse", {
        name: "whenFalse",
        type: "EntityExpression",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });
    concept.properties.set("appliedfeature", {
        name: "appliedfeature",
        type: "AppliedFeature",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeBaseType(): Interface {
    const intface = {
        typeName: "BaseType",
        isPublic: true,
        isNamedElement: true,
        properties: new Map<string, Property>(),
        subConceptNames: ["Entity", "AttributeType"]
    };
    intface.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    intface.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        type: "number",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });

    return intface;
}

function describeType(): Interface {
    const intface = {
        typeName: "Type",
        isPublic: true,
        isNamedElement: true,
        properties: new Map<string, Property>(),
        subConceptNames: ["Entity"]
    };
    intface.properties.set("simpleprop", {
        name: "simpleprop",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    intface.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    intface.properties.set("baseInterface_attr", {
        name: "baseInterface_attr",
        type: "number",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    intface.properties.set("int_attrs", {
        name: "int_attrs",
        type: "AttributeWithLimitedType",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    intface.properties.set("int_functions", {
        name: "int_functions",
        type: "EntityFunction",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });
    intface.properties.set("baseInterface", {
        name: "baseInterface",
        type: "Entity",
        isList: false,
        isPublic: true,
        propertyKind: "reference"
    });
    return intface;
}
