// Generated by the ProjectIt Language Generator.
import { EntityEveryConcept, EntityMetaType, Entity, EntityFunction, AppliedFeature } from "../../language/gen";
import { EntityNamespace } from "./EntityNamespace";
import { PiScoper, PiNamedElement, PiLogger, Language } from "@projectit/core";
import { EntityEnvironment } from "../../environment/gen/EntityEnvironment";
import { isNameSpace } from "./EntityScoperUtils";
import { EntityTyper } from "../../typer/gen";

const LOGGER = new PiLogger("EntityScoper");

/**
 * Class EntityScoper implements the scoper generated from, if present, the scoper definition,
 * otherwise this class implements the default scoper.
 */
export class EntityScoper implements PiScoper {
    myTyper: EntityTyper;

    public resolvePathName(
        basePosition: EntityEveryConcept,
        doNotSearch: string,
        pathname: string[],
        metatype?: EntityMetaType
    ): PiNamedElement {
        // basePosition itself may be an additional namespace;
        // if so, do not search this namespace, as this will result in a (mobx) cycle
        EntityNamespace.doNotSearch = doNotSearch;
        // get the names from the namespace where the pathname is found (i.e. the basePostion) to be able to check against this later on
        let elementsFromBasePosition: PiNamedElement[] = this.getVisibleElements(basePosition);
        // start the loop over the set of names in the pathname
        let previousFound: EntityEveryConcept = basePosition;
        let found: PiNamedElement = null;
        for (let index = 0; index < pathname.length; index++) {
            if (index === pathname.length - 1) {
                // it is the last name in the path, use 'metatype'
                found = this.getFromVisibleElements(previousFound, pathname[index], metatype);
            } else {
                // search the next name of pathname in the namespace of 'previousFound'
                // but do not use the metatype information, because only the element with the last of the pathname will have the correct type
                found = this.getFromVisibleElements(previousFound, pathname[index]);
                if (found === null || found === undefined || !isNameSpace(found as EntityEveryConcept)) {
                    return null;
                }
                previousFound = found as EntityEveryConcept;
            }
            // check if 'found' is public or 'found' is in the namespace of the basePosition
            if (!this.isPublic(found) && !elementsFromBasePosition.includes(found)) {
                return null;
            }
        }
        // do not forget to clear 'doNotSearch'; it is a static and might be used again!
        EntityNamespace.doNotSearch = null;
        return found;
    }

    private isPublic(found: PiNamedElement): boolean {
        // find the information about whether this element is public or private within its parent from the its container:
        // 1. check the language description to find the concept description of the parent
        // 2. from the parent find the property description with the right name
        // 3. check whether the found property is public
        if (found === null || found === undefined) {
            return false;
        }
        const container = found.piContainer();
        if (container === null || container === undefined) {
            return false;
        }
        const metaType: string = container.container.piLanguageConcept();
        if (metaType === "EntityModel") {
            return true; // model only has units as properties, all units are public
        } else if (metaType === "SomeOtherModelUnit") {
            return Language.getInstance().unit(metaType).properties.get(container.propertyName).isPublic;
        } else if (metaType === "EntityModelUnit") {
            return Language.getInstance().unit(metaType).properties.get(container.propertyName).isPublic;
        } else {
            return Language.getInstance().concept(metaType).properties.get(container.propertyName).isPublic;
        }
    }

    /**
     * See PiScoper.
     */
    public getVisibleElements(modelelement: EntityEveryConcept, metatype?: EntityMetaType, excludeSurrounding?: boolean): PiNamedElement[] {
        this.myTyper = EntityEnvironment.getInstance().typer as EntityTyper;
        let result: PiNamedElement[] = this.getElementsFromStdlib(metatype);
        if (!!modelelement) {
            let doSurrouding: boolean = !(!(excludeSurrounding === undefined) && excludeSurrounding);
            let nearestNamespace: EntityNamespace;
            // first, see if we need to use an alternative scope/namespace
            if (this.hasAlternativeScope(modelelement)) {
                nearestNamespace = this.getAlternativeScope(modelelement);
                // do not search surrounding namespaces for alternative scopes
                doSurrouding = false;
            } else {
                nearestNamespace = this.findNearestNamespace(modelelement);
            }
            // second, get the elements from the found namespace
            if (!!nearestNamespace) {
                result = result.concat(nearestNamespace.getVisibleElements(metatype));
            }

            // third, get the elements from any surrounding namespaces
            let parentElement = this.getParent(modelelement);
            while (doSurrouding) {
                const parentNamespace = this.findNearestNamespace(parentElement);
                if (!!parentNamespace) {
                    // join the results with shadowing
                    EntityNamespace.joinResultsWithShadowing(parentNamespace.getVisibleElements(metatype), result);
                    parentElement = this.getParent(parentElement);
                } else {
                    doSurrouding = false;
                }
            }
        } else {
            LOGGER.error(this, "getVisibleElements: modelelement is null");
            return result;
        }
        return result;
    }

    /**
     * See PiScoper.
     */
    public getFromVisibleElements(
        modelelement: EntityEveryConcept,
        name: string,
        metatype?: EntityMetaType,
        excludeSurrounding?: boolean
    ): PiNamedElement {
        const visibleElements = this.getVisibleElements(modelelement, metatype, excludeSurrounding);
        if (visibleElements !== null) {
            for (const element of visibleElements) {
                const n: string = element.name;
                if (name === n) {
                    return element;
                }
            }
        }
        return null;
    }

    /**
     * See PiScoper.
     */
    public getVisibleNames(modelelement: EntityEveryConcept, metatype?: EntityMetaType, excludeSurrounding?: boolean): string[] {
        const result: string[] = [];
        const visibleElements = this.getVisibleElements(modelelement, metatype, excludeSurrounding);
        for (const element of visibleElements) {
            const n: string = element.name;
            result.push(n);
        }
        return result;
    }

    /**
     * See PiScoper.
     */
    public isInScope(modelElement: EntityEveryConcept, name: string, metatype?: EntityMetaType, excludeSurrounding?: boolean): boolean {
        return this.getFromVisibleElements(modelElement, name, metatype, excludeSurrounding) !== null;
    }

    /**
     * Returns the enclosing namespace for 'modelelement'.
     * @param modelelement
     */
    private findNearestNamespace(modelelement: EntityEveryConcept): EntityNamespace {
        if (modelelement === null) {
            return null;
        }
        if (isNameSpace(modelelement)) {
            return EntityNamespace.create(modelelement);
        } else {
            return this.findNearestNamespace(this.getParent(modelelement));
        }
    }

    /**
     * Returns the element in the abstract syntax tree that contains 'modelelement'.
     * @param modelelement
     */
    private getParent(modelelement: EntityEveryConcept): EntityEveryConcept {
        let parent: EntityEveryConcept = null;
        if (modelelement.piContainer() !== null) {
            if (modelelement.piContainer().container !== null) {
                // if (modelelement.piContainer().container instanceof EntityEveryConcept) {
                parent = modelelement.piContainer().container as EntityEveryConcept;
                // }
            }
        }
        return parent;
    }

    /**
     * Returns the namespace to be used as alternative scope for 'modelelement'.
     * @param modelelement
     */
    private getAlternativeScope(modelelement: EntityEveryConcept): EntityNamespace {
        if (!!modelelement && modelelement instanceof AppliedFeature) {
            // use alternative scope 'typeof( container )'
            let container = modelelement.piContainer().container as EntityEveryConcept;
            if (!!container) {
                let newScopeElement = this.myTyper.inferType(modelelement.piContainer().container as EntityEveryConcept);
                return EntityNamespace.create(newScopeElement);
            }
        }
        return null;
    }

    /**
     * Returns true if there is an alternative scope defined for this 'modelelement'.
     * @param modelelement
     */
    private hasAlternativeScope(modelelement: EntityEveryConcept): boolean {
        if (!!modelelement && modelelement instanceof AppliedFeature) {
            return true;
        }
        return false;
    }

    /**
     * Returns all elements that are in the standard library, which types equal 'metatype'.
     * @param metatype
     */
    private getElementsFromStdlib(metatype?: EntityMetaType): PiNamedElement[] {
        if (!!metatype) {
            return EntityEnvironment.getInstance().stdlib.elements.filter(
                elem =>
                    elem.piLanguageConcept() === metatype || Language.getInstance().subConcepts(metatype).includes(elem.piLanguageConcept())
            );
        } else {
            return EntityEnvironment.getInstance().stdlib.elements;
        }
    }
}
