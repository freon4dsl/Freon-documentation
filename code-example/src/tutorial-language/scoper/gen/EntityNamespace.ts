// Generated by the ProjectIt Language Generator.
import { PiNamedElement, Language } from "@projectit/core";
import { EntityEveryConcept, EntityMetaType, Entity } from "../../language/gen";
import { EntityWalker } from "../../utils/gen/EntityWalker";
import { isNameSpace } from "./EntityScoperUtils";
import { EntityNamesCollector } from "./EntityNamesCollector";

const anymetatype = "_$anymetatype";

/**
 * Class EntityNamespace is a wrapper for a model element that is a namespace (as defined in the scoper definition).
 * It provides the implementation of the algorithm used to search for all names that are visible in the namespace.
 */
export class EntityNamespace {
    private static allNamespaces: Map<EntityEveryConcept, EntityNamespace> = new Map();
    static doNotSearch: string = null;

    /**
     * This method ensures that every element in the model has one and only one associated namespace object.
     * The type of element 'elem' should be marked as namespace in the scoper definition.
     * @param elem
     */
    public static create(elem: EntityEveryConcept): EntityNamespace {
        if (this.allNamespaces.has(elem)) {
            return this.allNamespaces.get(elem);
        } else {
            const result = new EntityNamespace(elem);
            this.allNamespaces.set(elem, result);
            return result;
        }
    }

    /**
     * This convenience method merges 'list' and 'result', where if an element is present in both,
     * the element in 'list' is discarded, thus shadowing names from 'list'.
     * @param list
     * @param result
     */
    public static joinResultsWithShadowing(list: PiNamedElement[], result: PiNamedElement[]) {
        list.forEach(elem => {
            // shadow name in outer namespace if it is already present
            if (!result.includes(elem)) {
                result.push(elem);
            }
        });
    }

    set doNotSearch(elem: string) {
        EntityNamespace.doNotSearch = elem;
    }

    private _myElem: EntityEveryConcept;
    private searchList: string[] = [];

    private constructor(elem: EntityEveryConcept) {
        this._myElem = elem;
    }

    /**
     * Returns all elements that are visible in this namespace, including those from additional namespaces
     * as defined in the scoper definition.
     */
    public getVisibleElements(metatype?: EntityMetaType): PiNamedElement[] {
        let result: PiNamedElement[] = [];

        // check whether we are already searching this namespace for a certain type
        if (this.searchingFor(metatype)) {
            return [];
        }

        // do it
        result = this.getInternalVisibleElements(metatype);

        // do additional namespaces
        if (this.hasAdditionalNamespace()) {
            // join the results
            EntityNamespace.joinResultsWithShadowing(this.addAdditionalNamespaces(metatype), result);
        }

        // at end clean searchlist
        this.cleanSearchList(metatype);
        return result;
    }

    /**
     * Returns the elements that are visible in this namespace only, without regard for additional namespaces
     * @param metatype
     */
    private getInternalVisibleElements(metatype?: EntityMetaType): PiNamedElement[] {
        const result: PiNamedElement[] = [];
        // for now we push all parts, later public/private annotations can be taken into account
        // set up the 'worker' of the visitor pattern
        const myNamesCollector = new EntityNamesCollector();
        myNamesCollector.namesList = result;
        if (!!metatype) {
            myNamesCollector.metatype = metatype;
        }

        // set up the 'walker of the visitor pattern
        const myWalker = new EntityWalker();
        myWalker.myWorkers.push(myNamesCollector);

        // collect the elements from the namespace, but not from any child namespace
        myWalker.walk(this._myElem, (elem: EntityEveryConcept) => {
            return !isNameSpace(elem);
        });
        return result;
    }

    /**
     * Returns true if there are additional namespaces defined for 'this._myElem' in the scoper definition
     */
    private hasAdditionalNamespace() {
        // based on namespace addition for Entity
        if (this._myElem instanceof Entity) {
            return true;
        }

        return false;
    }

    /**
     * Adds the results of the search in additional namespaces as defined in the scoper definition
     * @param metatype
     */
    private addAdditionalNamespaces(metatype?: EntityMetaType): PiNamedElement[] {
        const result: PiNamedElement[] = [];
        // based on namespace addition for Entity
        if (this._myElem instanceof Entity) {
            // generated based on 'self.baseEntity'
            if (EntityNamespace.doNotSearch !== "baseEntity") {
                if (!!this._myElem.baseEntity) {
                    let extraNamespace = EntityNamespace.create(this._myElem.baseEntity?.referred);
                    EntityNamespace.joinResultsWithShadowing(extraNamespace.getVisibleElements(metatype), result);
                }
            }
        }

        return result;
    }

    /**
     * Returns true if a search in this namespace is already in progress for 'metatype'
     * @param metatype
     */
    private searchingFor(metatype?: EntityMetaType): boolean {
        const type: string = !!metatype ? metatype : anymetatype;
        if (this.searchList.includes(type)) {
            return true;
        } else {
            this.searchList.push(type);
        }
        return false;
    }

    /**
     * Removes the 'metatype' from the list of searches that are in progress
     * @param metatype
     */
    private cleanSearchList(metatype?: EntityMetaType) {
        const type: string = !!metatype ? metatype : anymetatype;
        const index = this.searchList.indexOf(type);
        if (index > -1) {
            this.searchList.splice(index, 1);
        }
    }
}
