// Generated by the ProjectIt Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SyntaxAnalyser = net.akehurst.language.api.syntaxAnalyser.SyntaxAnalyser;
import SharedPackedParseTree = net.akehurst.language.api.sppt.SharedPackedParseTree;
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import SPPTLeaf = net.akehurst.language.api.sppt.SPPTLeaf;
import SPPTNode = net.akehurst.language.api.sppt.SPPTNode;
import {
    PiElementReference,
    EntityModelUnit,
    EntityFunction,
    AbsExpression,
    AttributeRef,
    VariableRef,
    StringLiteralExpression,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    FunctionCallExpression,
    IfExpression,
    Variable,
    Entity,
    AttributeWithLimitedType,
    AttributeWithEntityType,
    EntityExpression,
    Type,
    AppliedFeature,
    AttributeType,
    LiteralExpression,
    MultiplyExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression
} from "../../language/gen";
import { PiNamedElement } from "@projectit/core";

/**
 *   Class EntityModelUnitSyntaxAnalyser is ... TODO
 *
 */
export class EntityModelUnitSyntaxAnalyser implements SyntaxAnalyser {
    locationMap: any;

    clear(): void {
        throw new Error("Method not implemented.");
    }

    transform<T>(sppt: SharedPackedParseTree): T {
        if (!!sppt.root) {
            return this.transformSharedPackedParseTreeNode(sppt.root) as unknown as T;
        } else {
            return null;
        }
    }

    private transformSharedPackedParseTreeNode(node: SPPTNode): any {
        try {
            if (node.isLeaf) {
                return this.transformSharedPackedParseTreeLeaf(node);
            } else if (node.isBranch) {
                return this.transformSharedPackedParseTreeBranch(node as SPPTBranch);
            }
        } catch (e) {
            if (e.message.startsWith("Syntax error in ") || e.message.startsWith("Error in EntityModelUnitSyntaxAnalyser")) {
                throw e;
            } else {
                // add more info to the error message
                throw new Error(`Syntax error in "${node?.matchedText}": ${e.message}`);
            }
        }
    }

    private transformSharedPackedParseTreeLeaf(node: SPPTNode): any {
        let tmp = ((node as SPPTLeaf)?.matchedText).trim();
        if (tmp.length > 0) {
            if (tmp.startsWith('"')) {
                // stringLiteral, strip the surrounding quotes
                tmp = tmp.slice(1, tmp.length - 1);
                return tmp;
            } else if (tmp == "false") {
                // booleanLiteral
                return false;
            } else if (tmp == "true") {
                // booleanLiteral
                return true;
            } else if (Number.isInteger(parseInt(tmp))) {
                // numberLiteral
                return parseInt(tmp);
            } else {
                // identifier
                return tmp;
            }
        }
        return null;
    }

    private transformSharedPackedParseTreeBranch(branch: SPPTBranch): any {
        let brName: string = branch.name;
        if ("EntityModelUnit" == brName) {
            return this.transformEntityModelUnit(branch);
        } else if ("EntityFunction" == brName) {
            return this.transformEntityFunction(branch);
        } else if ("AbsExpression" == brName) {
            return this.transformAbsExpression(branch);
        } else if ("AttributeRef" == brName) {
            return this.transformAttributeRef(branch);
        } else if ("VariableRef" == brName) {
            return this.transformVariableRef(branch);
        } else if ("StringLiteralExpression" == brName) {
            return this.transformStringLiteralExpression(branch);
        } else if ("NumberLiteralExpression" == brName) {
            return this.transformNumberLiteralExpression(branch);
        } else if ("BooleanLiteralExpression" == brName) {
            return this.transformBooleanLiteralExpression(branch);
        } else if ("FunctionCallExpression" == brName) {
            return this.transformFunctionCallExpression(branch);
        } else if ("IfExpression" == brName) {
            return this.transformIfExpression(branch);
        } else if ("Variable" == brName) {
            return this.transformVariable(branch);
        } else if ("Entity" == brName) {
            return this.transformEntity(branch);
        } else if ("AttributeWithLimitedType" == brName) {
            return this.transformAttributeWithLimitedType(branch);
        } else if ("AttributeWithEntityType" == brName) {
            return this.transformAttributeWithEntityType(branch);
        } else if ("EntityExpression" == brName) {
            return this.transformEntityExpression(branch);
        } else if ("AppliedFeature" == brName) {
            return this.transformAppliedFeature(branch);
        } else if ("LiteralExpression" == brName) {
            return this.transformLiteralExpression(branch);
        } else if ("__pi_binary_expression" == brName) {
            return this.transform__pi_binary_expression(branch);
        } else if ("AttributeType" == brName) {
            return this.transformAttributeType(branch);
        } else if ("__pi_reference" == brName) {
            return this.transform__pi_reference(branch);
        } else {
            throw new Error(`Error in EntityModelUnitSyntaxAnalyser: ${brName} not handled for node '${branch?.matchedText}'`);
        }
    }

    /**
     * Method to transform branches that match the following rule:
     * EntityModelUnit = 'model' identifier '{'
     *	 'entities:'
     *	 ( Entity ' &&' )*
     *	 'model' 'wide' 'functions:'
     *	 [ EntityFunction / ';' ]*
     *	 '}' ;
     * @param branch
     * @private
     */
    private transformEntityModelUnit(branch: SPPTBranch): EntityModelUnit {
        // console.log('transformEntityModelUnit called: ' + branch.name);
        let name: string;
        let entities: Entity[];
        let functions: EntityFunction[];
        const children = this.getChildren(branch);
        name = this.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSListGroup
        if (!children[4].isEmptyMatch) {
            entities = [];
            for (const subNode of children[4].nonSkipChildren.toArray()) {
                entities.push(this.transformSharedPackedParseTreeNode(this.getGroup(subNode).nonSkipChildren.toArray()[0]));
            }
        }
        functions = this.transformSharedPackedParseTreeList<EntityFunction>(children[8], ";"); // RHSPartListEntryWithSeparator

        return EntityModelUnit.create({ name: name, entities: entities, functions: functions });
    }
    /**
     * Method to transform branches that match the following rule:
     * EntityFunction = 'EntityFunction' identifier
     *	 'aliases' [ stringLiteral / ',' ]*
     *	 'expression' EntityExpression
     *	 'parameters'
     *	 Variable*
     *	 'declaredType' __pi_reference ;
     * @param branch
     * @private
     */
    private transformEntityFunction(branch: SPPTBranch): EntityFunction {
        // console.log('transformEntityFunction called: ' + branch.name);
        let name: string;
        let aliases: string[];
        let expression: EntityExpression;
        let parameters: Variable[];
        let declaredType: PiElementReference<Type>;
        const children = this.getChildren(branch);
        name = this.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        aliases = this.transformSharedPackedParseTreeList<string>(children[3], ","); // RHSPrimListEntryWithSeparator
        expression = this.transformSharedPackedParseTreeNode(children[5]); // RHSPartEntry
        parameters = this.transformSharedPackedParseTreeList<Variable>(children[7]); // RHSPartListEntry
        declaredType = this.piElemRef<Type>(children[9], "Type"); // RHSRefEntry

        return EntityFunction.create({
            name: name,
            aliases: aliases,
            expression: expression,
            parameters: parameters,
            declaredType: declaredType
        });
    }
    /**
     * Method to transform branches that match the following rule:
     * AbsExpression = 'AbsExpression'
     *	 'expr' EntityExpression
     *	 'appliedfeature' AppliedFeature? ;
     * @param branch
     * @private
     */
    private transformAbsExpression(branch: SPPTBranch): AbsExpression {
        // console.log('transformAbsExpression called: ' + branch.name);
        let expr: EntityExpression;
        let appliedfeature: AppliedFeature;
        const children = this.getChildren(branch);
        expr = this.transformSharedPackedParseTreeNode(children[2]); // RHSPartEntry
        // RHSPartOptionalEntry
        if (!children[4].isEmptyMatch) {
            // take the first element of the group that represents the optional part
            const subNode = this.getGroup(children[4]).nonSkipChildren.toArray()[0];
            appliedfeature = this.transformSharedPackedParseTreeNode(subNode);
        }
        return AbsExpression.create({ expr: expr, appliedfeature: appliedfeature });
    }
    /**
     * Method to transform branches that match the following rule:
     * AttributeRef = 'AttributeRef'
     *	 'appliedfeature' AppliedFeature?
     *	 'attribute' __pi_reference ;
     * @param branch
     * @private
     */
    private transformAttributeRef(branch: SPPTBranch): AttributeRef {
        // console.log('transformAttributeRef called: ' + branch.name);
        let appliedfeature: AppliedFeature;
        let attribute: PiElementReference<AttributeWithEntityType>;
        const children = this.getChildren(branch); // RHSPartOptionalEntry
        if (!children[2].isEmptyMatch) {
            // take the first element of the group that represents the optional part
            const subNode = this.getGroup(children[2]).nonSkipChildren.toArray()[0];
            appliedfeature = this.transformSharedPackedParseTreeNode(subNode);
        }
        attribute = this.piElemRef<AttributeWithEntityType>(children[4], "AttributeWithEntityType"); // RHSRefEntry

        return AttributeRef.create({ appliedfeature: appliedfeature, attribute: attribute });
    }
    /**
     * Method to transform branches that match the following rule:
     * VariableRef = 'VariableRef'
     *	 'appliedfeature' AppliedFeature?
     *	 'variable' __pi_reference ;
     * @param branch
     * @private
     */
    private transformVariableRef(branch: SPPTBranch): VariableRef {
        // console.log('transformVariableRef called: ' + branch.name);
        let appliedfeature: AppliedFeature;
        let variable: PiElementReference<Variable>;
        const children = this.getChildren(branch); // RHSPartOptionalEntry
        if (!children[2].isEmptyMatch) {
            // take the first element of the group that represents the optional part
            const subNode = this.getGroup(children[2]).nonSkipChildren.toArray()[0];
            appliedfeature = this.transformSharedPackedParseTreeNode(subNode);
        }
        variable = this.piElemRef<Variable>(children[4], "Variable"); // RHSRefEntry

        return VariableRef.create({ appliedfeature: appliedfeature, variable: variable });
    }
    /**
     * Method to transform branches that match the following rule:
     * StringLiteralExpression = '\\'' stringLiteral '\\'' ;
     * @param branch
     * @private
     */
    private transformStringLiteralExpression(branch: SPPTBranch): StringLiteralExpression {
        // console.log('transformStringLiteralExpression called: ' + branch.name);
        let value: string;
        const children = this.getChildren(branch);
        value = this.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry

        return StringLiteralExpression.create({ value: value });
    }
    /**
     * Method to transform branches that match the following rule:
     * NumberLiteralExpression = stringLiteral ;
     * @param branch
     * @private
     */
    private transformNumberLiteralExpression(branch: SPPTBranch): NumberLiteralExpression {
        // console.log('transformNumberLiteralExpression called: ' + branch.name);
        let value: string;
        const children = this.getChildren(branch);
        value = this.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry

        return NumberLiteralExpression.create({ value: value });
    }
    /**
     * Method to transform branches that match the following rule:
     * BooleanLiteralExpression = 'BooleanLiteralExpression'
     *	 'value' stringLiteral
     *	 'appliedfeature' AppliedFeature? ;
     * @param branch
     * @private
     */
    private transformBooleanLiteralExpression(branch: SPPTBranch): BooleanLiteralExpression {
        // console.log('transformBooleanLiteralExpression called: ' + branch.name);
        let value: string;
        let appliedfeature: AppliedFeature;
        const children = this.getChildren(branch);
        value = this.transformSharedPackedParseTreeNode(children[2]); // RHSPrimEntry
        // RHSPartOptionalEntry
        if (!children[4].isEmptyMatch) {
            // take the first element of the group that represents the optional part
            const subNode = this.getGroup(children[4]).nonSkipChildren.toArray()[0];
            appliedfeature = this.transformSharedPackedParseTreeNode(subNode);
        }
        return BooleanLiteralExpression.create({ value: value, appliedfeature: appliedfeature });
    }
    /**
     * Method to transform branches that match the following rule:
     * FunctionCallExpression = '+'
     *	 'CALL' __pi_reference '(' ')' ;
     * @param branch
     * @private
     */
    private transformFunctionCallExpression(branch: SPPTBranch): FunctionCallExpression {
        // console.log('transformFunctionCallExpression called: ' + branch.name);
        let functionDefinition: PiElementReference<EntityFunction>;
        const children = this.getChildren(branch);
        functionDefinition = this.piElemRef<EntityFunction>(children[2], "EntityFunction"); // RHSRefEntry

        return FunctionCallExpression.create({ functionDefinition: functionDefinition });
    }
    /**
     * Method to transform branches that match the following rule:
     * IfExpression = 'if' '(' EntityExpression ')' 'then'
     *	 EntityExpression
     *	 'else'
     *	 EntityExpression
     *	 'endif' ;
     * @param branch
     * @private
     */
    private transformIfExpression(branch: SPPTBranch): IfExpression {
        // console.log('transformIfExpression called: ' + branch.name);
        let condition: EntityExpression;
        let whenTrue: EntityExpression;
        let whenFalse: EntityExpression;
        const children = this.getChildren(branch);
        condition = this.transformSharedPackedParseTreeNode(children[2]); // RHSPartEntry
        whenTrue = this.transformSharedPackedParseTreeNode(children[5]); // RHSPartEntry
        whenFalse = this.transformSharedPackedParseTreeNode(children[7]); // RHSPartEntry

        return IfExpression.create({ condition: condition, whenTrue: whenTrue, whenFalse: whenFalse });
    }
    /**
     * Method to transform branches that match the following rule:
     * Variable = 'Variable' identifier
     *	 'declaredType' __pi_reference ;
     * @param branch
     * @private
     */
    private transformVariable(branch: SPPTBranch): Variable {
        // console.log('transformVariable called: ' + branch.name);
        let name: string;
        let declaredType: PiElementReference<Entity>;
        const children = this.getChildren(branch);
        name = this.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        declaredType = this.piElemRef<Entity>(children[3], "Entity"); // RHSRefEntry

        return Variable.create({ name: name, declaredType: declaredType });
    }
    /**
     * Method to transform branches that match the following rule:
     * Entity = 'COMPANY'? 'entity' identifier ( 'base' __pi_reference )?
     *	 '{'
     *	 AttributeWithLimitedType*
     *	 EntityFunction*
     *	 '}' ;
     * @param branch
     * @private
     */
    private transformEntity(branch: SPPTBranch): Entity {
        // console.log('transformEntity called: ' + branch.name);
        let isCompany: boolean;
        let name: string;
        let baseEntity: PiElementReference<Entity>;
        let attributes: AttributeWithLimitedType[];
        let functions: EntityFunction[];
        const children = this.getChildren(branch);
        // RHSOptionalGroup
        if (!children[0].isEmptyMatch) {
            const optBranch = this.getChildren(children[0]);
            // RHSBooleanWithKeyWord
            if (!optBranch[0].isEmptyMatch) {
                isCompany = true;
            }
        }
        name = this.transformSharedPackedParseTreeNode(children[2]); // RHSPrimEntry

        // RHSOptionalGroup
        if (!children[3].isEmptyMatch) {
            const optGroup = this.getGroup(children[3]).nonSkipChildren.toArray();
            baseEntity = this.piElemRef<Entity>(optGroup[1], "Entity"); // RHSRefEntry
        }
        attributes = this.transformSharedPackedParseTreeList<AttributeWithLimitedType>(children[5]); // RHSPartListEntry
        functions = this.transformSharedPackedParseTreeList<EntityFunction>(children[6]); // RHSPartListEntry

        return Entity.create({ isCompany: isCompany, name: name, baseEntity: baseEntity, attributes: attributes, functions: functions });
    }
    /**
     * Method to transform branches that match the following rule:
     * AttributeWithLimitedType = identifier ':' AttributeType ;
     * @param branch
     * @private
     */
    private transformAttributeWithLimitedType(branch: SPPTBranch): AttributeWithLimitedType {
        // console.log('transformAttributeWithLimitedType called: ' + branch.name);
        let name: string;
        let declaredType: PiElementReference<AttributeType>;
        const children = this.getChildren(branch);
        name = this.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        declaredType = this.piElemRef<AttributeType>(children[2], "AttributeType"); // RHSLimitedRefEntry

        return AttributeWithLimitedType.create({ name: name, declaredType: declaredType });
    }
    /**
     * Method to transform branches that match the following rule:
     * AttributeWithEntityType = 'AttributeWithEntityType' identifier
     *	 'declaredType' __pi_reference ;
     * @param branch
     * @private
     */
    private transformAttributeWithEntityType(branch: SPPTBranch): AttributeWithEntityType {
        // console.log('transformAttributeWithEntityType called: ' + branch.name);
        let name: string;
        let declaredType: PiElementReference<Entity>;
        const children = this.getChildren(branch);
        name = this.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        declaredType = this.piElemRef<Entity>(children[3], "Entity"); // RHSRefEntry

        return AttributeWithEntityType.create({ name: name, declaredType: declaredType });
    }

    /**
     * Method to transform branches that match the following rule:
     * EntityExpression = AbsExpression
     *    | VariableRef
     *    | LiteralExpression
     *    | FunctionCallExpression
     *    | IfExpression
     *    | __pi_binary_expression ;
     * @param branch
     * @private
     */
    private transformEntityExpression(branch: SPPTBranch): EntityExpression {
        // console.log('transformEntityExpression called: ' + branch.name);
        return this.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * AppliedFeature = AttributeRef  ;
     * @param branch
     * @private
     */
    private transformAppliedFeature(branch: SPPTBranch): AppliedFeature {
        // console.log('transformAppliedFeature called: ' + branch.name);
        return this.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * LiteralExpression = StringLiteralExpression
     *    | NumberLiteralExpression
     *    | BooleanLiteralExpression  ;
     * @param branch
     * @private
     */
    private transformLiteralExpression(branch: SPPTBranch): LiteralExpression {
        // console.log('transformLiteralExpression called: ' + branch.name);
        return this.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Generic method to transform binary expressions, which are parsed
     * according to these rules:
     * __pi_binary_expression = [EntityExpression / __pi_binary_operator]2+ ;
     * leaf __pi_binary_operator = '*' | '+' | '/' | 'AndExpression' | 'or' | '<' | 'GreaterThenExpression' | 'EqualsExpression' ;
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     * @param branch
     * @private
     */
    private transform__pi_binary_expression(branch: SPPTBranch): EntityExpression {
        // console.log('transform__pi_binary_expression called: ' + branch.name);
        const children = branch.nonSkipChildren.toArray();
        const actualList = children[0].nonSkipChildren.toArray();
        let index = 0;
        let first = this.transformSharedPackedParseTreeNode(actualList[index++]);
        while (index < actualList.length) {
            let operator = this.transformSharedPackedParseTreeNode(actualList[index++]);
            let second = this.transformSharedPackedParseTreeNode(actualList[index++]);
            let combined: EntityExpression = null;
            switch (operator) {
                case "*": {
                    combined = MultiplyExpression.create({ left: first, right: second });
                    break;
                }
                case "+": {
                    combined = PlusExpression.create({ left: first, right: second });
                    break;
                }
                case "/": {
                    combined = DivideExpression.create({ left: first, right: second });
                    break;
                }
                case "AndExpression": {
                    combined = AndExpression.create({ left: first, right: second });
                    break;
                }
                case "or": {
                    combined = OrExpression.create({ left: first, right: second });
                    break;
                }
                case "<": {
                    combined = LessThenExpression.create({ left: first, right: second });
                    break;
                }
                case "GreaterThenExpression": {
                    combined = GreaterThenExpression.create({ left: first, right: second });
                    break;
                }
                case "EqualsExpression": {
                    combined = EqualsExpression.create({ left: first, right: second });
                    break;
                }
                default: {
                    combined = null;
                }
            }
            first = combined;
        }
        return first;
    }

    /**
     * Method to transform branches that match the following rule:
     * AttributeType = identifier ;
     * @param branch
     * @private
     */
    private transformAttributeType(branch: SPPTBranch): string {
        return branch.matchedText;
    }

    /**
     * Generic method to get the children of a branch. Throws an error if no children can be found.
     */
    private getChildren(branch: SPPTBranch): any {
        let children: any = null;
        try {
            return branch.nonSkipChildren.toArray();
        } catch (e) {
            throw new Error(`Cannot follow branch: ${e.message} (${branch.matchedText})`);
        }
        return children;
    }

    /**
     * Generic method to get the optional group of a branch. Throws an error if no group can be found.
     */
    private getGroup(branch: SPPTBranch) {
        // take the first element in the [0..1] optional group or multi branch
        let group: any = branch;
        let stop: boolean = false;
        while (!stop) {
            let nextOne: any = null;
            try {
                nextOne = group.nonSkipChildren.toArray()[0];
            } catch (e) {
                throw new Error(`Cannot follow group: ${e.message} (${group.matchedText})`);
            }
            if (!nextOne.name.includes("multi") && !nextOne.name.includes("group")) {
                stop = true; // found a branch with actual content, return its parent!
            } else {
                group = nextOne;
            }
        }
        return group;
    }

    private transform__pi_reference(branch: SPPTBranch) {
        if (branch.name.includes("multi") || branch.name.includes("List")) {
            return this.transformSharedPackedParseTreeList<string>(branch, "::");
        } else {
            return this.transformSharedPackedParseTreeLeaf(branch);
        }
    }

    /**
     * Generic method to transform references
     * ...PiElemRef = identifier;
     */
    private piElemRef<T extends PiNamedElement>(branch: SPPTBranch, typeName: string): PiElementReference<T> {
        let referred: string | string[] | T = this.transformSharedPackedParseTreeNode(branch);
        if (referred == null || referred == undefined) {
            throw new Error(`Syntax error in "${branch?.parent?.matchedText}": cannot create empty reference`);
        } else if (typeof referred === "string" && (referred as string).length == 0) {
            throw new Error(`Syntax error in "${branch?.parent?.matchedText}": cannot create empty reference`);
        } else {
            return PiElementReference.create<T>(referred, typeName);
        }
    }

    /**
     * Generic method to transform lists
     */
    private transformSharedPackedParseTreeList<T>(branch: SPPTBranch, separator?: string): T[] {
        let result: T[] = [];
        const children = this.getChildren(branch);
        if (!!children) {
            for (const child of children) {
                let element: any = this.transformSharedPackedParseTreeNode(child);
                if (element !== null && element !== undefined) {
                    if (separator == null || separator == undefined) {
                        result.push(element);
                    } else {
                        if (element != separator) {
                            result.push(element);
                        }
                    }
                }
            }
        }
        return result;
    }

    /**
     * Generic method to transform lists of references
     */
    private transformSharedPackedParseTreeRefList<T extends PiNamedElement>(
        branch: SPPTBranch,
        typeName: string,
        separator?: string
    ): PiElementReference<T>[] {
        let result: PiElementReference<T>[] = [];
        const children = this.getChildren(branch);
        if (!!children) {
            for (const child of children) {
                let refName: any = this.transformSharedPackedParseTreeNode(child);
                if (refName !== null && refName !== undefined && refName.length > 0) {
                    if (separator === null || separator === undefined) {
                        result.push(PiElementReference.create<T>(refName, typeName));
                    } else {
                        if (refName !== separator) {
                            result.push(PiElementReference.create<T>(refName, typeName));
                        }
                    }
                }
            }
        }
        return result;
    }
}
