// Generated by the Freon Language Generator.
import { FreReader } from "@freon4dsl/core";
import { net } from "net.akehurst.language-agl-processor";
import LanguageProcessor = net.akehurst.language.api.processor.LanguageProcessor;
import Agl = net.akehurst.language.agl.processor.Agl;
import AutomatonKind_api = net.akehurst.language.api.processor.AutomatonKind_api;
import { EntityModelUnitType, ModelUnitMetaType, EntityModel } from "../../language/gen";
import { EntityGrammarStr } from "./EntityGrammar";
import { EntitySyntaxAnalyser } from "./EntitySyntaxAnalyser";
import { EntitySemanticAnalyser } from "./EntitySemanticAnalyser";

/**
 *   Class EntityModelUnitReader is a wrapper for the various parsers of
 *   modelunits.
 */
export class EntityModelUnitReader implements FreReader {
    analyser: EntitySyntaxAnalyser = new EntitySyntaxAnalyser();
    parser: LanguageProcessor = Agl.processorFromString(EntityGrammarStr, this.analyser, null, null);

    /**
     * Parses and performs a syntax analysis on 'sentence', using the parser and analyser
     * for 'metatype', if available. If 'sentence' is correct, a model unit will be created,
     * otherwise an error wil be thrown containing the parse or analysis error.
     * @param sentence      the input string which will be parsed
     * @param metatype      the type of the unit to be created
     * @param model         the model to which the unit will be added
     * @param sourceName    the (optional) name of the source that contains 'sentence'
     */
    readFromString(sentence: string, metatype: ModelUnitMetaType, model: EntityModel, sourceName?: string): EntityModelUnitType {
        this.analyser.sourceName = sourceName;
        let startRule: string = "";
        // choose the correct parser
        if (metatype === "SomeOtherModelUnit") {
            startRule = "SomeOtherModelUnit";
        } else if (metatype === "EntityModelUnit") {
            startRule = "EntityModelUnit";
        }

        // parse the input
        let unit: EntityModelUnitType = null;
        if (this.parser) {
            try {
                let asm;
                if (startRule.length > 0) {
                    asm = this.parser.processForGoal(null, startRule, sentence, AutomatonKind_api.LOOKAHEAD_1);
                } else {
                    asm = this.parser.process(null, sentence, AutomatonKind_api.LOOKAHEAD_1);
                }
                unit = asm as EntityModelUnitType;
            } catch (e) {
                // strip the error message, otherwise it's too long for the webapp
                let mess = e.message.replace("Could not match goal,", "Parse error in " + sourceName + ":");
                if (!!mess && mess.length > 0) {
                    console.log(mess);
                    throw new Error(mess);
                } else {
                    throw e;
                }
            }
            // do semantic analysis taking into account the whole model, because references could be pointing anywhere
            if (!!model) {
                try {
                    if (model.getUnits().filter(existing => existing.name === unit.name).length > 0) {
                        throw new Error(`Unit named '${unit.name}' already exists.`);
                    } else {
                        model.addUnit(unit);
                        const semAnalyser = new EntitySemanticAnalyser();
                        semAnalyser.correct(unit);
                    }
                } catch (e) {
                    console.log(e.message);
                    throw e;
                }
            }
        } else {
            throw new Error(`No parser for ${metatype} available: grammar incorrect.`);
        }
        return unit;
    }
}
