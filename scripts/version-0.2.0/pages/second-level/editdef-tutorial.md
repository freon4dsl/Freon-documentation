






# The Editor Definition

## Three-level definition
As explained in (/010_Intro/050_Three_Levels_of_Customization#levels[Three-levels to Customize your Pi-tools] the generated editor can be defined at three levels.
For each **concept* in the AST the editor will

. use the *hand-made projection*, when this is present. Otherwise the editor will
. use to the *projection generated from the editor definition*, when this definition is present. Finally, the editor will
. use the *default projection*.

When a **concept* is marked as an **binary expression concept**, its default projection is usually the one you want to go with,
because of the extra (/010_Intro/010_Projectional_Editing#expressions[support for expressions] that is incorporated in it.

The rest of this tutorial explains the 2nd level: how to write an editor definition (`.edit` file).
For making more adjustments to the projection by adding hand-made projections on the 3rd level, see the
tutorial on (/050_Third_level/editor-third-level[using the framework].

## The Editor Definition File
In the editor definition file (`.edit` file) you can define a ProjectIt editor by providing extra information
for each **concept* in your language. Currently, you can define the following three items.

**	**Projection**, which is how the **concept* is shown in the editor.
**	**Trigger**, which is the key or keys your user needs to type to create a new instance of the **concept**.
**	**Symbol**, which is optional and only used for **binary expressions**. It is the character or character string that is
shown when a **binary expression* is being added to your user’s model. When the **symbol* is not present, the **trigger* will be used.

### Projections
In the `.edit` file a **projection* is defined between angular brackets.
This is done in a style similar from markdown, what you see looks close to what you get.
Everything within the square brackets (`[]`), except
the parts surrounded by `${ }`, is taken literally, including any indentation.

```ts
// LanguageDefinition.edit[tag=literal]
```ts

When the indentation of the opening and closing brackets aligns, this indentation is not taken into account.
The column in which the brackets appear is seen as the first column of the projection.
The
above example will show the text "This is" at the beginning of the line footnote:[This is not completely true. There will
be no indentation in the block that is generated by this projection. However, the projection as a whole may be indented
because it is included in another (bigger) projection.], but the text "for every concept of type Text"
will be shown with an indentation of 8 spaces. If the closing bracket would be positioned on the line after the text,
and it would have been indented with 8 spaces, then the text "for every concept of type Text"
would be shown without any indentation.


```ts
// LanguageDefinition.edit[tag=indentation]
```ts

Using ‘[+’ you can indicate that a newline should be added.

```ts
// LanguageDefinition.edit[tag=newlines]
```ts

### Including Subprojections

Using **${ }* you tell ProjectIt to include a property. Its projection is defined by the projection for its concept.

In the following example `${self.condition}` is a property of type `BooleanLiteralExpression`.
It will be projected according to the definition for this concept, whereas `${self.whenTrue}` is a
property of type `EntityExpression`, which is abstract. This property
will be projected according to the definition for subtype of `EntityExpression` that is currently found.


```ts
// LanguageDefinition.edit[tag=subprojection]
```ts

### Lists
If a property is a list, you can indicate whether it should be projected horizontally or vertically.
The default is horizontal.

Furthermore, you can add either a *separator* string in between all elements, or a *terminator* string after each element. Both are optional.

```ts
// LanguageDefinition.edit[tag=lists]
```ts

