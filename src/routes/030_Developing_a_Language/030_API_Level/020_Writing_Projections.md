<script>
    import Note from "../../../lib/notes/Note.svelte";
    import Figure from "../../../lib/figures/Figure.svelte";
</script>

# <a name="writing-projections"></a> Writing Projections in TypeScript

The editor is always an implementation of the interface 
[`PiProjection`](/060_Under_the_Hood/010_The_Editor_Framework/020_The_Editor_Interfaces/010_PiProjection_Interface). The 
implementation generated by ProjectIt is located in the file `~/picode/editor/gen/<yourLanguageName>ProjectionDefault.ts`.
It holds projections for **all concepts** in the language. When a projection is given in the `.edit` 
file this is the one that will be in
the implementation, when no projection is defined, a default projection will be generated.

As you can read in the [ProjectIt Editor Framework](/060_Under_the_Hood/010_The_Editor_Framework)  ,
all projections are based on boxes. In the next few steps we will show you how to build a hierarchy
of boxes to project your AST nodes, and how to style these boxes according to your wishes.

The projections in this section are available in 
the <a href="https://github.com/projectit-org/ProjectIt-example" target="_blank">ProjectIt-example</a>.

## Customize by implementing `getBox()`

In order to customize the editor you need to implement the `getBox(...)` method in the
file `~/picode/editor/Custom<yourLanguageName>Projection.ts`.
For every concept that needs a customized projection, it should
return a `Box` object. For all other concepts it should simply return `null`.
This way ProjectIt will know that you did not define a projection yourself and will use the projection
defined in `~/picode/editor/gen/<yourLanguageName>ProjectionDefault`.

```ts
// tutorial-language/editor/CustomEntityProjection.ts#L40-L43

getBox(element: PiElement): Box {
    // Add any handmade projections of your own before next statement
    return null;
}
```

<Note><svelte:fragment slot="header">Use another filename and/or location</svelte:fragment>
<svelte:fragment slot="content">
You can rename the file `~/picode/editor/Custom<yourLanguageName>Projection.ts` and/or put it in another location.
In that case, you need to adjust the file `projectit/ProjectItConfiguration`.
</svelte:fragment>
</Note>

## How to Create a Box Object

### Step 1 - Projecting a Simple Property

We start with building the projection for a simple property of type `identifier`:
the name of the unit in our Entity language. In the metamodel this is represented by the value of
the property `name` of class `EntityModelUnit`.

```ts
// tutorial-language/defs/LanguageDefinition.ast#L56-L61

modelunit EntityModelUnit {
    public name: identifier;

    functions: EntityFunction[];
    entities: Entity[];
}
```

A reasonable choice for the projection of this property is a 
`HorizontalListBox` which holds a `LabelBox` with
the name of the class, followed by the value stored in the variable *name*. 
The following code shows a method that returns
this `HorizontalListBox`. This method should be called in the overall method `getBox(...)`.

```ts
// tutorial-language/editor/CustomEntityProjection.ts#L45-L51

// Most simple model box
private createModelBox(model: EntityModelUnit): Box {
    return new HorizontalListBox(model, "model", [
        new LabelBox(model, "model-label", "Model"),
        new TextBox(model, "model-name", () => model.name, (c: string) => (model.name = c))
    ]);
}
```

When we start the editor based on this projection, we see the following:

<Figure
    imageName={"demomodelname.png"}
    caption={"Simple Projection of a name property"}
    figureNumber={1}
></Figure>


It doesn't look very nice currently.

1. The label is not distinguishable from the name of the model.
2. When the name of the model becomes empty, there is no visual clue that you can add a name.

### Step 2 - Adding Style and a PlaceHolder
To make the label look different from the value of the property, we need to add a style
to the `LabelBox`. To do so, we associate the `LabelBox` with the style `projectitStyles.keyword`.
This will project it in a different color.

Also, we give the `TextBox` has a `placeHolder` property. The placeholder will be shown
whenever the contents of the `TextBox`
is empty, giving the user a visual clue that a name could be entered.

```ts
// tutorial-language/editor/CustomEntityProjection.ts#L53-L63

// Modelbox with style added
private createModelBox2(model: EntityModelUnit): Box {
    return new HorizontalListBox(model, "model", [
        new LabelBox(model, "model-label", "Model", {
            style: styleToCSS(projectitStyles.keyword)
        }),
        new TextBox(model, "model-name", () => model.name, (c: string) => (model.name = c), {
            placeHolder: "<name>"
        })
    ]);
}
```

The result looks a lot better.

<Figure
    imageName={"demomodelname-with-style.png"}
    caption={"Simple Projection with Styles"}
    figureNumber={2}
></Figure>


The style `projectitStyles.keyword` is defined in the file `~/picode/editor/styles/styles.ts` as follows.
In principle all CSS styles can be used here. Learn more about styling
in [Styling](/030_Developing_a_Language/030_API_Level/090_Styling).



```ts
// tutorial-language/editor/styles/styles.ts#L37-L40

export const keyword: PiStyle = {
    "font-weight": "bold",
    color: "blue"
};
```

### Step 3 - Projecting a List

Next, we will add the `entities` property of the `EntityModelUnit` to the projection.
The `entities` property is a list of `Entity`.

```ts
// tutorial-language/defs/LanguageDefinition.ast#L60-L60

entities: Entity[];
```

In the projection we add a `LabelBox`, to be shown
before the list, and the list itself using a `VerticalListBox` to make sure that this list is
displayed vertically. Note that the `LabelBox` is styled as a keyword, like the `LabelBox`
in the previous step.

```ts
// tutorial-language/editor/CustomEntityProjection.ts#L67-L86

return new VerticalListBox(model, "model", [
    new HorizontalListBox(model, "model-info", [
        new LabelBox(model, "model-keyword", "Model", {
            style: styleToCSS(projectitStyles.keyword)
        }),
        new TextBox(model, "model-name", () => model.name, (c: string) => (model.name = c), {
            placeHolder: "<name>"
        })
    ]),
    new LabelBox(model, "entity-keyword", "Entities", {
        style: styleToCSS(projectitStyles.keyword)
    }),
    new VerticalListBox(
        model,
        "entity-list",
        model.entities.map(ent => {
            return this.rootProjection.getBox(ent);
        })
    )
]);
```

The projection of a single `Entity` is done using `this.rootProjection.getBox(ent)`. This will call a
separate function (here called `createEntityBox`) that also returns a `Box`, thus building a hierarchy of boxes. The use of
`this.rootProjection.getBox(ent)`, instead of directly calling `createEntityBox`,
ensures that the proper projection for entity is used, following the rules laid down in
[customize projections](/030_Developing_a_Language/020_ProjectIt_Definition_Level/010_Editor_Definition#editor-three-levels).

We can track the hierarchy of boxes. First, have a look at the projection for `Entity`, which is defines as follows in the .ast.

```ts
// tutorial-language/defs/LanguageDefinition.ast#L26-L32

concept Entity implements Type {
    isCompany: boolean;
    attributes: AttributeWithLimitedType[];
    entAttributes: AttributeWithEntityType[];
    functions: EntityFunction[];
    reference baseEntity?: Entity;
}
```

Its projection is very similar to the projection of the `EntityModel`,
showing the keyword *Entity* followed by its name and below all properties of the
entity in a `VerticalListBox`.

```ts
// tutorial-language/editor/CustomEntityProjection.ts#L108-L127

private createEntityBox(entity: Entity): Box {
    return new VerticalListBox(entity,"entity",
        [
            new HorizontalListBox(entity, "entity-info", [
                new LabelBox(entity, "entity-keyword", "Entity", {
                    style: styleToCSS(projectitStyles.keyword)
                }),
                new TextBox(entity, "entity-name",
                    () => entity.name,
                    (c: string) => (entity.name = c),
                    { placeHolder: "<name>" })
            ]),
            new VerticalListBox( entity, "attribute-list",
                entity.attributes.map(att => {
                    return this.rootProjection.getBox(att);
                })
            )
        ]
    );
}
```

Next in the hierarchy of boxes is the projection of the elements of the `attributes` list. Once again,
this projection is defined in its own function. Have a look at the .ast definition and the projection method.
Here, we use a `HorizontalListBox` to show the property name, followed by a colon,
followed by its type.

```ts
// tutorial-language/defs/LanguageDefinition.ast#L71-L74

concept AttributeWithLimitedType {
    reference declaredType: AttributeType;
    name: identifier;
}
```

```ts
// tutorial-language/editor/CustomEntityProjection.ts#L71-L106
```

### Step 4 - Adding Behavior

The projection so far is exactly that: a projection. There are no actions defined yet,
which we need to enable the user to change the model and add elements to it. However,
we do have the built-in default behavior of the editor:

- Inside a TextBox the text can be edited.
- Using the arrow keys the user can navigate the projection.
- Using Ctrl-Arrow the user can navigate up and down the model/AST.
- When an element is selected, it can be deleted with the DEL key.

The default behavior takes care of changing simple AST nodes and deleting both simple and
complex AST nodes. Find out more about adding behavior in [Writing Actions](/030_Developing_a_Language/030_API_Level/030_Writing_Actions).
