<script>
    import Note from "$lib/notes/Note.svelte";
    import Figure from "$lib/figures/Figure.svelte";
</script>

# <a name="writing-projections"></a> Writing Projections in TypeScript

The editor is always an implementation of the interface
[`PiProjection`](/060_Under_the_Hood/010_The_Editor_Framework/020_The_Editor_Interfaces/010_PiProjection_Interface). The
implementation generated by Freon is located in the file `~/picode/editor/gen/<yourLanguageName>ProjectionDefault.ts`.
It holds projections for **all concepts** in the language. When a projection is given in the `.edit`
file this is the one that will be in
the implementation, when no projection is defined, a default projection will be generated.

As you can read in the [Freon Editor Framework](/060_Under_the_Hood/010_The_Editor_Framework) ,
all projections are based on boxes. In the next few steps we will show you how to build a hierarchy
of boxes to project your AST nodes, and how to style these boxes according to your wishes.

The projections in this section are available in
the <a href="https://github.com/freon4dsl/Freon-example.git" target="_blank">Freon-example</a>.

## Customize by implementing `getBox()`

In order to customize the editor you need to implement the `getBox(...)` method in the
file `~/picode/editor/Custom<yourLanguageName>Projection.ts`.
For every concept that needs a customized projection, it should
return a `Box` object. For all other concepts it should simply return `null`.
This way Freon will know that you did not define a projection yourself and will use the projection
defined in `~/picode/editor/gen/<yourLanguageName>ProjectionDefault`.

```ts
// TutorialLanguage/src/editor/CustomEntityModelProjection.ts#L40-L43

}

```

<Note><svelte:fragment slot="header">Use another filename and/or location</svelte:fragment>
<svelte:fragment slot="content">
You can rename the file `~/picode/editor/Custom<yourLanguageName>Projection.ts` and/or put it in another location.
In that case, you need to adjust the file `config/ProjectItConfiguration`.
</svelte:fragment>
</Note>

## How to Create a Box Object

### Step 1 - Projecting a Simple Property

We start with building the projection for a simple property of type `identifier`:
the name of the unit in our Entity language. In the metamodel this is represented by the value of
the property `name` of class `EntityModelUnit`.

```ts
// TutorialLanguage/src/defs/LanguageDefinition.ast#L56-L61

modelunit EntityModelUnit {
    name: identifier;

    functions: EntityFunction[];
    entities: Entity[];
}
```

A reasonable choice for the projection of this property is a
`HorizontalListBox` which holds a `LabelBox` with
the name of the class, followed by the value stored in the variable _name_.
The following code shows a method that returns
this `HorizontalListBox`. This method should be called in the overall method `getBox(...)`.

```ts
// TutorialLanguage/src/editor/CustomEntityModelProjection.ts#L45-L51


```

When we start the editor based on this projection, we see the following:

<Figure
    imageName={"demomodelname.png"}
    caption={"Simple Projection of a name property"}
    figureNumber={1}>
</Figure>

### Step 2 - Adding Style and a PlaceHolder

[//]: # "// TODO Jos, please create new text for styling"

In version 0.5.0 this has been changed such that you can use CSS classes. More info follows...

### Step 3 - Projecting a List

Next, we will add the `entities` property of the `EntityModelUnit` to the projection.
The `entities` property is a list of `Entity`.

```ts
// TutorialLanguage/src/defs/LanguageDefinition.ast#L60-L60

entities: Entity[];
```

In the projection we add a `LabelBox`, to be shown
before the list, and the list itself using a `VerticalListBox` to make sure that this list is
displayed vertically. Note that the `LabelBox` is styled as a keyword, like the `LabelBox`
in the previous step.

```ts
// TutorialLanguage/src/editor/CustomEntityModelProjection.ts#L67-L86


```

The projection of a single `Entity` is done using `this.rootProjection.getBox(ent)`. This will call a
separate function (here called `createEntityBox`) that also returns a `Box`, thus building a hierarchy of boxes. The use of
`this.rootProjection.getBox(ent)`, instead of directly calling `createEntityBox`,
ensures that the proper projection for entity is used, following the rules laid down in
[customize projections](/030_Developing_a_Language/020_Definition_Level/010_Editor_Definition#editor-three-levels).

We can track the hierarchy of boxes. First, have a look at the projection for `Entity`, which is defines as follows in the .ast.

```ts
// TutorialLanguage/src/defs/LanguageDefinition.ast#L26-L32

concept Entity implements Type {
    isCompany: boolean;
    attributes: AttributeWithLimitedType[];
    entAttributes: AttributeWithEntityType[];
    functions: EntityFunction[];
    reference baseEntity?: Entity;
}
```

Its projection is very similar to the projection of the `EntityModel`,
showing the keyword _Entity_ followed by its name and below all properties of the
entity in a `VerticalListBox`.

```ts
// TutorialLanguage/src/editor/CustomEntityModelProjection.ts#L108-L127


```

Next in the hierarchy of boxes is the projection of the elements of the `attributes` list. Once again,
this projection is defined in its own function. Have a look at the .ast definition and the projection method.
Here, we use a `HorizontalListBox` to show the property name, followed by a colon,
followed by its type.

```ts
// TutorialLanguage/src/defs/LanguageDefinition.ast#L71-L74

concept AttributeWithLimitedType {
    reference declaredType: AttributeType;
    name: identifier;
}
```

```ts
// TutorialLanguage/src/defs/LanguageDefinition.ast#L56-L61

modelunit EntityModelUnit {
    name: identifier;

    functions: EntityFunction[];
    entities: Entity[];
}
```

```ts
// TutorialLanguage/src/editor/CustomEntityModelProjection.ts#L151-L188


```

### Step 4 - Adding Behavior

The projection so far is exactly that: a projection. There are no actions defined yet,
which we need to enable the user to change the model and add elements to it. However,
we do have the built-in default behavior of the editor:

- Inside a TextBox the text can be edited.
- Using the arrow keys the user can navigate the projection.
- Using Ctrl-Arrow the user can navigate up and down the model/AST.
- When an element is selected, it can be deleted with the DEL key.

The default behavior takes care of changing simple AST nodes and deleting both simple and
complex AST nodes. Find out more about adding behavior in [Writing Actions](/030_Developing_a_Language/030_API_Level/030_Writing_Actions).
